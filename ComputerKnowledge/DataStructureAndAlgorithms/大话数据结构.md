# 《大话数据结构》

# 1. 线性表

【特性】

* 零个或多个数据元素的有限序列（有顺序）
* 线性表元素的个数n为线性表的长度



【定义】

```apl
ADT List(线性表)
Data
	线性表的数据对象集合为{a1,a2,a3,...,an}，每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系
Operation
	InitList(*L) := 初始化操作，建立一个空的线性表L
	ListEmpty(L) := 若线性表为空，返回true，否则返回false
	ClearList(*L) := 将线性表清空
	GetElem(L,i,*e) := 将线性表L中的第i个位置元素值返回给e
	LocateElem(L,e) := 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败
	ListInsert(*L,i,e) := 在线性表L中的第i个位置插入新元素e
	ListDelete(*L,i,*e) := 删除线性表L中第i个位置元素，并用e返回其值
	ListLength(L) := 返回线性表L的元素个数
endADT
```

## 1.1 线性表的线性存储结构

【特性】

* 用连续地址的存储单元存储线性表元素
* 一维数组即可实现

* 地址计算方法（LOC函数）：LOC(ai) = LOC(a1) + (i - 1) * c（每个元素占据c个存储单元）
* 存取时间性能为O(1)，为随机存取结构

* 线性表长度要小于数组长度



【性能优缺点】

优点：

* 插入到最后一个元素：O(1)
* 删除最后一个元素：O(1)
* 读取任意位置元素：O(1)
* 快速存取

缺点：

* 插入到第一个位置：O(n)
* 删除第一个位置元素：O(n)
* 插入第i个和删除第i个平均为：O(n)
* 插入和删除需要移动大量元素

## 1.2 线性表的链式存储结构

### 1.2.1 单链表

【特性】

* 地址并不连续的存储单元存储元素
* 元素由节点Node存储，节点由指针域和数据域组成
* 指针域只指向后继



【性能优缺点】

时间性能

优点：

* 插入和删除：O(1)

缺点：

* 查找：O(n)

空间性能：单链表无需预分配存储空间，元素个数不受限制



【单链表与顺序存储】

频繁查找，很少插入删除：顺序存储

频繁插入删除：单链表

元素变化较大且不知数量：单链表

提前知道线性表长度：顺序存储

### 1.2.2 静态链表

【特性】

* 用数组替代指针来描述单链表
* 数组每个元素都有两个数据域：data 和 cur
* data是存放数据用。cur为存放该元素的后继在数组中的下标位置，也叫游标
* 数组第一个和最后一个位置不存数据，作为特殊元素
* 未被使用的数组元素为备用链表
* 数组第一个元素，cur存放备用链表的第一个结点的下标位置，备用链表的头指针
* 数组的最后一个元素，cur存放第一个有数值的元素的下标位置，相当于头结点
* 线性表的最后一个有值元素的下一位置为空，所以最后一个有值元素的cur存放0



【性能优缺点】

优点

* 插入删除：O(1)

缺点

* 平均查找：O(n)（单链表的特性）

* 失去了顺序存储结构的随机存取

### 1.2.3 循环链表

【特性】

* 单链表终结点指针指向头结点，成为单循环链表
* 从一个节点出发访问到链表的全部节点
* 判断遍历的结束条件为：下一节点不为头结点



【性能优缺点】

优点

* 查找头尾结点：O(1)

### 1.2.4 双向链表

【特性】

* 每个节点都有前驱和后继，两个指针域
* 许多操作与单链表相同，只涉及一个方向
* 也可以是循环链表



【性能优缺点】

优点

* 插入和删除：O(1)
* 查找头尾结点：O(1)

缺点：

* 平均查找：O(n)

------



# 2. 栈

【特性】

* 仅在表尾进行插入和删除操作的**线性表**
* 后进先出（Last In First Out）
* 允许插入和删除的一端为栈顶（top），另一端为栈底（bottom）
* 栈顶就是表尾
* 最先进入的只能在栈底



【定义】

```apl
ADT Stack(栈)
Data
	同线性表。元素具有相同类型，相邻元素具有前驱和后继关系
Operation
	InitStack(*S) := 初始化操作，建立一个空栈S
	DestroyStack(*S) := 若栈存在就销毁
	ClearStack(*S) := 将栈清空
	StackEmpty(S) := 若栈为空，返回true，否则返回false
	GetTop(S,*e) := 若栈存在且非空，用e返回S的栈顶元素
	Push(*S,e) := 若栈S存在，插入新元素e到栈S中并成为栈顶元素
	Pop(*S,*e) := 删除栈S中栈顶元素，并用e返回其值
	StackLength(S) := 返回栈S的元素个数
endADT
```

## 2.1 栈的顺序存储结构

【特性】

* 为线性表的顺序存储的简化
* 下标为0的一端作为栈底
* top指示栈顶元素在数组中的位置
* 空栈为：top = -1



【性能优缺点】

优点

* 出栈入栈均为：O(1)

缺点

* 顺序栈需要事先确定一个固定的长度，会有浪费内存空间的情况

## 2.2 栈的链式存储结构

【特性】

* 栈顶放在单链表的头部
* 不需要头结点
* 不存在栈满的情况
* 空栈：top = NULL



【性能优缺点】

优点

* 出栈入栈均为：O(1)

缺点

* 链栈每个元素有指针域，有额外的内存开销



【对比】

* 元素变化不可预料，有时很小，有时很大，用链栈
* 变化在可控范围内用顺序栈



【栈的应用】

* 递归（斐波那契数列）
* 四则远算表达式（后缀表达式）

------



# 3. 队列

【特性】

* 只允许在一端进行插入操作，在另一端进行删除操作的**线性表**
* 先进先出（First In First Out）
* 插入的一端为队尾，删除的一端为队头



【定义】

```apl
ADT Queue(队列)
Data
	同线性表。元素具有相同类型，相邻元素具有前驱和后继关系
Operation
	InitQueue(*Q) := 初始化操作，建立一个空队列Q
	DestroyQueue(*Q) := 若队列存在就销毁
	ClearQueue(*Q) := 将队列清空
	QueueEmpty(Q) := 若队列为空，返回true，否则返回false
	GetHead(Q,*e) := 若队列存在且非空，用e返回队列Q的队头元素
	EnQueue(*Q,e) := 若队列存在，插入新元素e到队列Q中并成为队尾元素
	DeQueue(*Q,*e) := 删除队列中队头元素，并用e返回其值
	QueueLength(Q) := 返回队列的元素个数
endADT
```

## 3.1 队列的顺序存储结构

【特性】

* 入队列操作不需要移动元素，在队尾追加一个元素
* 出队列操作需要所有的元素向前移动
* front指针指向队头元素，rear指针指向队尾元素的下一个位置
* 空队列：front == rear



【性能优缺点】

优点

* 入列：O(1)

缺点

* 出列：O(n)
* 会有假溢出现象，浪费内存

### 3.1.1 循环队列

【特性】

* 头尾相接
* 空队列：front == rear
* 满队列：(rear + 1) % QueueSize == front（保留一个元素位置为队列满）
* 队列长度：（rear - front + QueueSize ）% QueueSize
* 数组可能会溢出



【性能优缺点】

优点

* 入列：O(1)
* 出队：O(1)

缺点

* 必须有固定的长度，会有内存浪费

## 3.2 队列的链式存储结构

【特性】

* 只能尾进头出
* 头指针指向头结点
* 空队列：front和rear都指向头结点
* 入链队列，无需判断队满
* 出链队列，头结点的后继结点出队



【性能优缺点】

优点

* 入列：O(1)
* 出队：O(1)

缺点

* 每次申请和释放结点会有时间开销
* 指针域会有内存上的额外开销



【链队列和循环队列对比】

* 确定队列最大长度用循环队列
* 无法估计队列长度用链队列

------



# 4. 串



------



# 5. 树



------



# 6. 图



------

