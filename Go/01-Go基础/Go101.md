# Go

## Go官方工具链

介绍如何配置Go开发环境和如何使用Go官方工具链中提供的`go`命令

### 安装Go官方工具

[Go官方网站](https://go.dev/doc/install)下载Go官方工具链 :)

> 为了从任意目录运行Go官方工具链中工具命令（通过`go`命令）， Go官方工具链安装目录下的`bin`子目录路径必须配置在`PATH`环境变量中

Go官方工具链近来的版本均支持一个称为Go模块（Go modules）的特性，用来管理项目依赖（更多请了解[go mod说明](./go mod说明.md)）

> 从版本1.16开始被默认支持Go mod

了解环境变量：`GOPATH`

此环境变量的默认值为当前用户的HOME目录下的名为`go`文件夹对应的目录路径。 `GOPATH`环境变量可以被手动地配置多个路径。 以后，当`GOPATH`文件夹被提及的时候，它表示`GOPATH`环境变量中的第一个路径对应的文件夹

* `GOPATH`文件夹中的`pkg`子文件夹用来**缓存被本地项目所依赖的Go模块**（一个Go模块为若干Go库包的集合）的版本

了解环境变量：`GOBIN`

此环境变量用来指定`go install`子命令产生的Go应用程序二进制可执行文件应该存储在何处。 它的默认值为`GOPATH`文件夹中的`bin`子目录所对应的目录路径。 `GOBIN`路径需配置在`PATH`环境变量中，以便从任意目录运行这些Go应用程序

### 运行一个Go程序

最简单的一个Go程序

```go
package main

func main() {
}
```

> 在此程序中，单词`package`和`func`是两个关键字。 两个`main`是两个标识符
>
> 此程序的第一行指定了当前源代码文件所处的包的包名（此处为`main`）。 第二行是一个空行，用来增强可读性。 第三和第四行声明了一个名为`main`的函数。 此函数为程序的入口函数

Go官方工具链工具要求所有的Go源代码文件必须以`.go`后缀结尾。

假设上面展示的最简单的Go程序存放在一个名叫`simplest-go-program.go`的文件中

打开一个终端（控制台）并进入上述源文件所在的目录，然后运行

```bash
go run simplest-go-program.go
```

如果一个程序的`main`包中有若干Go源代码文件，我们也可以使用下面的命令运行此程序

```bash
go run .
```

注：

* `go run`子命令并**不推荐在正式的大项目中使用**

* `go run`子命令只是一种方便的方式来运行简单的Go程序
* 对于正式的项目，最好使用`go build`或者`go install`子命令构建可执行程序文件来运行Go程序

支持Go模块特性的Go项目的**根目录下**需要一个`go.mod`文件。此文件可以使用`go mod init`子命令来生成

名称以`_`和`.`开头的源代码文件将被Go官方工具链工具忽略掉

### 更多go子命令

`go run`、`go build`和`go install`构建可执行程序文件来运行Go程序，只会输出代码语法错误

`go vet`子命令可以用来检查可能的代码逻辑错误（即警告）

`go fmt`子命令用同一种代码风格格式化Go代码

`go test`子命令运行单元和基准测试用例

`go doc`子命令（在终端中）查看Go代码库包的文档

让你的Go项目支持Go模块特性来简化依赖管理：

* `go mod init example.com/myproject`命令可以用来在当前目录中生成一个`go.mod`文件。 当前目录将被视为一个名为`example.com/myproject`的模块（即当前项目）的**根目录**。 此`go.mod`文件将被用来记录当前项目需要的依赖模块和版本信息。 我们可以手动编辑或者使用`go`子命令来修改此文件
* `go mod tidy`命令用来通过扫描当前项目中的所有代码来**添加**未被记录的依赖至`go.mod`文件或从`go.mod`文件中**删除**不再被使用的依赖
* `go get`命令用拉添加、升级、降级或者删除单个依赖

从Go官方工具链1.16版本开始，我们可以运行`go install example.com/program@latest`来安装一个第三方Go程序的最新版本（至`GOBIN`目录）

`go help aSubCommand`来查看一个子命令`aSubCommand`的帮助信息

`go`命令将会列出所有支持的`go`子命令

更多go命令请在[go命令官网]((https://golang.google.cn/cmd/go/))查看 :)

### 查看Go标准库文档

请查看Go官方文档库：[Standard library - Go Packages](https://pkg.go.dev/std) :)

------

# Go编程入门

## 程序源代码基本元素介绍

将介绍编程中常用的代码元素，并展示一份简单的Go程序代码

### 编程和程序代码元素

编程可以看作是以各种方式控制和组合计算机运行中的各种操作，以达到各种各样的目的

一个操作可能从一个硬件设备读取、或者向一个硬件设备写入一些数据，从而完成一个特定的任务

对于现代计算机来说，最基本的操作是底层计算机指令，比如CPU和GPU指令

直接操控底层计算机指令进行编程是非常繁琐和容易出错的

高级编程语言通过对底层指令进行一些封装和对数据进行一些抽象，从而使得编程变得直观和易于理解

一个操作通常是通过**函数**（function）调用或者使用**操作符**（operator）运算来完成的

数据通常被抽象为各种**类型**（type）和**值**（value）。 一个类型可以看作是值的模板。一个值可以看作是某个类型的实例

 一些在编码阶段可确定的值可以用它们的**字面形式**（literal，即字面量）来表示，其它的值一般使用**变量**（variable）和**（具名）常量**（named constant）来表示

具名的函数、具名的值（包括变量和具名常量）、以及定义类型和类型别名将被统称为**代码要素**。 代码要素名必须为**[标识符（identifier）](#关键字和标识符)**。

高级编程语言代码将被编译器或者解释器转换为底层机器码进行执行。 为了帮助编译器和解释器解析高级语言代码，一些单词将被用做**[关键字（keyword）](#关键字和标识符)**。 这些单词不能被当做标识符使用

很多现代高级语言使用**包**（package）来组织代码。 一个包必须**引入**（import）另一个包才能使用另一个包中的公有（导出的）代码要素。 包名和包的引入名也都必须是标识符

和很多其流行语言一样，Go使用`//`来起始一个行注释，使用一个`/*`和`*/`对来包裹一个块注释

### 一个简单的Go示例程序

让我们来看一个简短的Go示例程序

```go
package main // 指定当前源文件所在的包名

import "math/rand" // 引入一个标准库包

const MaxRand = 16 // 声明一个具名整型常量

// 一个函数声明
/*
 StatRandomNumbers生成一些不大于MaxRand的非负
 随机整数，并统计和返回小于和大于MaxRand/2的随机数
 个数。输入参数numRands指定了要生成的随机数的总数。
*/
func StatRandomNumbers(numRands int) (int, int) {
	// 声明了两个变量（类型都为int，初始值都为0）
	var a, b int
	// 一个for循环代码块
	for i := 0; i < numRands; i++ {
		// 一个if-else条件控制代码块
		if rand.Intn(MaxRand) < MaxRand/2 {
			a = a + 1
		} else {
			b++ // 等价于：b = b + 1
		}
	}
	return a, b // 此函数返回两个结果
}

// main函数，或主函数，是一个程序的入口函数。
func main() {
	var num = 100
	// 调用上面声明的StatRandomNumbers函数，
	// 并将结果赋给使用短声明语句声明的两个变量。
	x, y := StatRandomNumbers(num)
	// 调用两个内置函数（print和println）。
	print("Result: ", x, " + ", y, " = ", num, "? ")
	println(x+y == num)
}
```

将上面的程序代码存盘到一个名为`basic-code-element-demo.go` 的文件中并使用下列命令运行此程序：

```bash
$ go run basic-code-element-demo.go
Result: 46 + 54 = 100? true
```

在上面的示例程序中，单词`package`、`import`、`const`、`func`、`var`、`for`、`if`、`else`和`return`均为关键字。 其它大多数单词均为标识符

四个`int`（一个在第*15*行，另三个在第*13*行） 表示内置基本类型`int`。int类型是Go中的内置基本整数类型之一。 

第*5*行中的`16`、第*17*行中的`0`、 第*20*行中的`1`以及第*30*行的`100`均为整型字面量。 

第*35*行的`"Result: "`是一个字符串字面量

第*20*行是一个赋值语句。

第*5*行声明了一个具名常量，叫做`MaxRand`。 

第*15*行和第*30*行使用标准变量声明语句声明了三个变量。 

第*17*行的变量`i`以及第*33*行的变量`x`和`y`是使用变量短声明语句声明的。 

变量`a`和`b`在声明的时候被指定为`int`类型。 编译器会自动推导出变量`i`、`num`、`x`和`y`的类型均为`int`类型，因为它们的初始值都是整型字面量表示的

上面的示例程序中使用了很多操作符，比如第*17*和*19*行的小于比较符`<`，第*36*行的等于比较符`==`，还有第*20*和*36*行的加法运算符`+`。 第*35*行中的`+`不是一个运算符，它是一个字符串字面量中的一个字符。 一个使用操作符的操作中涉及到的值称为操作值（有时也可称为运算数）

第*35*和*36*行调用了两个内置函数`print`和`println`。 从第*13*行到第*26*行声明的函数`StatRandomNumbers`在第*33*行被调用。 第*19*行也调用了一个函数 `Intn`。 这个函数声明在`math/rand`标准库包中

第*1*行指定了当前源文件所处的包的名称。 一个Go程序的主函数（`main`函数）必须被声明在一个名称为`main`的包中。 第*3*行引入了`math/rand`标准库包，并以`rand`做为引入名。 在这个包中声明的`Intn`函数将在第*19*行被调用

此处列出了所有的简单语句类型。 在Go代码中，各种流程控制代码块中的某些部分必须为简单语句，某些部分必须为表达式

`StatRandomNumbers`函数的声明体中使用了两个流程控制代码块。 其中一个是`for`循环代码块，它内嵌了另外一个代码块。 另外一个代码块是一个`if-else`条件控制代码块

### 代码断行

像很多其它流行编程语言一样，Go也使用一对大括号`{` and `}`来形成一个显式代码块

但是在Go代码中，编码样式风格有一些限制。比如，很多左大括号`{`不能被放到下一行

我们最好避免将左大括号放在下一行。 或者说，**每行的非空起始字符不能是左大括号**

------



## 关键字和标识符

将介绍Go中的关键字和标识符

### 关键字

关键字是一些特殊的用来帮助编译器理解和解析源代码的单词

截至目前（Go 1.20），Go中共有25个关键字

```go
break     default      func    interface  select
case      defer        go      map        struct
chan      else         goto    package    switch
const     fallthrough  if      range      type
continue  for          import  return     var
```

这些关键字可以分为四组：

- `const`、`func`、`import`、`package`、`type`和`var`用来声明各种代码元素。
- `chan`、`interface`、`map`和`struct`用做 一些组合类型的字面表示中。
- `break`、`case`、`continue`、`default`、 `else`、`fallthrough`、`for`、 `goto`、`if`、`range`、 `return`、`select`和`switch`用在流程控制语句中。 详见[基本流程控制语法](#)。
- `defer`和`go`也可以看作是流程控制关键字， 但它们有一些特殊的作用。详见[协程和延迟函数调用](#)。

### 标识符

一个标识符是一个以Unicode字母或者`_`开头并且完全由Unicode字母和Unicode数字组成的单词

注意：**关键字不能被用做标识符**

标识符`_`是一个特殊字符，它叫做**空标识符**

所有的类型名、变量名、常量名、跳转标签、包名和包的引入名都必须是标识符

一个由**Unicode大写字母开头**的标识符称为**导出标识符**。 这里**导出**可以被理解为**公开**（public）

其它（即**非Unicode大写字母开头的**）标识符称为非导出标识符。 ***非导出***可以被理解为**私有**（private）

下面是一些合法的导出标识符：

```go
Player_9
DoSomething
VERSION
Ĝo
Π
```

下面是一些合法的未导出标识符：

```go
_
_status
memStat
book
π
一个类型
변수
エラー
```

下面这些不能被用做标识符：

```go
// Unicode数字开头
123
3apples

// 含有不符合要求的Unicode字符
a.b
*ptr
$name
a@b.c

// 这两个是关键字
type
range
```

------



## 基本类型和它们的字面量表示

类型（type）可以被看作是值（value）的模板，值可以被看作是类型的实例。将介绍内置（或称为预声明的）基本类型和它们字面量的表示形式。不介绍组合类型。

### 基本内置类型

Go支持如下内置基本类型：

- 一种内置布尔类型：`bool`。
- 11种内置整数类型：`int8`、`uint8`、`int16`、`uint16`、`int32`、`uint32`、`int64`、`uint64`、`int`、`uint`和`uintptr`。
- 两种内置浮点数类型：`float32`和`float64`。
- 两种内置复数类型：`complex64`和`complex128`。
- 一种内置字符串类型：`string`。

内置类型也称为预声明类型

这17种内置基本类型（type）各自属于一种Go中的类型种类（kind）。 尽管所有的内置基本类型的名称都是[非导出标识符](#identifier)， 我们**可以不用引入任何代码包而直接使用这些类型**

除了`bool`和`string`类型，其它的15种内置基本类型都称为数值类型（整型、浮点数型和复数型）

Go中有两种内置类型别名（type alias）：

- `byte`是`uint8`的内置别名。 我们可以将`byte`和`uint8`看作是同一个类型
- `rune`是`int32`的内置别名。 我们可以将`rune`和`int32`看作是同一个类型

以`u`开头的整数类型称为无符号整数类型。 无符号整数类型的值都是非负的。 一个数值类型名称中的数字表示每个这个类型的值将在内存中占有多少二进制位（以后简称位）。二进制位常称为比特（bit）。 比如，一个`uint8`的值将占有8位。 我们称`uint8`类型的值的尺寸是8位。 因此，最大的`uint8`值是`255`（2^8^-1）， 最大的`int8`值是`127`（2^7^-1）， 最小的`int8`值是`-128`（-2^7^）。

任一个类型的所有值的尺寸都是相同的，所以一个值的尺寸也常称为它的类型的尺寸。

更多的时候，我们**使用字节（byte）做为值尺寸的度量单位。 一个字节相当于8个比特**。所以`uint32`类型的尺寸为4，即每个`uint32`值占用4个字节。

`uintptr`、`int`以及`uint`类型的值的尺寸**依赖于具体编译器实现**。 通常地，在64位的架构上，`int`和`uint`类型的值是64位的；在32位的架构上，它们是32位的。 编译器必须保证`uintptr`类型的值的尺寸能够存下任意一个内存地址。

一个`complex64`复数值的实部和虚部都是`float32`类型的值。 一个`complex128`复数值的实部和虚部都是`float64`类型的值

在内存中，所有的浮点数都使用**IEEE-754格式**存储

一个布尔值表示一个真假。在内存中，一个布尔值只有两种可能的状态。 这两种状态使用两个预声明（或称为内置）的常量（`false`和`true`）来表示

从逻辑上说，一个字符串值表示一段文本。 在内存中，**一个字符串存储为一个字节（byte）序列**。 此字节序列体现了此字符串所表示的文本的UTF-8编码形式

尽管布尔和字符串类型分类各自只有一种内置类型， 我们可以声明定义更多**自定义布尔和字符串类型**。 所以，**Go代码中可以出现很多布尔和字符串类型（数值类型也同样）**。 下面是一个类型声明的例子。 在这些例子中，`type`是一个关键字

```go
// 一些[类型定义]声明
type status bool     // status和bool是两个不同的类型
type MyString string // MyString和string是两个不同的类型
type Id uint64       // Id和uint64是两个不同的类型
type real float32    // real和float32是两个不同的类型

// 一些[类型别名]声明
type boolean = bool // boolean和bool表示同一个类型
type Text = string  // Text和string表示同一个类型
type U8 = uint8     // U8、uint8和 byte表示同一个类型
type char = rune    // char、rune和int32表示同一个类型
```

我们将上面定义的`real`类型和内置类型`float32`都称为float32类型 （注意这里的第二个float32是一个泛指，而第一个高亮的float32是一个特指）。 同样地，`MyString`和`string`都被称为字符串（string）类型，`status`和`bool`都被称为布尔（bool）类型。

### 零值

每种类型都有一个零值。一个类型的零值可以看作是此类型的默认值。

- 一个布尔类型的零值表示真假中的**假**。
- 数值类型的零值都是**零**（但是不同类型的零在内存中占用的空间可能不同）。
- 一个字符串类型的零值是一个**空字符串**。

### 基本类型的字面量表示形式

一个值的字面形式称为一个字面量，它表示此值在代码中文字体现形式（和内存中的表现形式相对应）。一个值可能会有很多种字面量形式。

#### 布尔值的字面量形式

Go白皮书没有定义布尔类型值字面量形式。 我们可以将`false`和`true`这两个预声明的具名常量当作布尔类型的字面量形式。 但是，我们应该知道，从严格意义上说，它们不属于字面量。

布尔类型的零值可以使用预声明的`false`来表示。

#### 整数类型值的字面量形式

整数类型值有四种字面量形式：十进制形式（decimal）、八进制形式（octal）、十六进制形式（hex）和二进制形式（binary）。比如，下面的三个字面量均表示十进制的15：

```go
0xF // 十六进制表示（必须使用0x或者0X开头）
0XF

017 // 八进制表示（必须使用0、0o或者0O开头）
0o17
0O17

0b1111 // 二进制表示（必须使用0b或者0B开头）
0B1111

15  // 十进制表示（必须不能用0开头）
```

整数类型的零值的字面量一般使用`0`表示。 当然，`00`和`0x0`等也是合法的整数类型零值的字面量形式

#### 浮点数类型值的字面量形式

一个浮点数的完整十进制字面量形式可能包含一个十进制整数部分、一个小数点、一个十进制小数部分和一个以10为底数的整数指数部分。 整数指数部分由字母`e`或者`E`带一个十进制的整数字面量组成（`xEn`表示`x`乘以10^n^的意思，而`xE-n`表示`x`除以10^n^的意思）。 常常地，某些部分可以根据情况省略掉。一些例子：

```go
1.23
01.23 // == 1.23
.23
1.
// 一个e或者E随后的数值是指数值（底数为10）。
// 指数值必须为一个可以带符号的十进制整数字面量。
1.23e2  // == 123.0
123E2   // == 12300.0
123.E+2 // == 12300.0
1e-1    // == 0.1
.1e0    // == 0.1
0010e-2 // == 0.1
0e+5    // == 0.0
```

从Go 1.13开始，Go也支持另一种浮点数字面量形式：**十六进制浮点数字面量**。 在一个十六进制浮点数字面量中，

- 一个十六进制浮点数字面量必须以一个以2为底数的整数指数部分。 这样的一个整数指数部分由字母`p`或者`P`带一个十进制的整数字面量组成（`yPn`表示`y`乘以2^n^的意思，而`yP-n`表示`y`除以2^n^的意思）。
- 和整数的十六进制字面量一样，一个十六进制浮点数字面量也必须使用`0x`或者`0X`开头。 和整数的十六进制字面量不同的是，一个十六进制浮点数字面量可以包括一个小数点和一个十六进制小数部分。

一些合法的浮点数的十六进制字面量例子：

```go
0x1p-2     // == 1.0/4 = 0.25
0x2.p10    // == 2.0 * 1024 == 2048.0
0x1.Fp+0   // == 1+15.0/16 == 1.9375 F是十六进制数15
0X.8p1     // == 8.0/16 * 2 == 1.0
0X1FFFP-16 // == 0.1249847412109375
```

不合法的浮点数的十六进制字面量：

```go
0x.p1    // 整数部分表示必须包含至少一个数字
1p-2     // p指数形式只能出现在浮点数的十六进制字面量中
0x1.5e-2 // e和E不能出现在十六进制浮点数字面量的指数部分中
```

注意：下面这个表示是合法的，但是它不是浮点数的十六进制字面量。事实上，它是一个减法算术表达式。其中的`e`为是十进制中的`14`，`0x15e`为一个整数十六进制字面量，`-2`并不是此整数十六进制字面量的一部分

```go
0x15e-2 // == 0x15e - 2 (整数相减表达式)
```

浮点类型的零值的标准字面量形式为`0.0`。 当然其它很多形式也是合法的，比如`0.`、`.0`、`0e0`和`0x0p0`等

#### 虚部字面量形式

一个虚部值的字面量形式由一个浮点数字面量或者一个整数字面量和其后跟随的一个小写的字母`i`组成。 在Go 1.13之前，如果虚部中`i`前的部分为一个整数字面量，则其必须为并且总是被视为十进制形式。

```go
1.23i
1.i
.23i
123i
0123i   // == 123i（兼容性使然。见下）
1.23E2i // == 123i
1e-1i
011i   // == 11i（兼容性使然。见下）
00011i // == 11i（兼容性使然。见下）
// 下面这几行从Go 1.13开始才能编译通过。
0o11i    // == 9i
0x11i    // == 17i
0b11i    // == 3i
0X.8p-0i // == 0.5i
```

注意：在Go 1.13之前，虚部字面量中字母`i`前的部分只能为浮点数字面量。 为了兼容老的Go版本，从Go 1.13开始，一些虚部字面量中表现为（不以`0o`和`0O`开头的）八进制形式的整数字面量仍被视为浮点数字面量。 比如上例中的`011i`、`0123i`和`00011i`。

虚部字面量用来表示复数的虚部

```go
1 + 2i       // == 1.0 + 2.0i
1. - .1i     // == 1.0 + -0.1i
1.23i - 7.89 // == -7.89 + 1.23i
1.23i        // == 0.0 + 1.23i
```

复数零值的标准字面表示为`0.0+0.0i`。 当然`0i`、`.0i`、`0+0i`等表示也是合法的。

#### rune值的字面量形式

`rune`类型是`int32`类型的别名。 因此，rune类型（泛指）是特殊的整数类型。

一个rune值可以用上面已经介绍的整数类型的字面量形式表示。 另一方面，很多各种整数类型的值也可以用rune字面量形式来表示。

在Go中，**一个rune值表示一个Unicode码点**。 一般说来，我们**可以将一个Unicode码点看作是一个Unicode字符**。但是，我们也应该知道，**有些Unicode字符由多个Unicode码点组成**。 每个英文或中文Unicode字符值含有一个Unicode码点。

一个rune字面量由若干包在一对单引号中的字符组成。**包在单引号中的字符序列表示一个Unicode码点值**。rune字面量形式有几个变种

```go
'a' // 一个英文字符
'π'
'众' // 一个中文字符

//下面这些rune字面量形式的变种和'a'是等价的 （字符a的Unicode值是97）。
'\141'   // 141是97的八进制表示
'\x61'   // 61是97的十六进制表示
'\u0061'
'\U00000061'
```

注意：`\`之后必须跟随三个八进制数字字符（0-7）表示一个byte值， `\x`之后必须跟随两个十六进制数字字符（0-9，a-f和A-F）表示一个byte值， `\u`之后必须跟随四个十六进制数字字符表示一个rune值（此rune值的高四位都为0）， `\U`之后必须跟随八个十六进制数字字符表示一个rune值。 这些八进制和十六进制的数字字符序列表示的整数必须是一个合法的Unicode码点值，否则编译将失败。

下面这些`println`函数调用都将打印出`true`。

```go
package main

func main() {
	println('a' == 97)
	println('a' == '\141')
	println('a' == '\x61')
	println('a' == '\u0061')
	println('a' == '\U00000061')
	println(0x61 == '\x61')
	println('\u4f17' == '众')
}
```

在日常编程中，这四种rune字面量形式的变种很少用来表示rune值。 它们**多用做字符串的双引号字面量形式中的转义字符**。

如果一个rune字面量中被单引号包起来的部分含有两个字符， 并且第一个字符是`\`，第二个字符不是`x`、 `u`和`U`，那么这两个字符将被转义为一个特殊字符。目前支持的转义组合为：

```go
\a   (rune值：0x07) 铃声字符
\b   (rune值：0x08) 退格字符（backspace）
\f   (rune值：0x0C) 换页符（form feed）
\n   (rune值：0x0A) 换行符（line feed or newline）
\r   (rune值：0x0D) 回车符（carriage return）
\t   (rune值：0x09) 水平制表符（horizontal tab）
\v   (rune值：0x0b) 竖直制表符（vertical tab）
\\   (rune值：0x5c) 一个反斜杠（backslash）
\'   (rune值：0x27) 一个单引号（single quote）
```

其中，`\n`在日常编程中用得最多。

一个例子：

```go
	println('\n') // 10
	println('\r') // 13
	println('\'') // 39

	println('\n' == 10)     // true
	println('\n' == '\x0A') // true
```

rune类型的零值常用 `'\000'`、`'\x00'`或`'\u0000'`等来表示。

#### 字符串值的字面量形式

**在Go中，字符串值是UTF-8编码的**， 甚至所有的Go源代码都必须是UTF-8编码的。

Go字符串的字面量形式有两种。 一种是**解释型字面表示**（interpreted string literal，双引号风格）。 另一种是**直白字面表示**（raw string literal，反引号风格）。

下面的两个字符串表示形式是等价的：

```go
// 解释形式
"Hello\nworld!\n\"你好世界\""

// 直白形式
`Hello
world!
"你好世界"`
```

在上面的解释形式（双引号风格）的字符串字面量中，每个`\n`将被转义为一个换行符，每个`\"`将被转义为一个双引号字符。 双引号风格的字符串字面量中支持的转义字符和rune字面量基本一致，除了<u>一个例外：双引号风格的字符串字面量中支持`\"`转义，但不支持`\'`转义；而rune字面量则刚好相反</u>。

以`\`、`\x`、`\u`和`\U`开头的rune字面量（不包括两个单引号）也可以出现在双引号风格的字符串字面量中。比如：

```go
// 这几个字符串字面量是等价的。
"\141\142\143"
"\x61\x62\x63"
"\x61b\x63"
"abc"

// 这几个字符串字面量是等价的。
"\u4f17\xe4\xba\xba"// “众”的Unicode值为4f17，它的UTF-8编码为三个字节：0xe4 0xbc 0x97。
"\xe4\xbc\x97\u4eba"// “人”的Unicode值为4eba，它的UTF-8编码为三个字节：0xe4 0xba 0xba。
"\xe4\xbc\x97\xe4\xba\xba"
"众人"
```

在UTF-8编码中，**一个Unicode码点（rune）可能由1到4个字节组成**。 **每个英文字母的UTF-8编码只需要一个字节**；**每个中文字符的UTF-8编码需要三个字节**。

**直白反引号风格的字面表示中是不支持转义字符的**。 除了首尾两个反引号，直白反引号风格的字面表示中不能包含反引号。 为了跨平台兼容性，直白反引号风格的字面表示中的回车符（Unicode码点为`0x0D`） 将被忽略掉。

字符串类型的零值在代码里用 `""`或````表示。

#### 数值字面表示中使用下划线分段来增强可读性

从Go 1.13开始，下划线`_`可以出现在**整数、浮点数和虚部数字面量**中，以用做分段符以增强可读性。

但是要注意，在一个数值字面表示中，一个下划线`_`不能出现在此字面表示的首尾，并且其两侧的字符必须为（相应进制的）数字字符或者进制表示头。

```go
// 合法的使用下划线的例子
6_9          // == 69
0_33_77_22   // == 0337722
0x_Bad_Face  // == 0xBadFace
0X_1F_FFP-16 // == 0X1FFFP-16
0b1011_0111 + 0xA_B.Fp2i

// 非法的使用下划线的例子
_69        // 下划线不能出现在首尾
69_        // 下划线不能出现在首尾
6__9       // 下划线不能相连
0_xBadFace // x不是一个合法的八进制数字
1_.5       // .不是一个合法的十进制数字
1._5       // .不是一个合法的十进制数字
```

### 基本数值类型字面量的适用范围

一个数值型的字面量只有在不需要舍入时，才能用来表示一个整数基本类型的值。 比如，<u>`1.0`可以表示任何基本整数类型的值</u>，但`1.01`却不可以。 当一个数值型的字面量用来表示一个非整数基本类型的值时，舍入（或者精度丢失）是允许的。

每种数值类型有一个能够表示的数值范围。 如果一个字面量超出了一个类型能够表示的数值范围（溢出），则在编译时刻，此字面量不能用来表示此类型的值。

下表是一些例子：

|             字面表示             | 此字面表示可以表示哪些类型的值（在编译时刻）                 |
| :------------------------------: | ------------------------------------------------------------ |
|              `256`               | 除了int8和uint8类型外的所有的基本数值类型。                  |
|              `255`               | 除了int8类型外的所有的基本数值类型。                         |
|              `-123`              | 除了无符号整数类型外的所有的基本数值类型。                   |
|              `123`               | 所有的基本数值类型。                                         |
|            `123.000`             | 所有的基本数值类型。                                         |
|             `1.23e2`             | 所有的基本数值类型。                                         |
|              `'a'`               | 所有的基本数值类型。                                         |
|             `1.0+0i`             | 所有的基本数值类型。                                         |
|              `1.23`              | 所有浮点数和复数基本数值类型。                               |
| `0x10000000000000000` (16 zeros) | 所有浮点数和复数基本数值类型。                               |
|             `3.5e38`             | 除了float32和complex64类型外的所有浮点数和复数基本数值类型。 |
|              `1+2i`              | 所有复数基本数值类型。                                       |
|             `2e+308`             | 无。                                                         |

注意几个溢出的例子：

- 字面量`0x10000000000000000`需要65个比特才能表示，所以在运行时刻，任何基本整数类型都不能精确表示此字面量。
- 在IEEE-754标准中，最大的可以精确表示的float32类型数值为`3.40282346638528859811704183484516925440e+38`，所以`3.5e38`不能表示任何float32和complex64类型的值。
- 在IEEE-754标准中，最大的可以精确表示的float64类型数值为`1.797693134862315708145274237317043567981e+308`，因此`2e+308`不能表示任何基本数值类型的值。
- 尽管`0x10000000000000000`可以用来表示float32类型的值，但是它不能被任何float32类型的值所精确表示。上面已经提到了，当使用字面量来表示非整数基本数值类型的时候，精度丢失是允许的（但溢出是不允许的）。

------



## 常量和变量

将介绍常量和变量相关的知识。 类型不确定值、类型推断和值的显式类型转换等概念也将被介绍。

上一章中提到的[基本类型的字面量表示](#基本类型的字面量表示形式) （除了`false`和`true`）都属于**无名常量（unnamed constant）**，或者叫**字面常量（literal constant）**。 `false`和`true`是预声明的两个**具名常量**。这里将介绍如何声明自定义的具名常量。

### 类型不确定值（untyped value）和类型确定值（typed value）

在Go中，有些值的类型是不确定的。换句话说，<u>有些值的类型有很多可能性</u>。 这些值称为**类型不确定值**。对于大多数类型不确定值来说，它们各自都有一个**默认类型**

除了预声明的`nil`。`nil`是没有默认类型的。

与类型不确定值相对应的概念称为**类型确定值**

上一章提到的**字面常量（无名常量）**<u>都属于类型不确定值</u>。 事实上，<u>Go中大多数的类型不确定值都属于字面常量和即将介绍的具名常量</u>。 少数类型不确定值包括刚提到的`nil`和以后会逐步接触到的某些操作的布尔返回值。

一个字面（常）量的默认类型取决于它为何种字面量形式：

- 一个字符串字面量的默认类型是预声明的`string`类型。
- 一个布尔字面量的默认类型是预声明的`bool`类型。
- 一个整数型字面量的默认类型是预声明的`int`类型。
- 一个rune字面量的默认类型是预声明的`rune`（亦即`int32`）类型。
- 一个浮点数字面量的默认类型是预声明的`float64`类型。
- 如果一个字面量含有虚部字面量，则此字面量的默认类型是预声明的`complex128`类型

### 类型不确定常量的显式类型转换

和很多语言一样，Go也支持类型转换。但go语言中**不允许隐式类型转换**，只能显式的进行类型转换，并且，当两个类型兼容才能进行显示转换。 一个**显式类型转换**的形式为`T(v)`，其表示将一个值`v`转换为类型`T`。 编译器将`T(v)`的转换结果视为一个类型为`T`的类型确定值。当然，对于一个特定的类型`T`，`T(v)`并非对任意的值`v`都合法。

对于一个类型不确定常量值`v`，有两种情形显式转换`T(v)`是合法的：

1. `v`可以表示为`T`类型的一个值。 转换结果为一个类型为`T`的类型确定常量值。
2. `v`的默认类型是一个整数类型（`int`或者`rune`） 并且`T`是一个字符串类型。 转换`T(v)`将`v`看作是一个Unicode码点。 转换结果为一个类型为`T`的字符串常量。 此字符串常量只包含一个Unicode码点，并且可以看作是此Unicode码点的UTF-8表示形式。 对于不在合法的Unicode码点取值范围内的整数`v`， 转换结果等同于字符串字面量`"\uFFFD"`（亦即`"\xef\xbf\xbd"`）。 `0xFFFD`是Unicode标准中的（非法码点的）替换字符值。 （但是请注意，今后的Go版本可能[只允许rune或者byte整数被转换为字符串](https://github.com/golang/go/issues/3939)。 从Go官方工具链1.15版本开始，`go vet`命令会对从非rune和非byte整数到字符串的转换做出警告。）

这一规则同时适用于字面常量和类型不确定具名常量。

第二种情形并不要求`v`必须是一个常量。 如果`v`是一个常量，则转换结果也是一个常量。 如果`v`不是一个常量，则转换结果也不是一个常量。

一些合法的转换例子：

```go
// 结果为complex128类型的1.0+0.0i。虚部被舍入了。
complex128(1 + -1e-1000i)
// 结果为float32类型的0.5。这里也舍入了。
float32(0.49999999)
// 只要目标类型不是整数类型，舍入都是允许的。
float32(17000000000000000)
float32(123)
uint(1.0)
int8(-123)
int16(6+0i)
complex128(789)

string(65)          // "A"
string('A')         // "A"
string('\u68ee')    // "森"
string(-1)          // "\uFFFD"
string(0xFFFD)      // "\uFFFD"
string(0x2FFFFFFFF) // "\uFFFD"
```

一些非法的转换例子：

```go
int(1.23)     // 1.23不能被表示为int类型值。
uint8(-1)     // -1不能被表示为uint8类型值。
float64(1+2i) // 1+2i不能被表示为float64类型值。

// -1e+1000不能被表示为float64类型值。不允许溢出。
float64(-1e1000)
// 0x10000000000000000做为int值将溢出。
int(0x10000000000000000)

// 字面量65.0的默认类型是float64（不是一个整数类型）。
string(65.0)
// 66+0i的默认类型是complex128（不是一个整数类型）。
string(66+0i)
```

从上面的例子可以看出，一个类型不确定数字值所表示的值可能溢出它的默认类型的表示范围。 比如上例中的`-1e1000`和`0x10000000000000000`。 一个溢出了它的默认类型的表示范围的类型不确定数字值是不能被转换到它的默认类型的（将编译报错）。

有时一个显式转换形式必须被写成`(T)(v)`以免发生歧义。 这种情况多发生在`T`不为一个标识符的时候。

### 类型推断介绍

Go支持类型推断（type deduction or type inference）。 **类型推断是指在某些场合下，程序员可以在代码中使用一些类型不确定值， 编译器会自动推断出这些类型不确定值在特定情景下应被视为某些特定类型的值**。

在Go代码中，**如果某处需要一个特定类型的值并且一个类型不确定值可以表示为此特定类型的值， 则此类型不确定值可以使用在此处**。**Go编译器将此类型不确定值视为此特定类型的类型确定值**。 这种情形常常出现在运算符运算、函数调用和赋值语句中。

有些场景**对某些类型不确定值并没有特定的类型要求。在这种情况下，Go编译器将这些类型不确定值视为它们各自的默认类型的类型确定值**。

这两条类型推断规则可以被视为**隐式转换规则**。

### （具名）常量声明（constant declaration）

和无名字面常量一样，具名常量也必须都是布尔、数字或者字符串值。 在Go中，关键字`const`用来声明具名常量。

下面是一些常量声明的例子：

```go
package main

// 声明了两个单独的具名常量。（是的，非ASCII字符可以用做标识符。）
const π = 3.1416
const Pi = π // 等价于：const Pi = 3.1416

// 声明了一组具名常量。
const (
	No         = !Yes // 常量描述
	Yes        = true
	MaxDegrees = 360
	Unit1      = "弧度"
)

func main() {
	// 声明了三个局部具名常量。
	const DoublePi, HalfPi, Unit2 = π * 2, π * 0.5, "度"
}
```

Go白皮书把上面每行含有一个等号`=`的语句称为一个**常量描述**（constant specification）。 每个`const`关键字对应一个常量声明。一个常量声明中可以有若干个常量描述。 上面的例子中含有4个常量声明。除了第3个，其它的常量声明中都各自只有一个常量描述。 第3个常量声明中有4个常量描述。

常量声明中的等号`=`<u>表示“绑定”而非“赋值”</u>。 每个常量描述将一个或多个字面量绑定到各自对应的具名常量上。 或者说，**每个具名常量其实代表着一个字面常量**。

在上面的例子中，具名常量`π`和`Pi`都绑定到（或者说代表着）字面常量`3.1416`。 这两个具名常量可以在程序代码中被多次使用，从而有效避免了字面常量`3.1416`在代码中出现在多处。 如果字面常量`3.1416`在代码中出现在多处， 当我们以后欲将`3.1416`改为`3.14`的时候，所有出现在代码中的`3.1416`都得逐个修改。 有了具名常量的帮助，我们只需修改对应常量描述中的`3.1416`即可。 这是常量声明的主要作用

我们使用**非常量**这一术语表示不是常量的值。将要介绍的变量就属于非常量。

常量可以直接声明在包中，也可以声明在函数体中。 声明在函数体中的常量称为局部常量（local constant），直接声明在包中的常量称为**包级常量**（package-level constant）。 包级常量也常常被称为**全局常量**。

**包级常量声明中的常量描述的顺序并不重要**。比如在上面的例子中， 常量描述`No`和`Yes`的顺序可以掉换一下。

上面例子中声明的所有常量都是类型不确定的。 它们各自的默认类型和它们各自代表的字面量的默认类型是一样的。

#### 类型确定具名常量

我们可以**在声明一些常量的时候指定这些常量的确切类型**。 这样声明的常量称为类型确定具名常量。

在下面这个例子中，所有这4个声明的常量都是类型确定的。 `X`和`Y`的类型都是`float32`， `A`和`B`的类型都是`int64`。

```go
const X float32 = 3.14

const (
	A, B int64   = -3, 5
	Y    float32 = 2.718
)
```

如果一个常量描述中包含多个类型确定常量，则这些常量的类型必然是一样的， 比如上例中的`A`和`B`。

我们也可以**使用显式类型转换来声明类型确定常量**。 下面的例子和上面的例子是完全等价的。

```go
const X = float32(3.14)

const (
	A, B = int64(-3), int64(5)
	Y    = float32(2.718)
)
```

欲**将一个字面常量绑定到一个类型确定具名常量上，此字面常量必须能够表示为此常量的确定类型的值**。 否则，编译将报错。比如：

```go
const a uint8 = 256             // error: 256溢出uint8
const b = uint8(255) + uint8(1) // error: 256溢出uint8
const c = int8(-128) / int8(-1) // error: 128溢出int8
const MaxUint_a = uint(^0)      // error: -1溢出uint
const MaxUint_b uint = ^0       // error: -1溢出uint
```

在上面的例子中，符号`^`为位反运算符（<u>位反运算：^n = - (n+1)</u>）。

下面这个类型确定常量声明在64位的操作系统上是合法的，但在32位的操作系统上是非法的。 因为一个`uint`值在32位操作系统上的尺寸是32位， `(1 << 64) - 1`将溢出`uint`。（这里，符号`<<`为左移位运算符。）(左位移运算：左移n位就是乘以2的n次方)

```go
const MaxUint uint = (1 << 64) - 1
```

那么如何声明一个代表着最大`uint`值的常量呢？ 我们可以用下面这个常量声明来替换上面这个。下面这个声明在64位和32位的操作系统上都是合法的。

```go
const MaxUint = ^uint(0)
```

类似地，我们可以使用下面这个常量声明来声明一个具名常量来表示最大的`int`值。（这里，符号`>>`为右移位运算符。）（右位移运算：右移几位就除以2的几次方）

```go
const MaxInt = int(^uint(0) >> 1)
```

使用类似的方法，我们可以声明一个常量来表示当前操作系统的位数，或者检查当前操作系统是32位的还是64位的。

```go
const NativeWordBits = 32 << (^uint(0) >> 63) // 64 or 32
const Is64bitOS = ^uint(0) >> 63 != 0
const Is32bitOS = ^uint(0) >> 32 == 0
```

#### 常量声明中的自动补全

在一个包含多个常量描述的常量声明中，除了第一个常量描述，其它**后续的常量描述都可以只包含标识符列表部分**。 Go编译器**将通过照抄前面最紧挨的一个完整的常量描述来自动补全不完整的常量描述**。

比如，在编译阶段，编译器会将下面的代码

```go
const (
	X float32 = 3.14
	Y                // 这里必须只有一个标识符
	Z                // 这里必须只有一个标识符

	A, B = "Go", "language"
	C, _
	// 上一行中的空标识符是必需的
	// （如果上一行是一个不完整的常量描述的话）。
)
```

自动补全为

```go
const (
	X float32 = 3.14
	Y float32 = 3.14
	Z float32 = 3.14

	A, B = "Go", "language"
	C, _ = "Go", "language"
)
```

#### 在常量声明中使用`iota`

`iota`是Go中预声明（内置）的<u>一个特殊的具名常量</u>。 `iota`被预声明为`0`，但是它的值在编译阶段并非恒定。 当此预声明的`iota`出现在一个常量声明中的时候，它的值在第n个常量描述中的值为`n`（从0开始）。 所以`iota`**只对含有多个常量描述的常量声明有意义**

`iota`和常量描述自动补全相结合有的时候能够给Go编程带来很大便利。

比如，下面是一个使用了这两个特性的例子

```go
package main

func main() {
	const (
		k = 3 // 在此处，iota == 0

		m float32 = iota + .5 // m float32 = 1 + .5
		n                     // n float32 = 2 + .5

		p = 9             // 在此处，iota == 3
		q = iota * 2      // q = 4 * 2
		_                 // _ = 5 * 2
		r                 // r = 6 * 2
		s, t = iota, iota // s, t = 7, 7
		u, v              // u, v = 8, 8
		_, w              // _, w = 9, 9
	)

	const x = iota // x = 0 （iota == 0）
	const (
		y = iota // y = 0 （iota == 0）
		z        // z = 1
	)

	println(m)             // +1.500000e+000
	println(n)             // +2.500000e+000
	println(q, r)          // 8 12
	println(s, t, u, v, w) // 7 7 8 8 9
	println(x, y, z)       // 0 0 1
}
```

在实际编程中，我们应该用有意义的方式使用之。比如

```go
const (
	Failed = iota - 1 // == -1
	Unknown           // == 0
	Succeeded         // == 1
)

const (
	Readable = 1 << iota // == 1
	Writable             // == 2
	Executable           // == 4
)
```

### 变量声明和赋值操作语句

变量可以被看作是在运行时刻存储在内存中并且可以被更改的具名的值。

**所有的变量值都是类型确定值**。当声明一个变量的时候，我们必须在代码中给编译器提供足够的信息来让编译器推断出此变量的确切类型。

在一个函数体内声明的变量称为**局部变量**。 在任何函数体外声明的变量称为**包级或者全局变量**。

Go语言有两种变量声明形式。一种称为**标准形式**，另一种称为**短声明形式**。 **短声明形式只能用来声明局部变量**。

#### 标准变量声明形式

标准变量声明形式语句起始于一个`var`关键字。 每个`var`关键字跟随着一个变量名。 每个变量名必须为一个[标识符](#标识符)。

下面是几条完整形式的标准变量声明语句。 这些声明确地指定了被声明的变量的类型和初始值。

```go
var lang, website string = "Go", "https://golang.org"
var compiled, dynamic bool = true, false
var announceYear int = 2009
```

可以看到，和常量声明一样，多个同类型的变量可以在一条语句中被声明。

完整形式的标准变量声明使用起来有些罗嗦，因此很少在日常Go编程中使用。 在日常Go编程中，另外两种变种形式用得更广泛一些。 一种变种形式**省略了变量类型（但仍指定了变量的初始值）**，这时编译器**将根据初始值的字面量形式来推断出变量的类型**。 另一种变种形式**省略了初始值（但仍指定了变量类型）**，这时编译器**将使用变量类型的零值做为变量的初始值**。

下面是一些第一种变种形式的用例。在这些用例中，如果一个初始值是一个类型确定值，则对应声明的变量的类型将被推断为此初始值的类型； 如果一个初始值是一个类型不确定值，则对应声明的变量的类型将被推断为此初始值的默认类型。 注意**在这种变种中，同时声明的多个变量的类型可以不一样。**

```go
// 变量lang和dynamic的类型将被推断为内置类型string和bool。
var lang, dynamic = "Go", false

// 变量compiled和announceYear的类型将被推断
// 为内置类型bool和int。
var compiled, announceYear = true, 2009

// 变量website的类型将被推断为内置类型string。
var website = "https://golang.org"
```

上例中的类型推断可以被视为**隐式类型转换**。

下例展示了几个省略了初始值的标准变量声明。每个声明的变量的初始值为它们各自的类型的零值。

```go
var lang, website string      // 两者都被初始化为空字符串。
var interpreted, dynamic bool // 两者都被初始化为false。
var n int                     // 被初始化为0。
```

和常量声明一样，**多个变量可以用一对小括号组团在一起被声明**。

```go
var (
	lang, bornYear, compiled     = "Go", 2007, true
	announceAt, releaseAt    int = 2009, 2012
	createdBy, website       string
)
```

这个变量声明语句包含三个**变量描述**（variable specification）。

#### 纯赋值语句

等号`=`表示赋值。 一旦一个变量被声明之后，它的值可以被通过纯赋值语句来修改。 多个变量可以同时在一条赋值语句中被修改

一个赋值语句等号左边的表达式必须是一个可寻址的值、一个映射元素或者一个空标识符

**常量是不可改变的**（不可寻址的），所以常量不能做为目标值出现在纯赋值语句的左边，而只能出现在右边用做源值。 变量既可以出现在纯赋值语句的左边用做目标值，也可以出现在右边用做源值

**空标识符**也可以出现在纯赋值语句的左边，**表示不关心对应的目标值**。 空标识符不可被用做源值

纯赋值语句的例子：

```go
const N = 123
var x int
var y, z float32

N = 789 // error: N是一个不可变量
y = N   // ok: N被隐式转换为类型float32
x = y   // error: 类型不匹配
x = N   // ok: N被隐式转换为类型int
y = x   // error: 类型不匹配
z = y   // ok
_ = y   // ok

z, y = y, z               // ok
_, y = y, z               // ok
z, _ = y, z               // ok
_, _ = y, z               // ok
x, y = 69, 1.23           // ok
x, y = y, x               // error: 类型不匹配
x, y = int(y), float32(x) // ok
```

上例中的最后一行使用了显式类型转换，否则此赋值（见倒数第二行）将不合法

**Go不支持某些其它语言中的连等语法**

```go
var a, b int
a = b = 123 // 语法错误
```

#### 短变量声明形式

用短变量声明形式来声明一些局部变量。如下例：

```go
package main

func main() {
	// 变量lang和year都为新声明的变量。
	lang, year := "Go language", 2007

	// 这里，只有变量createdBy是新声明的变量。
	// 变量year已经在上面声明过了，所以这里仅仅
	// 改变了它的值，或者说它被重新声明了。
	year, createdBy := 2009, "Google Research"

	// 这是一个纯赋值语句。
	lang, year = "Go", 2012

	print(lang, "由", createdBy, "发明")
	print("并发布于", year, "年。")
	println()
}
```

**每个短声明语句中必须至少有一个新声明的变量**。

从上面的例子中，我们可以看到短变量声明形式和标准变量声明形式有几个显著的区别：

1. 短声明形式不包含`var`关键字，并且**不能指定变量的类型**。
2. 短变量声明中的赋值符号必须为`:=`。
3. 在一个短声明语句的左侧，**已经声明过的变量和新声明的变量可以共存**。 但在一个标准声明语句中，所有出现在左侧的变量必须都为新声明的变量。

注意，相对于纯赋值语句，目前短声明语句有一个限制：**出现在一个短声明左侧的项必须都为纯标识符**。 **在纯赋值语句的左边可以出现结构体值的字段，指针的解引用和容器类型值的元素索引项等。 但是这些项不能出现在一个变量短声明语句的左边**

#### 关于“赋值”这个术语

当“赋值”这个术语被提到的时候，它可以指一个纯赋值、一个短变量声明或者一个初始值未省略的标准变量声明

当`y = x`是一条合法的赋值语句时，我们可以说`x`可以被赋给`y`。 假设`y`的类型为`Ty`，有时为了叙述方便，我们也可以说`x`可以被赋给类型`Ty`

一般来说，如果`x`可以被赋给`y`，则`y`应该是可修改的，并且`x`和`y`的类型相同或者`x`可以被隐式转换到`y`的类型。 当然，`y`也可以是空标识符`_`

#### 每个局部声明的变量至少要被有效使用一次

注意，当使用目前的主流Go编译器编译Go代码时，**一个局部变量被声明之后至少要被有效使用一次，否则编译器将报错**。 <u>包级变量无此限制</u>。 如果一个变量总是被当作赋值语句中的目标值，那么我们认为这个变量没有被有效使用过

比如，下面这个例子编译不通过：

```go
package main

var x, y, z = 123, true, "foo" // 包级变量

func main() {
	var q, r = 789, false
	r, s := true, "bar"
	r = y // r没有被有效使用。
	x = q // q被有效使用了。
}
```

当编译上面这个程序的时候，编译器将报错（假设这个程序代码存在一个名为`example-unused.go`的文件中）：

```bash
./example-unused.go:6:6: r declared and not used
./example-unused.go:7:16: s declared and not used
```

避免编译器报错的方法很简单，**要么删除相关的变量声明**，要么像下面这样，将未曾有效使用过的变量（这里是`r`和`s`）**赋给空标识符**

```go
package main

var x, y, z = 123, true, "foo"

func main() {
	var q, r = 789, false
	r, s := true, "bar"
	r = y
	x = q

	_, _ = r, s // 将r和s做为源值使用一次。
}
```

#### 若干包级变量在声明时刻的依赖关系将影响它们的初始化顺序

下面这个例子中的声明的变量的初始化顺序为`y = 5`、`c = y`、`b = c+1`、`a = b+1`、`x = a+1`

```go
var x, y = a+1, 5         // 8 5
var a, b, c = b+1, c+1, y // 7 6 5
```

**包级变量在初始化的时候不能相互依赖**。比如，下面这个变量声明语句编译不通过：

```go
var x, y = y, x
```

### 值的可寻址性

在Go中，有些值是可以被寻址的。上面已经提到**所有变量都是可以寻址的**，**所有常量都是不可被寻址**

### 非常量数字值相关的显式类型转换规则

在Go中，两个类型不一样的[基本类型](#基本内置类型)值是不能相互赋值的。 我们必须使用显式类型转换将一个值转换为另一个值的类型之后才能进行赋值

已经提到了<u>整数（不论常量还是非常量）都可以被显式转换为字符串类型</u>

再介绍两个不同类型数字值之间的转换规则：

- <u>一个非常量浮点数和整数可以显式转换到其它任何一个浮点数和整数类型</u>。
- <u>一个非常量复数可以显式转换到其它任何一个复数类型</u>。

上面已经提到，**常量数字值的类型转换不能溢出**。**此规则不适用于非常量数字值的类型转换**。 <u>非常量数字值的类型转换中，溢出是允许的</u>。 另外当将一个浮点数非常量值（比如一个变量）转换为一个整数类型的时候，舍入（或者精度丢失）也是允许的。 具体规则如下：

- 当从一个比特位数多的整数类型的非常量整数值向一个比特位数少的整数类型转换的时候，高位的比特将被舍弃，低位的比特将被保留。我们称这种处理方式为**截断（truncated）**。
- 当从一个非常量的浮点数向一个整数类型转换的时候，浮点数的**小数部分将被舍弃**（向零靠拢）。
- 当从一个非常量整数或者浮点数向一个浮点数类型转换的时候，精度丢失是可以发生的。
- 当从一个非常量复数向另一个复数类型转换的时候，精度丢失也是可以发生的。
- 当一个显式转换涉及到非常量浮点数或者复数数字值时，如果源值溢出了目标类型的表示范围，则转换结果取决于具体编译器实现（即行为未定义）。

下面的例子：

```go
const a = -1.23
// 变量b的类型被推断为内置类型float64。
var b = a
// error: 常量1.23不能被截断舍入到一个整数。
var x = int32(a)
// error: float64类型值不能被隐式转换到int32。
var y int32 = b
// ok: z == -1，变量z的类型被推断为int32。
//     z的小数部分将被舍弃。
var z = int32(b)

const k int16 = 255
var n = k            // 变量n的类型将被推断为int16。
var f = uint8(k + 1) // error: 常量256溢出了uint8。
var g uint8 = n + 1  // error: int16值不能隐式转换为uint8。
var h = uint8(n + 1) // ok: h == 0，变量h的类型为uint8。
                     // (n+1)溢出uint8，所以只有低8位bits（都为0）被保留。
```

第*7*行和第*15*行的隐式转换是不允许的，第*5*行和第*14*行的显式转换也是不允许的。

第*3*行的隐式转换中，`a`被转换为它的默认类型（`float64`）；因此`b`的类型被推断为`float64`

### 变量和常量的作用域

在Go中，我们可以使用一对大括号来显式形成一个（局部）代码块。一个代码块可以内嵌另一个代码块。 最外层的代码块称为包级代码块。 一个声明在一个内层代码块中的常量或者变量将遮挡另一个外层代码块中声明的同名变量或者常量。 

比如，下面的代码中声明了3个名为`x`的变量。 内层的`x`将遮挡外层的`x`， 从而外层的`x`在内层的`x`声明之后在内层中将不可见

```go
package main

const y = 70
var x int = 123 // 包级变量

func main() {
	// 此x变量遮挡了包级变量x。
	var x = true

	// 一个内嵌代码块。
	{
		x, y := x, y-10 // 这里，左边的x和y均为新声明
		                // 的变量。右边的x为外层声明的
		                // bool变量。右边的y为包级变量。

		// 在此内层代码块中，从此开始，
		// 刚声明的x和y将遮挡外层声明x和y。

		x, z := !x, y/10 // z是一个新声明的变量。
		                 // x和y是上一句中声明的变量。
		println(x, y, z) // false 60 6
	}
	println(x) // true
	println(y) // 70 （包级变量y从未修改）
	/*
	println(z) // error: z未定义。
	           // z的作用域仅限于上面的最内层代码块。
	*/
}
```

**作用域是指一个标识符的可见范围**。 一个包级变量或者常量的作用域为其所处于的整个代码包。 一个局部变量或者常量的作用域开始于此变量或者常量的声明的下一行，结束于最内层包含此变量或者常量的声明语句的代码块的结尾

### 更多关于常量声明

#### 一个类型不确定常量所表示的值可以溢出其默认类型

比如，下例中的三个类型不确定常量均溢出了它们各自的默认类型，但是此程序编译和运行都没问题

```go
package main

// 三个类型不确定常量。
const n = 1 << 64          // 默认类型为int
const r = 'a' + 0x7FFFFFFF // 默认类型为rune
const x = 2e+308           // 默认类型为float64

func main() {
	_ = n >> 2
	_ = r - 0x7FFFFFFF
	_ = x / 2
}
```

但是下面这个程序编译不通过，因为三个声明的常量为类型确定常量。

```go
package main

// 三个类型确定常量。
const n int = 1 << 64           // error: 溢出int
const r rune = 'a' + 0x7FFFFFFF // error: 溢出rune
const x float64 = 2e+308        // error: 溢出float64

func main() {}
```

#### 每个常量标识符将在编译的时候被其绑定的字面量所替代

常量声明可以看作是增强型的C语言中的`#define`宏。 **在编译阶段，所有的标识符将被它们各自绑定的字面量所替代**

如果一个运算中的所有运算数都为常量，则此运算的结果也为常量。或者说，此运算将在编译阶段就被估值

一个例子：

```go
package main

const X = 3
const Y = X + X
var a = X

func main() {
	b := Y
	println(a, b, X, Y)
}
```

上面这段程序代码将在编译阶段被重写为下面这样：

```go
package main

var a = 3

func main() {
	b := 6
	println(a, b, 3, 6)
}
```

------



## 运算操作符

将介绍适用于基本类型值的各种运算操作符

同时只介绍算术运算符、位运算符、比较运算符、布尔运算符和字符串衔接运算符。 这些运算符要么是二元的（需要两个操作数），要么是一元的（需要一个操作数）。 所有这些运算符运算都只返回一个结果。操作数常常也称为操作值。

此处的介绍不追求描述的完全准确性。 比如，当我们说一个二元运算符运算需要其涉及的两个操作数类型必须一样的时，这指：

- 如果这两个操作数都是类型确定值，则它们的类型必须相同，或者其中一个操作数可以被隐式转换到另一个操作数的类型。
- 如果其中只有一个操作数是类型确定的，则要么另外一个类型不确定操作数可以表示为此类型确定操作数的类型的值，要么此类型不确定操作数的默认类型的任何值可以被隐式转换到此类型确定操作数的类型。
- 如果这两个操作数都是类型不确定的，则它们必须同时都为两个布尔值，同时都为两个字符串值，或者同时都为两个基本数字值。

类似的，当我们说一个运算符（一元或者二元）运算要求其涉及的某个操作数的类型必须为某个特定类型时，这指：

- 如果这个操作数是类型确定的，则它的类型必须为所要求的特定类型，或者此操作数可以被隐式转换为所要求的特定类型。
- 如果一个操作数是类型不确定的，则要么此操作数可以表示为所要求的特定类型值，要么此操作数的默认类型的任何值可以被隐式转换为所要求的特定类型。

### 常量表达式

在介绍之前，我们需要知道什么叫常量表达式和关于常量表达式估值的一个常识

表达式的概念将在[表达式和语句](#)一文中得到解释。 目前我们只需知道本文中所提及的大多数运算都属于表达式。 **当一个表达式中涉及到的所有操作数都是常量时，此表达式称为一个常量表达式**。 **一个常量表达式的估值是在编译阶段进行的**。一个常量表达式的估值结果依然是一个常量。 **如果一个表达式中涉及到的操作数中至少有一个不为常量，则此表达式称为非常量表达式**。

### 算术运算符

Go支持五个基本二元算术运算符：

| 字面形式 | 名称 | 对两个运算数的要求                               |
| -------- | ---- | ------------------------------------------------ |
| +        | 加法 | 两个运算数的类型必须相同并且为基本数值类型。     |
| -        | 减法 | 两个运算数的类型必须相同并且为基本数值类型。     |
| *        | 乘法 | 两个运算数的类型必须相同并且为基本数值类型。     |
| /        | 除法 | 两个运算数的类型必须相同并且为基本数值类型。     |
| %        | 余数 | 两个运算数的类型必须相同并且为基本整数数值类型。 |

Go支持六种位运算符（也属于算术运算）：

| 字面形式 | 名称       | 对两个操作数的要求以及机制解释                               |
| -------- | ---------- | ------------------------------------------------------------ |
| &        | 位与       | 两个操作数的类型必须相同并且为基本整数数值类型。机制解释（以下字面量均为二进制）：`1100 & 1010` 得到 `1000` |
| \|       | 位或       | 两个操作数的类型必须相同并且为基本整数数值类型。机制解释：`1100 |1010` 得到 `1110` |
| ^        | （位）异或 | 两个操作数的类型必须相同并且为基本整数数值类型。机制解释：`1100 ^ 1010  ` 得到 `0110` |
| &^       | 清位       | 两个操作数的类型必须相同并且为基本整数数值类型。机制解释：`1100 &^ 1010` 得到 `0100` |
| <<       | 左移位     | 左操作数必须为一个整数，右操作数也必须为一个整数（如果它是一个常数，则它必须非负），但它们的类型可以不同。 （注意：在Go 1.13之前，右操作数必须为一个无符号整数类型的类型确定值或者一个可以表示成`uint`值的[类型不确定](#类型不确定值（untyped value）和类型确定值（typed value）)常数值。）一个负右操作数（非常数）将在运行时刻造成一个恐慌。机制解释：`1100 << 3` 得到 `1100000`（低位补零） |
| >>       | 右移位     | 左操作数必须为一个整数，右操作数也必须为一个整数（如果它是一个常数，则它必须非负），但它们的类型可以不同。 （注意：在Go 1.13之前，右操作数必须为一个无符号整数类型的类型确定值或者一个可以表示成`uint`值的[类型不确定](#类型不确定值（untyped value）和类型确定值（typed value）)常数值。）一个负右操作数（非常数）将在运行时刻造成一个恐慌。机制解释：`1100 >> 3` 得到 `1`（低位被舍弃）注意，在右移运算中，左边空出来的位（即高位）全部用左操作数的最高位（即正负号位）填充。 比如如果左操作数`-128`的类型为`int8`（二进制补码表示为`100000002`）， 则`100000002 >> 2`的二进制补码结果为`111000002`（即`-32`）。 |

Go也支持三个一元算术运算符：

| 字面形式 | 名称           | 解释                                                         |
| -------- | -------------- | ------------------------------------------------------------ |
| +        | 取正数         | `+n`等价于`0 + n`.                                           |
| -        | 取负数         | `-n`等价于`0 - n`.                                           |
| ^        | 位反（或位补） | `^n`等价于`m ^ n`，^为异或运算，每个比特位相同为0，不同为1。其中`m`和`n`同类型并且它的二进制表示中所有比特位均为1。 比如如果`n`的类型为`int8`，则`m`的值为`-1`；如果`n`的类型为`uint8`，则`m`的值为`255`。 |

注意：

- 在很多其它流行语言中，位反运算符是用`~`表示的。
- 和一些其它流行语言一样，加号运算符`+`也**可用做字符串衔接运算符**。
- 和C及C++语言一样，`*`除了可以当作乘号运算符，它也可以**用做指针解引用运算符**； `&`除了可以当作位与运算符，它也可以用做**取地址运算符**。 后面将详解内存地址和指针类型。
- 和Java不一样，**Go支持无符号数**，所以Go不需要无符号右移运算符`>>>`。
- **Go不支持幂运算符**， 我们必须**使用`math`标准库包中的`Pow`函数来进行幂运算**。
- 清位运算符`&^`是Go中特有的一个运算符。 `m &^ n`等价于`m & (^n)`。

一些运算符的使用示例：

```go
func main() {
	var (
		a, b float32 = 12.0, 3.14
		c, d int16   = 15, -6
		e	uint8   = 7
	)

	// 这些行编译没问题。
	_ = 12 + 'A' // 两个类型不确定操作数（都为数值类型）
	_ = 12 - a   // 12将被当做a的类型（float32）使用。
	_ = a * b    // 两个同类型的类型确定操作数。
	_ = c % d
	_, _ = c + int16(e), uint8(c) + e
	_, _, _, _ = a / b, c / d, -100 / -9, 1.23 / 1.2
	_, _, _, _ = c | d, c & d, c ^ d, c &^ d
	_, _, _, _ = d << e, 123 >> e, e >> 3, 0xF << 0
	_, _, _, _ = -b, +c, ^e, ^-1

	// 这些行编译将失败。
	_ = a % b   // error: a和b都不是整数
	_ = a | b   // error: a和b都不是整数
	_ = c + e   // error: c和e的类型不匹配
	_ = b >> 5  // error: b不是一个整数
	_ = c >> -5 // error: -5不是一个无符号整数

	_ = e << uint(c) // 编译没问题
	_ = e << c       // 从Go 1.13开始，此行才能编译过
	_ = e << -c      // 从Go 1.13开始，此行才能编译过。
	                 // 将在运行时刻造成恐慌。
	_ = e << -1      // error: 右操作数不能为负（常数）
}
```

#### 关于溢出

之前提到了

- 一个类型确定数字型常量所表示的值是不能溢出它的类型的表示范围的。
- 一个类型不确定数字型常量所表示的值是可以溢出它的默认类型的表示范围的。 当一个类型不确定数字常量值溢出它的默认类型的表示范围时，此数值不会被截断（亦即回绕）。
- 将一个非常量数字值转换为其它数字类型时，此非常量数字值可以溢出转化结果的类型。 在此转换中，当溢出发生时，转化结果为此非常量数字值的截断（亦即回绕）表示。

对于一个算数运算的结果，上述规则同样适用。

示例：

```go
// 结果为非常量
var a, b uint8 = 255, 1
var c = a + b  // c==0。a+b是一个非常量表达式，
               // 结果中溢出的高位比特将被截断舍弃。
var d = a << b // d == 254。同样，结果中溢出的
               // 高位比特将被截断舍弃。

// 结果为类型不确定常量，允许溢出其默认类型。
const X = 0x1FFFFFFFF * 0x1FFFFFFFF // 没问题，尽管X溢出
const R = 'a' + 0x7FFFFFFF          // 没问题，尽管R溢出

// 运算结果或者转换结果为类型确定常量
var e = X                // error: X溢出int。
var h = R                // error: R溢出rune。
const Y = 128 - int8(1)  // error: 128溢出int8。
const Z = uint8(255) + 1 // error: 256溢出uint8。
```

#### 关于算术运算的结果

除了移位运算，对于一个二元算术运算，

- 如果它的两个操作数都为类型确定值，则此运算的结果也是一个和这两个操作数类型相同的类型确定值。
- 如果只有一个操作数是类型确定的，则此运算的结果也是一个和此类型确定操作数类型相同的类型确定值。 另一个类型不确定操作数的类型将被推断为（或隐式转换为）此类型确定操作数的类型。
- 如果它的两个操作数均为类型不确定值，则此运算的结果也是一个类型不确定值。 在运算中，两个操作数的类型将被设想为它们的默认类型中一个（按照此优先级来选择：`complex128`高于`float64`高于`rune`高于`int`）。 结果的默认类型同样为此设想类型。 比如，如果一个类型不确定操作数的默认类型为`int`，另一个类型不确定操作数的默认类型为`rune`， 则前者的类型在运算中也被视为`rune`，运算结果为一个默认类型为`rune`的类型不确定值。

对于移位运算，结果规则有点小复杂。首先**移位运算的结果肯定都是整数**。

- 如果左操作数是一个类型确定值（则它的类型必定为整数），则此移位运算的结果也是一个和左操作数类型相同的类型确定值。
- 如果左操作数是一个类型不确定值**并且右操作数是一个常量**，则左操作数将总是被视为一个整数。 如果它的默认类型不是一个整数（`rune`或`int`），则它的默认类型将被视为`int`。 此移位运算的结果也是一个类型不确定值并且它的默认类型和左操作数的默认类型一致。
- 如果左操作数是一个类型不确定值**并且右操作数是一个非常量**，则左操作数将被首先转化为运算结果的期待设想类型。 如果期待设想类型并没有被指定，则左操作数的默认类型将被视为它的期待设想类型。 如果此期待设想类型不是一个内置整数类型，则编译报错。 当然最终运算结果是一个类型为此期待设想类型的类型确定值。

一些非移位算术运算的例子：

```go
func main() {
	// 三个类型不确定常量。它们的默认类型
	// 分别为：int、rune和complex64.
	const X, Y, Z = 2, 'A', 3i


	var a, b int = X, Y // 两个类型确定值

	// 变量d的类型被推断为Y的默认类型：rune（亦即int32）。
	d := X + Y
	// 变量e的类型被推断为a的类型：int。
	e := Y - a
	// 变量f的类型和a及b的类型一样：int。
	f := a * b
	// 变量g的类型被推断为Z的默认类型：complex64。
	g := Z * Y

	// 2 65 (+0.000000e+000+3.000000e+000i)
	println(X, Y, Z)
	// 67 63 130 (+0.000000e+000+1.950000e+002i)
	println(d, e, f, g)
}
```

一个移位算术运算的例子：

```go
const N = 2
// A == 12，它是一个默认类型为int的类型不确定值。
const A = 3.0 << N
// B == 12，它是一个类型为int8的类型确定值。
const B = int8(3.0) << N

var m = uint(32)
// 下面的三行是相互等价的。
var x int64 = 1 << m  // 1的类型将被设想为int64，而非int
var y = int64(1 << m) // 同上
var z = int64(1) << m // 同上

// 下面这行编译不通过。
/*
var _ = 1.23 << m // error: 浮点数不能被移位
*/
```

上面提到的移位运算结果的最后一点类型推断规则有点反常。 这条规则的主要目的是为了防止一些移位运算在32位架构和64位架构的机器上的运算结果出现不一致但不一致却没有被及时发现的情况。 比如如果上面一段代码中第*10*行（或第*9*行）的`1`的类型被推断为它的默认类型`int`， 则在32位架构的机器上，`x`的取值在运行时刻将被截断为*0*，而在64位架构的机器上，`x`的取值在运行时刻将为*232*。 因为`m`是一个变量，在32位架构的机器上，第*9*行和第*10*行并不会在编译时刻报错。 这将导致Go程序员在不经意间写出没有料到的和难以觉察的bug。 因此，第*9*行和第*10*行中的`1`的类型被推断为`int64`（最终的设想结果类型），而不是它们的默认类型`int`。

下面这段代码展示了对于左操作数为类型不确定值的移位运算，编译结果因右操作数是否为常量而带来的不同结果：

```go
const n = uint(2)
var m = uint(2)

// 这两行编译没问题。
var _ float64 = 1 << n
var _ = float64(1 << n)

// 这两行编译失败。
var _ float64 = 1 << m  // error
var _ = float64(1 << m) // error
```

上面这段代码最后两行编译失败是因为它们都等价于下面这两行：

```go
var _ = float64(1) << m
var _ = 1.0 << m // error: shift of type float64
```

另一个例子：

```go
package main

const n = uint(8)
var m = uint(8)

func main() {
	println(a, b) // 2 0
}

var a byte = 1 << n / 128
var b byte = 1 << m / 128
```

上面这个程序打印出`2 0`，因为最后两行等价于：

```go
var a = byte(int(1) << n / 128)
var b = byte(1) << m / 128
```

#### 关于除法和余数运算

假设两个操作数`x`和`y`的类型为同一个整数类型， 则它们通过除法和余数运算得到的商`q`（`= x / y`）和余数`r`（`= x % y`）满足`x == q*y + r`（`|r| < |y|`）。如果余数`r`不为零，则它的符号和被除数`x`相同。商`q`的结果为`x / y`向零靠拢截断。

如果除数`y`是一个常量，则它必须不为0，否则编译不通过。 如果它是一个整数型非常量，则在运行时刻将抛出一个恐慌（panic）。 **恐慌类似于某些其它语言中的异常（exception）**。  如果除数`y`非整数型的非常量，则运算结果为一个无穷大（Inf，当被除数不为0时）或者NaN（not a number，当被除数为0时）。

示例：

```go
println(5/3,   5%3)  // 1 2
println(5/-3,  5%-3) // -1 2
println(-5/3,  -5%3)  // -1 -2
println(-5/-3, -5%-3) // 1 -2

println(5.0 / 3.0)     // 1.666667
println((1-1i)/(1+1i)) // -1i

var a, b = 1.0, 0.0
println(a/b, b/b) // +Inf NaN

_ = int(a)/int(b) // 编译没问题，但在运行时刻将造成恐慌。

// 这两行编译不通过。
println(1.0/0.0) // error: 除数为0
println(0.0/0.0) // error: 除数为0
```

#### `op=`运算符

对于一个二元算数运算符`op`，语句`x = x op y`可以被简写为`x op= y`。 在这个简写的语句中，`x`只会被估值一次。

示例：

```go
var a, b int8 = 3, 5
a += b
println(a) // 8
a *= a
println(a) // 64
a /= b
println(a) // 12
a %= b
println(a) // 2
b <<= uint(a)
println(b) // 20
```

#### 自增和自减操作符

和很多其它流行语言一样，Go也支持自增（`++`）和自减（`--`）操作符。 不过和其它语言不一样的是，**自增（`aNumber++`）和自减（`aNumber--`）操作没有返回值**， 所以它们**不能当做表达式来使用**。 另一个显著区别是，在Go中，自增（`++`）和自减（`--`）操作符**只能后置，不能前置**。

一个例子：

```go
package main

func main() {
	a, b, c := 12, 1.2, 1+2i
	a++ // ok. <=> a += 1 <=> a = a + 1
	b-- // ok. <=> b -= 1 <=> b = b - 1
	c++ // ok.

	// 下面这些行编译不通过。
	/*
	_ = a++
	_ = b--
	_ = c++
	++a
	--b
	++c
	*/
}
```

### 字符串衔接运算符

加法运算符可用做字符串衔接运算符。

| 字面形式 | 名称       | 对两个操作数的要求                   |
| -------- | ---------- | ------------------------------------ |
| +        | 字符串衔接 | 两个操作数必须为同一类型的字符串值。 |

`+=`运算符也适用于字符串衔接。

示例：

```go
println("Go" + "lang") // Golang
var a = "Go"
a += "lang"
println(a) // Golang
```

如果一个字符串衔接运算中的一个操作值为类型确定的，则结果字符串是一个类型和此操作数类型相同的类型确定值。 否则，结果字符串是一个类型不确定值（肯定是一个常量）。

### 布尔（又称逻辑）运算符

Go支持两种布尔二元运算符和一种布尔一元运算符。

| 字面形式 | 名称           | 对操作值的要求                             |
| -------- | -------------- | ------------------------------------------ |
| &&       | 布尔与（二元） | 两个操作值的类型必须为同一布尔类型。       |
| \|\|     | 布尔或（二元） |                                            |
| !        | 布尔否（一元） | 唯一的一个操作值的类型必须为一个布尔类型。 |

我们可以用即将介绍的不等于操作符`!=`来做为布尔异或操作符。

机理解释：

```go
// x    y       x && y   x || y   !x      !y
true    true    true     true     false   false
true    false   false    true     false   true
false   true    false    true     true    false
false   false   false    false    true    true
```

如果一个布尔运算中的一个操作值为类型确定的，则结果为一个和此操作值类型相同的类型确定值。 否则，结果为一个类型不确定布尔值。

### 比较运算符

Go支持6种比较运算符：

| 字面形式 | 名称       | 对两个操作值的要求                                           |
| -------- | ---------- | ------------------------------------------------------------ |
| ==       | 等于       | 如果两个操作数都为类型确定的，则它们的类型必须一样，或者其中一个操作数可以隐式转换为另一个操作数的类型。 两者的类型必须都为可比较类型（将在以后的文章中介绍）。如果只有一个操作数是类型确定的，则另一个类型不确定操作数必须可以隐式转换到类型确定操作数的类型。如果两个操作数都是类型不确定的，则它们必须同时为两个类型不确定布尔值、两个类型不确定字符串值或者两个类型不确定数字值。 |
| !=       | 不等于     | 同 ==                                                        |
| <        | 小于       | 两个操作值的类型必须相同并且它们的类型必须为整数类型、浮点数类型或者字符串类型。 |
| <=       | 小于或等于 | 同 <                                                         |
| >        | 大于       | 同 <                                                         |
| >=       | 大于或等于 | 同 <                                                         |

比较运算的结果总是一个类型不确定布尔值。 如果一个比较运算中的两个操作数都为常量，则结果布尔值也为一个常量。

如果我们说两个值可以比较，我们的意思是说这两个值可以用`==`或者`!=`运算符来比较。我们将了解到某些类型的值是不能比较的。

注意，并非所有的实数在内存中都可以被精确地表示，所以比较两个浮点数或者复数的结果并不是很可靠。 在编程中，我们常常比较两个浮点数的差值是否小于一个阙值来检查两个浮点数是否相等。

### 操作符运算的优先级

Go中的操作符运算的优先级和其它流行语言有一些差别。 下面列出了本文介绍的操作符的优先级。 同一行中的操作符的优先级是一样的。优先级逐行递减。

```go
*   /   %   <<  >>  &   &^
+   -   |   ^
==  !=  <   <=  >   >=
&&
||
```

一个和其它流行语言明显的差别是，移位运算`<<`和`>>`的优先级比加减法`+`和`-`的优先级要高。

一个表达式（做为一个子表达式）可以出现在另一个表达式中。 这个子表达式的估值结果将成为另一个表达式的一个操作数。 在这样的复杂表达式中，对于相同优先级的运算，它们将从左到右进行估值。 和很多其它语言一样，我们也可用一对小括号`()`来提升一个子运算的优先级。

### 更多关于常量表达式

**常量子表达式的顺序有可能影响到最终的估值结果**。

下面这个声明的变量将被初始化为`2.2`，而不是`2.7`。 优先级更高的子表达式`3/2`是一个常量表达式，所以它将在编译阶段被估值。 根据上面介绍的规则，在运算中，`3`和`2`都被视为`int`，所以`3/2`的估值结果为`1`。 在常量表达式`1.2 + 1`的运算中，两个操作数的类型被视为`float64`，所以最终的估值结果为`2.2`。

```go
var x = 1.2 + 3/2
```

再比如下例，在一个常量声明中，`3/2`先被估值，其结果为`1`，所以最终的估值结果为`0.1`。 在第二个常量声明中，`0.1*3`先被估值，其结果为`0.3`，所以最终的估值结果为`0.15`。

```go
package main

const x = 3/2*0.1
const y = 0.1*3/2

func main() {
	println(x) // +1.000000e-001
	println(y) // +1.500000e-001
}
```

### 更多其它操作符

Go中还有一些其它操作符。它们将在后续介绍。

------



## 函数声明和调用

函数操作常被称为函数调用。这里将介绍如何在Go中声明和调用函数。

### 函数声明

让我们来看一个函数声明：

```go
func SquaresOfSumAndDiff(a int64, b int64) (s int64, d int64) {
	x, y := a + b, a - b
	s = x * x
	d = y * y
	return // <=> return s, d
}
```

从上面的例子中，我们可以发现一个函数声明从左到右由以下部分组成：

1. 第一部分是**`func`关键字**。
2. 第二部分是**函数名称**。函数名称必须是一个标识符。 这里的函数名称是`SquareOfSumAndDiff`。
3. 第三部分是**输入参数列表**。输入参数声明列表必须用一对小括号括起来。 输入参数声明有时也称为**形参声明**（对应后面将介绍的函数调用中的实参）。
4. 第四部分是**输出结果声明列表**。**在Go中，一个函数可以有多个返回值**。 比如上面这个例子就有两个返回值。 当一个函数的输出结果声明列表为空或者只包含一个匿名结果声明时，此列表可以不用一对小括号括起来（见下面的示例）；否则，小括号是必需的。
5. 最后一部分是**函数体**。函数体必须用一对大括号括起来。 一对大括号和它其间的代码形成了一个显式代码块。 在一个函数体内，`return`关键字可以用来结束此函数的正常向前执行流程并进入此函数的退出阶段（详见下下节中的解释）。

在上面的例子中，每个函数参数和结果声明都由一个名字和一个类型组成（**变量名字在前，类型在后**）。 我们**可以把一个参数和结果声明看作是一个省略了`var`关键字的标准变量声明**。 上面这个函数有两个输入参数（`a`和`b`）以及两个输出结果（`x`和`y`）。 它们的类型都是`int64`。

输出结果声明列表中的所有声明中的**结果名称**可以（而且**必须）同时出现或者同时省略**。 这两种方式在实践中都使用得很广泛。 如果一个返回结果声明中的结果名称没有省略，则这个返回结果称为**具名返回结果**。否则称为**匿名返回结果**。

如果一个函数声明的所有返回结果均为匿名的，则在此函数体内的返回语句`return`关键字后必须跟随一系列返回值，这些**返回值和此函数的各个返回结果声明一一对应**。比如，下面这个函数声明和上例中的函数声明是等价的。

```go
func SquaresOfSumAndDiff(a int64, b int64) (int64, int64) {
	return (a+b) * (a+b), (a-b) * (a-b)
}
```

事实上，如果一个函数声明中的所有**输入参数在此函数体内都没有被使用过，则它们也可以都同时是匿名的**。 不过这种情形在实际编程中很少见。

尽管一个函数声明中的输入参数和返回结果看上去是声明在这个函数体的外部，但是在此函数体内，**这些输入参数和输出结果被当作局部变量来使用**。 但输入参数和输出结果和普通局部变量还是有一点区别的：目前的主流Go编译器不允许一个名称不为`_`的普通局部变量被声明而不有效使用。

**Go不支持输入参数默认值。每个返回结果的默认值是它的类型的零值**。 比如，下面的函数在被调用时将打印出（和返回）`0 false`。

```go
func f() (x int, y bool) {
	println(x, y) // 0 false
	return
}
```

和普通的变量声明一样，**如果若干连续的输入参数或者返回结果的类型相同，则在它们的声明中可以共用一个类型**。 比如，上面的两个`SquaresOfSumAndDiff`函数声明和下面这个是完全等价的。

```go
func SquaresOfSumAndDiff(a, b int64) (s, d int64) {
	return (a+b) * (a+b), (a-b) * (a-b)
	// 上面这行等价于下面这行：
	// s = (a+b) * (a+b); d = (a-b) * (a-b); return
}
```

注意，尽管在上面这个函数声明的返回结果都是具名的，函数体内的`return`关键字后仍然可以跟返回值。

**如果一个函数声明只包含一个返回结果，并且此返回结果是匿名的，则此函数声明中的返回结果部分不必用小括号括起来**。 **如果一个函数声明的返回结果列表为空，则此函数声明中的返回结果部分可以完全被省略掉**。 一个函数声明的输入参数列表部分总不能省略掉，即使此函数声明的输入参数列表为空。

下面是更多函数声明的例子：

```go
func CompareLower4bits(m, n uint32) (r bool) {
	// 下面这两行等价于：return m&0xFF > n&0xff
	r = m&0xF > n&0xf
	return
}

// 此函数没有输入参数。它的结果声明列表只包含一个
// 匿名结果声明，因此它不必用()括起来。
func VersionString() string {
	return "go1.0"
}

// 此函数没有返回结果。它的所有输入参数都是匿名的。
// 它的结果声明列表为空，因此可以被省略掉。
func doNothing(string, int) {
}
```

在前面的文章中，我们已经知道一个程序的`main`入口函数必须不带任何输入参数和返回结果。

注意，在Go中，所有函数都必须直接声明在包级代码块中。 或者说，**任何一个函数都不能被声明在另一个函数体内**。 **虽然匿名函数（将在下面的某节中介绍）可以定义在函数体内，但匿名函数定义不属于函数声明**。

### 函数调用

一个声明的函数可以通过它的名称和一个实参列表来调用之。 **一个实参列表必须用小括号括起来。 实参列表中的每一个单值实参对应着（或称被传递给了）一个形参**。

注意：**函数传参也属于赋值操作**。在传参中，各个实参被赋值给各个对应形参。

一个实参值的类型不必一定要和其对应的形参声明的类型一样。 但如果一个实参值的类型和其对应的形参声明的类型不一致，则此实参**必须能够隐式转换到其对应的形参的类型**。

**如果一个函数带有返回值，则它的一个调用被视为一个表达式**。如果此函数返回多个结果，则它的每个调用被视为一个多值表达式。 一个多值表达式可以被同时赋值给多个目标值（数量必须匹配，各个输出结果被赋值给相对应的目标值）。

下面这个例子完整地展示了如何调用几个已经声明了的函数。

```go
package main

func SquaresOfSumAndDiff(a int64, b int64) (int64, int64) {
	return (a+b) * (a+b), (a-b) * (a-b)
}

func CompareLower4bits(m, n uint32) (r bool) {
	r = m&0xF > n&0xf
	return
}

// 使用一个函数调用的返回结果来初始化一个包级变量。
var v = VersionString()

func main() {
	println(v) // v1.0
	x, y := SquaresOfSumAndDiff(3, 6)
	println(x, y) // 81 9
	b := CompareLower4bits(uint32(x), uint32(y))
	println(b) // false
	// "Go"的类型被推断为string；1的类型被推断为int32。
	doNothing("Go", 1)
}

func VersionString() string {
	return "v1.0"
}

func doNothing(string, int32) {
}
```

从上例可以看出，**一个函数的声明可以出现在它的调用之前，也可以出现在它的调用之后**。

**一个函数调用可以被延迟执行或者在另一个协程（goroutine，或称绿色线程）中执行**。 后面的一文将对这两个特性进行详解。

### 函数调用的退出阶段

**在Go中，当一个函数调用返回后（比如执行了一个`return`语句或者函数中的最后一条语句执行完毕）， 此调用可能并未立即退出**。**一个函数调用从返回开始到最终退出的阶段称为此函数调用的退出阶段（exiting phase）**。 函数调用的退出阶段的意义将在讲解**延迟函数**的时候体现出来。

函数调用的退出阶段将在后面的一篇文章中详细解释。

### 匿名函数

Go支持匿名函数。**定义一个匿名函数和声明一个函数类似，但是一个匿名函数的定义中不包含函数名称部分**。 注意**匿名函数定义不是一个函数声明**。

**一个匿名函数在定义后可以被立即调用**，比如：

```go
package main

func main() {
	// 这个匿名函数没有输入参数，但有两个返回结果。
	x, y := func() (int, int) {
		println("This function has no parameters.")
		return 3, 4
	}() // 一对小括号表示立即调用此函数。不需传递实参。

	// 下面这些匿名函数没有返回结果。

	func(a, b int) {
		println("a*a + b*b =", a*a + b*b) // a*a + b*b = 25
	}(x, y) // 立即调用并传递两个实参。

	func(x int) {
		// 形参x遮挡了外层声明的变量x。
		println("x*x + y*y =", x*x + y*y) // x*x + y*y = 32
	}(y) // 将实参y传递给形参x。

	func() {
		println("x*x + y*y =", x*x + y*y) // x*x + y*y = 25
	}() // 不需传递实参。
}
```

注意，**上例中的最后一个匿名函数处于变量`x`和`y`的作用域内，所以在它的函数体内可以直接使用这两个变量。 这样的函数称为闭包（closure）**。事实上，**Go中的所有的自定义函数（包括声明的函数和匿名函数）都可以被视为闭包**。 这就是为什么Go中的函数使用起来和动态语言中的函数一样灵活。

在后面的文章中，我们将了解到**一个匿名函数可以被赋值给某个函数类型的值，从而我们不必在定义完此匿名函数后立即调用它，而是可以在以后合适的时候再调用它**。

### 内置函数

Go支持一些内置函数，比如前面的例子中已经用到过多次的`println`和`print`函数。 **我们可以不引入任何库包（见下一篇文章）而调用一个内置函数**。

我们可以使用内置函数`real`和`imag`来得到一个复数的实部和虚部（均为浮点数类型）。 注意，如果这两个函数的任何一个调用的实参是一个常量，则此调用将在编译时刻被估值，其返回结果也是一个常量。 此调用将被视为一个常量表达式。特别地，如果此实参是一个类型不确定值，则返回结果也是一个类型不确定值。

一个例子：

```go
// c是一个类型不确定复数常量。
const c = complex(1.6, 3.3)

// 函数调用real(c)和imag(c)的结果都是类型
// 不确定浮点数值。在下面这句赋值中，它们都
// 被推断为float32类型的值。
var a, b float32 = real(c), imag(c)

// 变量d的类型被推断为内置类型complex64。
// 函数调用real(d)和imag(d)的结果都是
// 类型为float32的类型确定值。
var d = complex(a, b)

// 变量e的类型被推断为内置类型complex128。
// 函数调用real(e)和imag(e)的结果都是
// 类型为float64的类型确定值。
var e = c
```

### 更多函数相关的概念

本文是一篇Go函数入门的文章，很多其它函数相关的概念并未在此文中解释。 今后，我们可以从**函数类型和函数值**一文中了解到和函数相关的其它概念。

------



## 代码包和包引入

和很多现代编程语言一样，Go代码包（package）来组织管理代码。 我们必须先引入一个代码包（除了`builtin`标准库包）才能使用其中导出的代码要素（比如函数、类型、变量和具名常量等）。 此篇文章将讲解Go代码包和代码包引入（import）。

### 包引入

下面这个简短的程序（假设它存在一个名为`simple-import-demo.go`的源文件中）引入了一个标准库包。

```go
package main

import "fmt"

func main() {
	fmt.Println("Go has", 25, "keywords.")
}
```

对此程序的一些解释：

- 第一行指定了源文件`simple-import-demo.go`所处的包名为`main`。 程序入口`main`函数必须处于一个名为`main`的代码包中。
- 第三行通过使用`import`关键字引入了`fmt`标准库包。 在此源文件中，`fmt`标准库包将用`fmt`标识符来表示。 标识符`fmt`称为`fmt`标准库包的**引入名称**。（后续某节将详述代码包的引入名称）。
- `fmt`标准库包中声明了很多终端打印函数供其它代码包使用。 `Println`函数是其中之一。 它可以将不定数量参数的字符串表示形式输出到标准输出中。 第六行调用了此`Println`函数。 注意在此调用中，函数名之前需要带上前缀`fmt.`，其中`fmt`是`Println`函数所处的代码包的引入名称。 `aImportName.AnExportedIdentifier`这种形式称为一个限定标识符（[qualified identifier](https://golang.google.cn/ref/spec#Qualified_identifiers)）。
- `fmt.Println`函数调用**接受任意数量的实参并且对实参的类型没有任何限制**。 所以此程序中的此函数调用的三个实参的类型将被推断为它们各自的默认类型：`string`、`int`和`string`。
- 对于一个`fmt.Println`函数调用，任何两个相邻的实参的输出之间将被插入一个空格字符，并且在最后将输出一个空行字符。

下面是上面这个程序的运行结果：

```bash
$ go run simple-import-demo.go
Go has 25 keywords.
```

当一个代码包被引入一个Go源文件时，**只有此代码包中的[导出](https://gfw.go101.org/article/keywords-and-identifiers.html#identifier)代码要素（名称为大写字母的变量、常量、函数、定义类型和类型别名等）可以在此源文件被使用**。 比如上例中的`Println`函数即为一个导出代码要素，所以它可以在上面的程序源文件中使用。

前面几篇文章中使用的内置函数`print`和`println`提供了和`fmt`标准库包中的对应函数相似的功能。 **内置函数可以不用引入任何代码包而直接使用**。

注意：`print`和`println`这两个内置函数**不推荐使用在生产环境**，因为它们不保证一定会出现在以后的Go版本中。

我们可以访问[Go官网](https://golang.org/pkg/)（[墙内版](https://golang.google.cn/pkg/)）来查看各个标准库包的文档， 我们也可以[开启一个本地文档服务器](https://gfw.go101.org/article/go-toolchain.html#doc)来查看这些文档。

**一个包引入也可称为一个包声明。一个包声明只在当前包含此声明的源文件内可见**。

另外一个例子：

```go
package main

import "fmt"
import "math/rand"

func main() {
	fmt.Printf("下一个伪随机数是%v。\n", rand.Uint32())
}
```

这个例子多引入了一个`math/rand`标准库包。 此包是`math`标准库包中的一个子包。 此包提供了一些函数来产生伪随机数序列。

一些解释：

- 在此例中，`math/rand`标准库包的引入名是`rand`。 `rand.Uint32()`函数调用将返回一个`uint32`类型的随机数。
- `Printf`函数是`fmt`标准库包中提供的另外一个常用终端打印函数。 一个`Printf`函数调用必须带有至少一个实参，并且第一个实参的类型必须为`string`。 此第一个实参指定了此调用的打印格式。此格式中的`%v`在打印结果将被对应的后续实参的字符串表示形式所取代。 比如上列中的`%v`在打印结果中将被`rand.Uint32()`函数调用所返回的随机数所取代。 打印格式中的`\n`表示一个换行符，这在[基本类型和它们的字面量表示](https://gfw.go101.org/article/basic-types-and-value-literals.html)一文中已经解释过。

上面这个程序的输出如下：

```bash
下一个伪随机数是2596996162。
```

注意：在Go 1.20之前，如果我们希望上面的程序每次运行的时候输出一个不同的随机数，我们需要在程序启动的时候调用`rand.Seed`函数来设置一个不同的随机数种子。

**多个包引入语句可以用一对小括号来合并成一个包引入语句**。比如下面这例。

```go
package main

// 一条包引入语句引入了三个代码包。
import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	// 设置随机数种子（仅在Go 1.20之前需要）。
	rand.Seed(time.Now().UnixNano())
	fmt.Printf("下一个伪随机数是%v。\n", rand.Uint32())
}
```

一些解释：

- 此例多引入了一个`time`标准库包。 此包提供了很多和时间相关的函数和类型。 其中`time.Time`和`time.Duration`是两个最常用的类型。
- 函数调用`time.Now()`将返回一个**表示当前时间**的类型为`time.Time`的值。
- `UnixNano`是类型`time.Time`的一个方法。 我们可以把方法看作是特殊的函数。方法将在[Go中的方法](https://gfw.go101.org/article/method.html)一文中详述。 方法调用`aTime.UnixNano()`将返回从UTC时间的1970年一月一日到`aTime`所表示的时间之间的纳秒数。 返回结果的类型为`int64`，这也是`rand.Seed`函数的参数类型（注意：`rand.Seed`函数从Go 1.20开始被声明为废弃了）。 在上例中，此方法调用的结果用来设置随机数种子。

### 更多关于`fmt.Printf`函数调用的输出格式

从上面的例子中，我们已经了解到`fmt.Printf`函数调用的第一个实参中的`%v`在输出中将替换为后续的实参的字符串表示形式。 实际上，这种百分号开头的占位字符组合还有很多。下面是一些常用的占位字符组合：

- `%v`：将被替换为对应实参字符串表示形式。
- `%T`：将替换为对应实参的类型的字符串表示形式。
- `%x`：将替换为对应实参的十六进制表示。实参的类型可以为字符串、整数、整数数组（array）或者整数切片（slice）等。 （数组和切片将在以后的文章中讲解。）
- `%s`：将被替换为对应实参的字符串表示形式。实参的类型必须为字符串或者字节切片（byte slice）类型。
- `%%`：将被替换为一个百分号。

一个例子：

```go
package main

import "fmt"

func main() {
	a, b := 123, "Go"
	fmt.Printf("a == %v == 0x%x, b == %s\n", a, a, b)
	fmt.Printf("type of a: %T, type of b: %T\n", a, b)
	fmt.Printf("1%% 50%% 99%%\n")
}
```

输出：

```bash
a == 123 == 0x7b, b == Go
type of a: int, type of b: string
1% 50% 99%
```

请阅读[`fmt`标准库包的文档](https://golang.google.cn/pkg/fmt/)以了解更多的占位字符组合。 我们也可以运行`go doc fmt`命令来在终端中查看`fmt`标准库包的文档。 运行`go doc fmt.Printf`命令可以查看`fmt.Printf`函数的文档。

### 代码包目录、代码包引入路径和代码包依赖关系

**一个代码包可以由若干Go源文件组成**。**一个代码包的源文件须都处于同一个目录下**。 **一个目录（不包含子目录）下的所有源文件必须都处于同一个代码包中，亦即这些源文件开头的`package pkgname`语句必须一致**。 所以，**一个代码包对应着一个目录（不包含子目录）**，反之亦然。 对应着一个代码包的目录称为此代码包的目录。 **一个代码包目录下的每个子目录对应的都是另外一个独立的代码包**。

对于Go官方工具链来说，**一个引入路径中包含有`internal`目录名的代码包被视为一个特殊的代码包**。 **它只能被此`internal`目录的直接父目录（和此父目录的子目录）中的代码包所引入**。 比如，代码包`.../a/b/c/internal/d/e/f`和`.../a/b/c/internal`只能被引入路径含有`.../a/b/c`前缀的代码包引入。

**当一个代码包中的某个文件引入了另外一个代码包，则我们说前者代码包依赖于后者代码包**。

**Go不支持循环引用（依赖）**。 如果一个代码包`a`依赖于代码包`b`，同时代码包`b`依赖于代码包`c`，则代码包`c`中的源文件不能引入代码包`a`和代码包`b`，代码包`b`中的源文件也不能引入代码包`a`。

当然，一个代码包中的源文件不能也没必要引入此代码包本身。

今后，我们**称一个程序中含有`main`入口函数的名称为`main`的代码包为程序代码包（或者命令代码包）**，**称其它代码包为库代码包**。 **程序代码包不能被其它代码包引入**。**一个程序只能有一个程序代码包**。

代码包目录的名称并不要求一定要和其对应的代码包的名称相同。 但是，**库代码包目录的名称最好设为和其对应的代码包的名称相同。 因为一个代码包的引入路径中包含的是此包的目录名，但是此包的默认引入名为此包的名称**。 如果两者不一致，会使人感到困惑。

另一方面，最好给每个程序代码包目录指定一个有意义的名字，而不是它的包名`main`。

### `init`函数

在一个代码包中，甚至一个源文件中，**可以声明若干名为`init`的函数**。 这些`init`函数**必须不带任何输入参数和返回结果**。

注意：**我们不能声明名为`init`的包级变量、常量或者类型**。

在程序运行时刻，**在进入`main`入口函数之前，每个`init`函数在此包加载的时候将被（串行）执行并且只执行一遍**。

下面这个简单的程序中有两个`init`函数：

```go
package main

import "fmt"

func init() {
	fmt.Println("hi,", bob)
}

func main() {
	fmt.Println("bye")
}

func init() {
	fmt.Println("hello,", smith)
}

func titledName(who string) string {
	return "Mr. " + who
}

var bob, smith = titledName("Bob"), titledName("Smith")
```

此程序的运行结果：

```bash
hi, Mr. Bob
hello, Mr. Smith
bye
```

### 程序代码要素初始化顺序

一个程序中所涉及到的所有的在运行时刻要用到的**代码包的加载是串行执行的**。 在一个程序启动时，**每个包中总是在它所有依赖的包都加载完成之后才开始加载**。 **程序代码包总是最后一个被加载的代码包。每个被用到的包会被而且仅会被加载一次**。

**在加载一个代码包的过程中，所有的声明在此包中的`init`函数将被串行调用并且仅调用执行一次**。 一个代码包中声明的`init`函数的调用肯定晚于此代码包所依赖的代码包中声明的`init`函数。 **所有的`init`函数都将在调用`main`入口函数之前被调用执行**。

**在同一个源文件中声明的`init`函数将按从上到下的顺序被调用执行**。 **对于声明在同一个包中的两个不同源文件中的两个`init`函数，Go语言白皮书推荐（但不强求）按照它们所处于的源文件的名称的词典序列（对英文来说，即字母顺序）来调用**。 **所以最好不要**让声明在同一个包中的两个不同源文件中的两个`init`函数存在依赖关系。

**在加载一个代码包的时候，此代码包中声明的所有包级变量都将在此包中的任何一个`init`函数执行之前初始化完毕**。

**在同一个包内，包级变量将尽量按照它们在代码中的出现顺序被初始化，但是一个包级变量的初始化肯定晚于它所依赖的其它包级变量**。 比如，在下面的代码片段中，四个包级变量的初始化顺序依次为`y`、`z`、`x`、`w`。

```go
func f() int {
	return z + y
}

func g() int {
	return y/2
}

var (
	w       = x
	x, y, z = f(), 123, g()
)
```

关于更具体的包级变量的初始化顺序，请阅读[表达式估值顺序规则](https://gfw.go101.org/article/evaluation-orders.html#package-level-variables)一文。

### 完整的引入声明语句形式

事实上，一个引入声明语句的完整形式为：

```go
import importname "path/to/package"
```

其中引入名`importname`是可选的，它的**默认值为被引入的包的包名**（不是目录名）。

事实上，在本文上面的例子中的包引入声明中，`importname`部分都被省略掉了，因为它们都分别和引入的代码包的包名相同。 这些引入声明等价于下面这些：

```go
import fmt "fmt"        // <=> import "fmt"
import rand "math/rand" // <=> import "math/rand"
import time "time"      // <=> import "time"
```

**如果一个包引入声明中的`importname`没有省略，则限定标识符使用的前缀必须为`importname`，而不是被引入的包的名称**。

引入声明语句的完整形式在日常编程中使用的频率不是很高。 但是在某些情况下，完整形式必须被使用。 比如，**如果一个源文件引入的两个代码包的包名一样，为了防止使编译器产生困惑，我们至少需要用完整形式为其中一个包指定一个不同的引入名以区分这两个包**。

下面是一个使用了完整引入声明语句形式的例子。

```go
package main

import (
	format "fmt"
	random "math/rand"
	"time"
)

func main() {
	random.Seed(time.Now().UnixNano())
	format.Print("一个随机数:", random.Uint32(), "\n")

	// 下面这行编译不通过，因为rand不可识别。
	/*
	fmt.Print("一个随机数:", rand.Uint32(), "\n")
	*/
}
```

一些解释：

- 我们必须使用`format`和`random`，而不是`fmt`和`rand`，来做为限定标识符的前缀。
- `Print`是`fmt`标准库包中的另外一个函数。 和`Println`函数调用一样，一个`Print`函数调用也接受任意数量实参。 它将逐个打印出每个实参的字符串表示形式。如果相邻的两个实参都不是字符串类型，则在它们中间会打印一个空格字符。

**一个完整引入声明语句形式的引入名`importname`可以是一个句点(`.`)。 这样的引入称为句点引入。使用被句点引入的包中的导出代码要素时，限定标识符的前缀必须省略**。

例子：

```go
package main

import (
	. "fmt"
	. "time"
)

func main() {
	Println("Current time:", Now())
}
```

在上面这个例子中，`Println`和`Now`函数调用不需要带任何前缀。

一般来说，**句点引入不推荐使用**，因为它们会导致较低的代码可读性。

**一个完整引入声明语句形式的引入名`importname`可以是一个空标识符(`_`)。 这样的引入称为匿名引入。一个包被匿名引入的目的主要是为了加载这个包，从而使得这个包中的代码要素得以初始化。 被匿名引入的包中的`init`函数将被执行并且仅执行一遍**。

在下面这个例子中，[`net/http/pprof`标准库包](https://golang.google.cn/pkg/net/http/pprof/)中的所有`init`函数将在`main`入口函数开始执行之前全部执行一遍。

```go
package main

import _ "net/http/pprof"

func main() {
	... // 做一些事情
}
```

### 每个非匿名引入必须至少被使用一次

除了匿名引入，其它引入必须在代码中被使用一次。 比如，下面的程序编译不通过。

```go
package main

import (
	"net/http" // error: 引入未被使用
	. "time"   // error: 引入未被使用
)

import (
	format "fmt"  // okay: 下面被使用了一次
	_ "math/rand" // okay: 匿名引入
)

func main() {
	format.Println() // 使用"fmt"包
}
```

### 模块

一个模块（module）为的若干代码包的集合。当被下载至本地后，这些代码包处于同一个目录（此模块的根目录）下。 一个模块可以有很多版本（版本号遵从[Semantic Versioning](https://semver.org/)规范）。 更多关于模块的概念和使用，请阅读[官方文档](https://golang.google.cn/ref/mod)。

------



## 表达式、语句和简单语句

将简单介绍一下Go语言中的表达式和语句

简单说来，**一个表达式表示一个值，而一条语句表示一个操作**。 但是在实际中，有些个表达式可能同时表示多个值，有些语句可能是由很多更基本的语句组成的。 另外，根据场合不同，某些语句也可以被视为表达式。

Go中，某些语句被称为简单语句。Go中各种流程控制语句的某些部分可能会被要求必须为简单语句或者表达式。 详见下一篇文章对Go中基本流程控制语句的介绍和解释。

本篇文章将不对表达式和语句作出详尽的解释。 详尽的解释需要大量的篇幅。 本文只是列出一些表达式和语句的例子，并非包括所有的表达式和语句的种类，但是简单语句的所有种类都会被列出来。

### 一些表达式的例子

Go中大多数的表达式都是**单值表达式**。一个单值表达式只表示一个值。 某些表达式可以表示多个值，它们被称为**多值表达式**。

以后（不包括本文），如果没有特殊说明，当表达式这个词被提及的时候，它表示一个单值表达式。

前面的几篇文章介绍的字面量、变量和具名常量等均属于单值表达式。它们可称为基本表达式。

前面的[运算操作符](https://gfw.go101.org/article/operators.html)一文中介绍的运算符操作（不包括赋值部分）也都属于单值表达式。

如果一个函数至少返回一个值，则它的调用属于表达式。 特别的，如果此函数返回两个或两个以上的值，则对它的调用称为多值表达式。 不返回任何结果的函数的调用不属于表达式。

以后的某篇文章中介绍的[方法](https://gfw.go101.org/article/method.html)可以看作是特殊的函数。 所以上述对函数的解释同样适用于方法。

事实上，以后我们将会了解到自定义函数（包括方法）本身都属于函数类型的值，所以它们都是单值表达式。

通道的接收数据操作（不包括赋值部分）也属于表达式。[通道](https://gfw.go101.org/article/channel.html)将在以后详解。

Go中的一些表达式，包括刚提及的通道的接收数据操作，可能会表示可变数量的值。 根据不同的场景，这样的表达式可能呈现为单值表达式，也可能呈现为多值表达式。 我们将在以后的文章中了解到这样的表达式。

### 简单语句类型列表

Go中有六种简单语句类型：

1. 变量短声明语句。
2. 纯赋值语句，包括`x op= y`这种运算形式。
3. 有返回结果的函数或方法调用，以及通道的接收数据操作。 上一节已经提到了，这些语句也可以用做表达式。
4. 通道的发送数据操作。上面已经提到过一次，通道以后将在[此文中](https://gfw.go101.org/article/channel.html)详解。
5. 空语句。在下一篇文章我们将看到一些空语句的应用。
6. 自增（`x++`）和自减（`x--`）语句。

注意：和C/C++不一样，在Go中，自增和自减语句不能被当作表达式使用。

简单语句这个概念在Go中比较重要，所以请牢记这六种简单语句类型。

### 一些非简单语句

下面是一个非简单语句的不完整列表：

- 标准变量声明语句。是的，短声明语句属于简单语句，但是标准变量声明语句不属于。
- （具名）常量声明语句。
- 类型声明语句。
- （代码）包引入语句。
- 显式代码块。一个显式代码块起始于一个左大括号`{`，终止于一个右大括号`}`。 一个显式代码块中可以包含若干子语句。
- 函数声明。 一个函数声明中可以包含若干子语句。
- 流程控制跳转语句。详见下一章。
- 函数返回（`return`）语句。
- 延迟函数调用和协程创建语句。下下篇文章将会介绍。

### 一些表达式和语句的例子

```go
// 一些非简单语句：
import "time"
var a = 123
const B = "Go"
type Choice bool
func f() int {
	for a < 10 {
		break
	}

	// 这是一个显式代码块。
	{
		// ...
	}
	return 567
}

// 一些简单语句的例子：
c := make(chan bool) // 通道将在以后讲解
a = 789
a += 5
a = f() // 这是一个纯赋值语句
a++
a--
c <- true // 一个通道发送操作
z := <-c  // 一个使用通道接收操作
          // 做为源值的变量短声明语句

// 一些表达式的例子：
123
true
B
B + " language"
a - 789
a > 0 // 一个类型不确定布尔值
f     // 一个类型为“func ()”的表达式

// 下面这些即可以被视为简单语句，也可以被视为表达式。
f() // 函数调用
<-c // 通道接收操作
```

------



## 基本流程控制语法

Go中的流程控制语句和其它很多流行语言很类似，但是也有不少区别。 本篇文章将列出所有这些相似点和不同点。

### Go中的流程控制语句简单介绍

Go语言中有三种**基本**的流程控制代码块：

- `if-else`条件分支代码块；
- `for`循环代码块；
- `switch-case`多条件分支代码块。

Go中另外还有几种**和特定种类的类型相关**的流程控制代码块：

- [容器类型](https://gfw.go101.org/article/container.html#iteration)相关的`for-range`循环代码块。
- [接口类型](https://gfw.go101.org/article/interface.html#type-switch)相关的`type-switch`多条件分支代码块。
- [通道类型](https://gfw.go101.org/article/channel.html#select)相关的`select-case`多分支代码块。

和很多其它流行语言一样，Go也支持`break`、`continue`和`goto`等跳转语句。 另外，Go还支持一个**特有**的`fallthrough`跳转语句。

Go所支持的六种流程控制代码块中，除了`if-else`条件分支代码块，其它五种称为**可跳出代码块**。 我们可以**在一个可跳出代码块中使用`break`语句以跳出此代码块**。

我们**可以在`for`和`for-range`两种循环代码块中使用`continue`语句提前结束一个循环步**。 除了这两种循环代码块，其它四种代码块称为**分支代码块**。

请注意，上面所提及的每种流程控制的一个分支都属于一条语句。这样的语句常常会包含很多子语句。

上面所提及的流程控制语句都属于狭义上的流程控制语句。 下一篇文章中将要介绍的[协程、延迟函数调用、以及恐慌和恢复](https://gfw.go101.org/article/control-flows-more.html)，以及今后要介绍的[并发同步技术](https://gfw.go101.org/article/concurrent-synchronization-overview.html)属于广义上的流程控制语句。

本文余下的部分将只解释三种基本的流程控制语句和各种代码跳转语句。其它上面提及的语句将在后面其它文章中逐渐介绍。

### `if-else`条件分支控制代码块

一个`if-else`条件分支控制代码块的完整形式如下：

```go
if InitSimpleStatement; Condition {
	// do something
} else {
	// do something
}
```

`if`和`else`是两个关键字。 和很多其它编程语言一样，`else`分支是可选的。

在一个`if-else`条件分支控制代码块中，

- `InitSimpleStatement`部分是可选的，如果它没被省略掉，则它必须为一条[简单语句](https://gfw.go101.org/article/expressions-and-statements.html#simple-statements)。 如果它被省略掉，它可以被视为一条空语句（简单语句的一种）。 在实际编程中，`InitSimpleStatement`常常为一条变量短声明语句。
- `Condition`必须为一个结果为布尔值的[表达式](https://gfw.go101.org/article/expressions-and-statements.html#expressions)（它被称为条件表达式）。 `Condition`部分可以用一对小括号括起来，但大多数情况下不需要。

注意，我们**不能**用一对小括号将`InitSimpleStatement`和`Condition`两部分括在一起。

在执行一个`if-else`条件分支控制代码块中，如果`InitSimpleStatement`这条语句没有被省略，则此条语句将被**率先执行**。 如果`InitSimpleStatement`被省略掉，则其后跟随的分号`;`也可一块儿被省略。

每个`if-else`流程控制**包含一个隐式代码块**，一个`if`分支显式代码块和一个可选的`else`分支代码块。 这两个分支代码块内嵌在这个隐式代码块中。 在程序运行中，如果`Condition`条件表达式的估值结果为`true`，则`if`分支式代码块将被执行；否则，`else`分支代码块将被执行。

一个例子：

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要

	if n := rand.Int(); n%2 == 0 {
		fmt.Println(n, "是一个偶数。")
	} else {
		fmt.Println(n, "是一个奇数。")
	}

	n := rand.Int() % 2 // 此n不是上面声明的n
	if n % 2 == 0 {
		fmt.Println("一个偶数。")
	}

	if ; n % 2 != 0 { // ;可省略
		fmt.Println("一个奇数。")
	}
}
```

如果`InitSimpleStatement`语句是一个变量短声明语句，则**在此语句中声明的变量被声明在外层的隐式代码块中**。

可选的`else`分支代码块一般情况下必须为显式的，但是如果此分支为另外一个`if-else`块，则此分支代码块可以是隐式的。

另一个例子：

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	if h := time.Now().Hour(); h < 12 {
		fmt.Println("现在为上午。")
	} else if h > 19 {
		fmt.Println("现在为晚上。")
	} else {
		fmt.Println("现在为下午。")
		// 左h是一个新声明的变量，右h已经在上面声明了。
		h := h
		// 刚声明的h遮掩了上面声明的h。
		_ = h
	}

	// 上面声明的两个h在此处都不可见。
}
```

### `for`循环代码块

`for`循环代码块的完整形式如下：

```go
for InitSimpleStatement; Condition; PostSimpleStatement {
	// do something
}
```

其中`for`是一个关键字。

在一个`for`循环代码块中，

- `InitSimpleStatement`（初始化语句）和`PostSimpleStatement`（步尾语句）两个部分必须均为简单语句，并且`PostSimpleStatement`不能为一个变量短声明语句。
- `Condition`必须为一个结果为布尔值的表达式（它被称为条件表达式）。

所有这三个刚提到的部分都是可选的。和很多其它流行语言不同，在Go中上述三部分**不能用小括号括在一起**。

每个`for`流程控制**包括至少两个子代码块。 其中一个是隐式的，另一个是显式的**（花括号起始和终止的部分，又称循环体）。 此**显式代码块内嵌在隐式代码块之中**。

在一个`for`循环流程控制中，初始化语句（`InitSimpleStatement`）将被**率先执行，并且只会被执行一次**。

在每个循环步的开始，`Condition`条件表达式将被估值。如果估值结果为`false`，则循环立即结束；否则循环体（即显式代码块）将被执行。

在每个循环步的结尾，步尾语句（`PostSimpleStatement`）将被执行。

下面是一个使用`for`循环流程控制的例子。此程序将逐行打印出`0`到`9`十个数字。

```go
for i := 0; i < 10; i++ {
	fmt.Println(i)
}
```

在一个`for`循环流程控制中，如果`InitSimpleStatement`和`PostSimpleStatement`两部分同时被省略（可将它们视为空语句），则和它们相邻的两个分号也可被省略。 这样的形式被称为**只有条件表达式的`for`循环**。只有条件表达式的`for`循环**和很多其它语言中的`while`循环类似**。

```go
var i = 0
for ; i < 10; {
	fmt.Println(i)
	i++
}
for i < 20 {
	fmt.Println(i)
	i++
}
```

在一个`for`循环流程控制中，如果条件表达式部分被省略，则编译器视其为`true`。

```go
for i := 0; ; i++ { // 等价于：for i := 0; true; i++ {
	if i >= 10 {
		break
	}
	fmt.Println(i)
}

// 下面这几个循环是等价的。
for ; true; {
}
for true {
}
for ; ; {
}
for {
}
```

在一个`for`循环流程控制中，如果初始化语句`InitSimpleStatement`是一个变量短声明语句，则**在此语句中声明的变量被声明在外层的隐式代码块中**。 我们可以在内嵌的循环体（显式代码块）中**声明同名变量来遮挡在`InitSimpleStatement`中声明的变量**。 比如下面的代码打印出`012`，而不是`0`。

```go
for i := 0; i < 3; i++ {
	fmt.Print(i)
	i := i // 这里声明的变量i遮挡了上面声明的i。
	       // 右边的i为上面声明的循环变量i。
	i = 10 // 新声明的i被更改了。
	_ = i
}
```

一条`break`语句可以用来提前跳出包含此`break`语句的最内层`for`**循环**。 下面这段代码同样逐行打印出`0`到`9`十个数字。

```go
i := 0
for {
	if i >= 10 {
		break
	}
	fmt.Println(i)
	i++
}
```

一条`continue`语句可以被用来提前结束包含此`continue`语句的最内层`for`循环的当前**循环步**（步尾语句仍将得到执行）。 比如下面这段代码将打印出`13579`。

```go
for i := 0; i < 10; i++ {
	if i % 2 == 0 {
		continue
	}
	fmt.Print(i)
}
```

### `switch-case`流程控制代码块

`switch-case`流程控制代码块是另外一种多分支代码块。

一个`switch-case`流程控制代码块的完整形式为：

```go
switch InitSimpleStatement; CompareOperand0 {
case CompareOperandList1:
	// do something
case CompareOperandList2:
	// do something
...
case CompareOperandListN:
	// do something
default:
	// do something
}
```

其中`switch`、`case`和`default`是三个关键字。

在一个`switch-case`流程控制代码块中，

- `InitSimpleStatement`部分必须为一条简单语句，它是可选的。
- `CompareOperand0`部分必须为一个表达式（如果它没被省略的话，见下）。 此表达式的估值结果总是被视为一个类型确定值。如果它是一个类型不确定值，则它被视为类型为它的默认类型的类型确定值。 因为这个原因，此表达式不能为类型不确定的`nil`值。 `CompareOperand0`常被称为**switch表达式**。
- 每个`CompareOperandListX`部分（`X`表示`1`到`N`）必须为一个用（英文）逗号分隔开来的表达式列表。 其中每个表达式都必须能和`CompareOperand0`表达式进行比较。 每个这样的表达式常被称为**case表达式**。 如果其中case表达式是一个类型不确定值，则它必须能够自动隐式转化为对应的switch表达式的类型，否则编译将失败。

每个`case CompareOperandListX:`部分和`default:`之后形成了一个**隐式代码块**。 每个这样的隐式代码块和它对应的`case CompareOperandListX:`或者`default:`形成了一个分支。 每个分支都是可选的。

每个`switch-case`流程控制代码块中**最多只能有一个**`default`分支（默认分支）。

除了刚提到的分支代码块，每个`switch-case`流程控制至少包括其它两个代码块。 其中一个是隐式的，另一个是显式的。此显式的代码块内嵌在隐式的代码块之中。 所有的分支代码块都内嵌在此显式代码块之中（因此也间接内嵌在刚提及的隐式代码块中）。

`switch-case`代码块属于**可跳出流程控制**。 `break`可以使用在一个`switch-case`流程控制的任何分支代码块之中以提前跳出此`switch-case`流程控制。

当一个`switch-case`流程控制被执行到的时候，其中的简单语句`InitSimpleStatement`将率先被执行（只执行一次）。 随后switch表达式`CompareOperand0`将被估值（仅一次）。上面已经提到，此估值结果一定为一个类型确定值。 然后此结果值将从上到下从左到右和各个`CompareOperandListX`表达式列表中的各个case表达式逐个依次比较（使用`==`运算符）。 一旦发现某个表达式和`CompareOperand0`相等，比较过程停止并且此表达式对应的分支代码块将得到执行。 如果没有任何一个表达式和`CompareOperand0`相等，则`default`默认分支将得到执行（如果此分支存在的话）。

一个`switch-case`流程控制的例子：

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要
	switch n := rand.Intn(100); n%9 {
	case 0:
		fmt.Println(n, "is a multiple of 9.")

		// 和很多其它语言不一样，程序不会自动从一个
		// 分支代码块跳到下一个分支代码块去执行。
		// 所以，这里不需要一个break语句。
	case 1, 2, 3:
		fmt.Println(n, "mod 9 is 1, 2 or 3.")
		break // 这里的break语句可有可无的，效果
		      // 是一样的。执行不会跳到下一个分支。
	case 4, 5, 6:
		fmt.Println(n, "mod 9 is 4, 5 or 6.")
	// case 6, 7, 8:
		// 上一行可能编译不过，因为6和上一个case中的
		// 6重复了。是否能编译通过取决于具体编译器实现。
	default:
		fmt.Println(n, "mod 9 is 7 or 8.")
	}
}
```

在上例中，`rand.Intn`函数将返回一个从`0`到所传实参之间类型为`int`的随机数。

注意，编译器可能会不允许一个`switch-case`流程控制中有任何两个case表达式可以在编译时刻确定相等。 比如，当前的官方标准编译器（1.21版本）认为上例中的`case 6, 7, 8`一行是不合法的（如果此行未被注释掉）。但是其它编译器未必这么认为。 事实上，当前的官方标准编译器[允许重复的布尔case表达式在同一个`switch-case`流程控制中出现](https://github.com/golang/go/issues/28357)， 而gccgo（v8.2）允许重复的布尔和字符串类型的case表达式在同一个`switch-case`流程控制中出现。

上面的例子中的前两个`case`分支中的注释已经解释了，和很多其它语言不一样，每个分支代码块的**结尾不需要一条`break`语句就可以自动跳出当前的`switch-case`流程控制**。 **那么如何让执行从一个`case`分支代码块的结尾跳入下一个分支代码块？Go提供了一个`fallthrough`关键字来完成这个任务**。 比如，在下面的例子中，所有的分支代码块都将得到执行（从上到下）。

```go
rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要
switch n := rand.Intn(100) % 5; n {
case 0, 1, 2, 3, 4:
	fmt.Println("n =", n)
	fallthrough // 跳到下个代码块
case 5, 6, 7, 8:
	// 一个新声明的n，它只在当前分支代码快内可见。
	n := 99
	fmt.Println("n =", n) // 99
	fallthrough
default:
	// 下一行中的n和第一个分支中的n是同一个变量。
	// 它们均为switch表达式"n"。
	fmt.Println("n =", n)
}
```

请注意：

- 一条`fallthrough`语句必须为一个分支代码块中的**最后一条语句**。
- 一条`fallthrough`语句不能出现在一个`switch-case`流程控制中的最后一个分支代码块中。

比如，下面代码的几个`fallthrough`使用是不合法的。

```go
switch n := rand.Intn(100) % 5; n {
case 0, 1, 2, 3, 4:
	fmt.Println("n =", n)
	// 此整个if代码块为当前分支中的最后一条语句
	if true {
		fallthrough // error: 不是当前分支中的最后一条语句
	}
case 5, 6, 7, 8:
	n := 99
	fallthrough // error: 不是当前分支中的最后一条语句
	_ = n
default:
	fmt.Println(n)
	fallthrough // error: 不能出现在最后一个分支中
}
```

一个`switch-case`流程控制中的`InitSimpleStatement`语句和`CompareOperand0`表达式都是可选的。 如果`CompareOperand0`表达式被省略，则它被认为类型为`bool`类型的`true`值。 如果`InitSimpleStatement`语句被省略，其后的分号也可一并被省略。

上面已经提到了一个`switch-case`流程控制中的所有分支都可以被省略，所以下面的所有流程控制代码块都是合法的，它们都可以被视为空操作。

```go
switch n := 5; n {
}

switch 5 {
}

switch _ = 5; {
}

switch {
}
```

上例中的后两个`switch-case`流程控制中的`CompareOperand0`表达式都为`bool`类型的`true`值。 同理，下例中的代码将打印出`hello`。

```go
switch { // <=> switch true {
case true: fmt.Println("hello")
default: fmt.Println("bye")
}
```

Go中另外一个和其它语言的显著不同点是**`default`分支不必一定为最后一个分支**。 比如，下面的三个`switch-case`流程控制代码块是相互等价的。

```go
switch n := rand.Intn(3); n {
case 0: fmt.Println("n == 0")
case 1: fmt.Println("n == 1")
default: fmt.Println("n == 2")
}

switch n := rand.Intn(3); n {
default: fmt.Println("n == 2")
case 0: fmt.Println("n == 0")
case 1: fmt.Println("n == 1")
}

switch n := rand.Intn(3); n {
case 0: fmt.Println("n == 0")
default: fmt.Println("n == 2")
case 1: fmt.Println("n == 1")
}
```

### `goto`跳转语句和跳转标签声明

和很多其它语言一样，Go也支持`goto`跳转语句。 **在一个`goto`跳转语句中，`goto`关键字后必须跟随一个表明跳转到何处的跳转标签**。 我们**使用`LabelName:`这样的形式来声明一个名为`LabelName`的跳转标签，其中`LabelName`必须为一个标识符**。 **一个不为空标识符的跳转标签声明后必须被使用至少一次**。

**一条跳转标签声明之后必须立即跟随一条语句**。 如果此声明的跳转标签使用在一条`goto`语句中，则当此条`goto`语句被执行的时候，执行将跳转到此跳转标签声明后跟随的语句。

**一个跳转标签必须声明在一个函数体内，此跳转标签的使用可以在此跳转标签的声明之后或者之前，但是此跳转标签的使用不能出现在此跳转标签声明所处的最内层代码块之外**。

下面这个例子使用跳转标签声明和`goto`跳转语句来实现了一个循环：

```go
package main

import "fmt"

func main() {
	i := 0

Next: // 跳转标签声明
	fmt.Println(i)
	i++
	if i < 5 {
		goto Next // 跳转
	}
}
```

上面刚提到了一个跳转标签的使用不能出现在此跳转标签声明所处的最内层代码块之外，所以下面的代码片段中的跳转标签使用都是不合法的。

```go
package main

func main() {
goto Label1 // error
	{
		Label1:
		goto Label2 // error
	}
	{
		Label2:
	}
}
```

另外要注意的一点是，**如果一个跳转标签声明在某个变量的作用域内，则此跳转标签的使用不能出现在此变量的声明之前**。 关于变量的作用域，请阅读后面的文章[代码块和作用域](https://gfw.go101.org/article/blocks-and-scopes.html)

下面这个程序编译不通过：

```go
package main

import "fmt"

func main() {
	i := 0
Next:
	if i >= 5 {
		// error: goto Exit jumps over declaration of k
		goto Exit
	}

	k := i + i
	fmt.Println(k)
	i++
	goto Next
Exit: // 此标签声明在k的作用域内，但
      // 它的使用在k的作用域之外。
}
```

刚提到的这条规则[可能会在今后放宽](https://github.com/golang/go/issues/26058)。 目前，有两种途径可以对上面的程序略加修改以使之编译通过。

第一种途径是缩小变量`k`的作用域：

```go
func main() {
	i := 0
Next:
	if i >= 5 {
		goto Exit
	}
	// 创建一个显式代码块以缩小k的作用域。
	{
		k := i + i
		fmt.Println(k)
	}
	i++
	goto Next
Exit:
}
```

第二种途径是放大变量`k`的作用域：

```go
func main() {
	var k int // 将变量k的声明移到此处。
	i := 0
Next:
	if i >= 5 {
		goto Exit
	}

	k = i + i
	fmt.Println(k)
	i++
	goto Next
Exit:
}
```

### 包含跳转标签的`break`和`continue`语句

**一个`goto`语句必须包含一个跳转标签名**。 **一个`break`或者`continue`语句也可以包含一个跳转标签名，但此跳转标签名是可选的**。 **包含跳转标签名的`break`语句一般用于跳出外层的嵌套可跳出流程控制代码块**。 **包含跳转标签名的`continue`语句一般用于提前结束外层的嵌套循环流程控制代码块的当前循环步**。

**如果一条`break`语句中包含一个跳转标签名，则此跳转标签必须刚好声明在一个包含此`break`语句的可跳出流程控制代码块之前**。 我们可以把此跳转标签名看作是其后紧跟随的可跳出流程控制代码块的名称。 此`break`语句将立即结束此可跳出流程控制代码块的执行。

**如果一条`continue`语句中包含一个跳转标签名，则此跳转标签必须刚好声明在一个包含此`continue`语句的循环流程控制代码块之前**。 我们可以把此跳转标签名看作是其后紧跟随的循环流程控制代码块的名称。 此`continue`语句将提前结束此循环流程控制代码块的当前步的执行。

下面是一个使用了包含跳转标签名的`break`和`continue`语句的例子。

```go
package main

import "fmt"

func FindSmallestPrimeLargerThan(n int) int {
Outer:
	for n++; ; n++{
		for i := 2; ; i++ {
			switch {
			case i * i > n:
				break Outer
			case n % i == 0:
				continue Outer
			}
		}
	}
	return n
}

func main() {
	for i := 90; i < 100; i++ {
		n := FindSmallestPrimeLargerThan(i)
		fmt.Print("最小的比", i, "大的素数为", n)
		fmt.Println()
	}
}
```

------



## 协程、延迟函数调用、以及恐慌和恢复

将介绍协程和延迟函数调用。**协程和延迟函数调用是Go中比较独特的两个特性**。 恐慌和恢复也将在此篇文章中得到简单介绍。本文并非全面地对这些特性进行介绍，后面的其它文章会陆续补全本文的未介绍的内容。

### 协程（goroutine）

现代CPU一般含有多个核，并且一个核可能支持多线程。换句话说，现代CPU可以同时执行多条指令流水线。 为了将CPU的能力发挥到极致，我们常常需要使我们的程序支持**并发（concurrent）计算**。

**并发计算是指若干计算可能在某些时间片段内同时运行的情形**。 下面这两张图描绘了两种并发计算的场景。在此图中，A和B表示两个计算。 在第一种情形中，两个计算只在某些时间片段同时运行。 第二种情形称为**并行（parallel）计算**。在并行计算中，多个计算在任何时间点都在同时运行。**并行计算属于特殊的并发计算**。

![](https://gfw.go101.org/article/res/concurrent-vs-parallel.png)

**并发计算可能发生在同一个程序中、同一台电脑上、或者同一个网络中**。 在《Go语言101》中，我们**只谈及发生在同一个程序中的并发计算**。 **在Go编程中，协程是创建计算的唯一途径**。

**协程有时也被称为绿色线程**。**绿色线程是由程序的运行时（runtime）维护的线程**。一个绿色线程的内存开销和情景转换（context switching）时耗比一个系统线程常常小得多。 **只要内存充足，一个程序可以轻松支持上万个并发协程**。

**Go不支持创建系统线程，所以协程是一个Go程序内部唯一的并发实现方式**。

**每个Go程序启动的时候只有一个对用户可见的协程，我们称之为主协程**。 **一个协程可以开启更多其它新的协程**。**在Go中，开启一个新的协程是非常简单的。 我们只需在一个函数调用之前使用一个`go`关键字，即可让此函数调用运行在一个新的协程之中**。 **当此函数调用退出后，这个新的协程也随之结束了**。我们可以**称此函数调用为一个协程调用（或者为此协程的启动调用）**。 **一个协程调用的所有返回值（如果存在的话）必须被全部舍弃**。

在下面的例子程序中，主协程创建了两个新的协程。在此例中，`time.Duration`是一个在`time`标准库包中定义的类型。 此类型的底层类型为内置类型`int64`。 底层类型这个概念将在[下一篇文章](https://gfw.go101.org/article/type-system-overview.html#underlying-type)中介绍。

```go
package main

import (
	"log"
	"math/rand"
	"time"
)

func SayGreetings(greeting string, times int) {
	for i := 0; i < times; i++ {
		log.Println(greeting)
		d := time.Second * time.Duration(rand.Intn(5)) / 2
		time.Sleep(d) // 睡眠片刻（随机0到2.5秒）
	}
}

func main() {
	rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要
	log.SetFlags(0)
	go SayGreetings("hi!", 10)
	go SayGreetings("hello!", 10)
	time.Sleep(2 * time.Second)
}
```

非常简单！我们编写了一个并发程序！ 此程序在运行的时候在某一时刻将很可能会有三个协程并存。 运行之，可能会得到如下的结果（也可能是其它结果）：

```bash
hi!
hello!
hello!
hello!
hello!
hi!
```

**当一个程序的主协程退出后，此程序也就退出了，即使还有一些其它协程在运行**。

和前面的几篇文章不同，上面的例子程序使用了`log`标准库而不是`fmt`标准库中的`Println`函数。 原因是**`log`标准库中的打印函数是经过了同步处理的**（下一节将解释什么是并发同步），而`fmt`标准库中的打印函数却没有被同步。 如果我们在上例中使用`fmt`标准库中的`Println`函数，则**不同协程的打印可能会交织在一起**。（虽然对此例来说，交织的概率很低。）

### 并发同步（concurrency synchronization）

**不同的并发计算可能共享一些资源，其中共享内存资源最为常见**。 在一个并发程序中，常常会发生下面的情形：

- 在一个计算向一段内存**写数据的时候，另一个计算从此内存段读数据**，结果导致**读出的**数据的**完整性得不到保证**。
- 在一个计算向一段内存**写数据的时候，另一个计算也向此段内存写数据**，结果导致**被写入**的数据的**完整性得不到保证**。

这些情形被称为**数据竞争（data race）**。并发编程的一大任务就是要调度不同计算，控制它们对资源的访问时段，以**使数据竞争的情况不会发生。 此任务常称为并发同步**（或者数据同步）。Go支持几种并发同步技术，这些并发同步技术将在后面的章节中逐一介绍。

并发编程中的其它任务包括：

- 决定需要开启多少计算；
- 决定何时开启、阻塞、解除阻塞和结束哪些计算；
- 决定如何在不同的计算中分担工作负载。

上一节中这个并发程序是有缺陷的。我们本期望每个新创建的协程打印出10条问候语，但是主协程（和程序）在这20条问候语还未都打印出来的时候就退出了。 如何确保主协程在这20条问候语都打印完毕之后才退出呢？我们必须使用某种并发同步技术来达成这一目标。

Go支持几种[并发同步技术](https://gfw.go101.org/article/concurrent-synchronization-overview.html)。 其中， **[通道](https://gfw.go101.org/article/channel.html)是最独特和最常用的**。 但是，为了**简单**起见，这里我们将**使用`sync`标准库包中的`WaitGroup`来同步上面这个程序中的主协程和两个新创建的协程**。

`WaitGroup`类型有三个方法（特殊的函数，将在以后的文章中详解）：`Add`、`Done`和`Wait`。 此类型将在后面的某篇文章中详细解释，目前我们可以简单地认为：

- `Add`方法用来注册新的需要完成的任务数。
- `Done`方法用来通知某个任务已经完成了。
- 一个`Wait`方法调用将阻塞（等待）到所有任务都已经完成之后才继续执行其后的语句。

示例：

```go
package main

import (
	"log"
	"math/rand"
	"time"
	"sync"
)

var wg sync.WaitGroup

func SayGreetings(greeting string, times int) {
	for i := 0; i < times; i++ {
		log.Println(greeting)
		d := time.Second * time.Duration(rand.Intn(5)) / 2
		time.Sleep(d)
	}
	wg.Done() // 通知当前任务已经完成。
}

func main() {
	rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要
	log.SetFlags(0)
	wg.Add(2) // 注册两个新任务。
	go SayGreetings("hi!", 10)
	go SayGreetings("hello!", 10)
	wg.Wait() // 阻塞在这里，直到所有任务都已完成。
}
```

运行这个修改后的程序，我们将会发现所有的20条问候语都将在程序退出之前打印出来

### 协程的状态

从上面这个的例子，我们可以看到一个活动中的协程可以处于两个状态：**运行状态**和**阻塞状态**。**一个协程可以在这两个状态之间切换**。 比如上例中的主协程在调用`wg.Wait`方法的时候，将从运行状态切换到阻塞状态；当两个新协程完成各自的任务后，主协程将从阻塞状态切换回运行状态。

下面的图片显示了一个协程的生命周期。

![](https://gfw.go101.org/article/res/goroutine-states.png)

注意，**一个处于睡眠中的（通过调用`time.Sleep`）或者在等待系统调用返回的协程被认为是处于运行状态**，而不是阻塞状态。

**当一个新协程被创建的时候，它将自动进入运行状态**，**一个协程只能从运行状态而不能从阻塞状态退出**。 如果因为某种原因而导致**某个协程一直处于阻塞状态，则此协程将永远不会退出**。 除了极个别的应用场景，在编程时我们**应该尽量避免**出现这样的情形。

**一个处于阻塞状态的协程不会自发结束阻塞状态，它必须被另外一个协程通过某种并发同步方法来被动地结束阻塞状态**。 如果一个运行中的程序当前所有的协程都出于阻塞状态，则这些协程将永远阻塞下去，程序将被视为**死锁**了。 当一个程序死锁后，**官方标准编译器的处理是让这个程序崩溃**。

比如下面这个程序将在运行两秒钟后崩溃。

```go
package main

import (
	"sync"
	"time"
)

var wg sync.WaitGroup

func main() {
	wg.Add(1)
	go func() {
		time.Sleep(time.Second * 2)
		wg.Wait() // 阻塞在此
	}()
	wg.Wait() // 阻塞在此
}
```

它的输出：

```bash
fatal error: all goroutines are asleep - deadlock!

...
```

以后我们将学习到更多可以让一个协程进入到阻塞状态的操作。

### 协程的调度

**并非所有处于运行状态的协程都在执行**。在任一时刻，**只能最多有和逻辑CPU数目一样多的协程在同时执行**。 我们**可以调用[`runtime.NumCPU`](https://golang.google.cn/pkg/runtime/#NumCPU)函数来查询当前程序可利用的逻辑CPU数目**。 **每个逻辑CPU在同一时刻只能最多执行一个协程**。Go运行时（runtime）必须让逻辑CPU频繁地在不同的处于运行状态的协程之间切换，从而**每个处于运行状态的协程都有机会得到执行**。 这和操作系统执行系统线程的原理是一样的。

下面这张图显示了一个协程的更详细的生命周期。在此图中，**运行状态被细分成了多个子状态**。 一个处于排队子状态的协程等待着进入执行子状态。一个处于执行子状态的协程在被执行一会儿（非常短的时间片）之后将进入排队子状态。

![](https://gfw.go101.org/article/res/goroutine-schedule.png)

请注意，为了解释的简单性，在以后其它的《Go语言101》文章中，上图中所示的子状态将不会再提及。 重申一下，**睡眠和等待系统调用返回子状态被认为是运行状态**，而不是阻塞状态。

标准编译器采纳了一种被称为[M-P-G模型](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw)的算法来实现协程调度。 其中，**M**表示系统线程，**P**表示逻辑处理器（并非上述的逻辑CPU），**G**表示协程。 大多数的调度工作是通过逻辑处理器（**P**）来完成的。 逻辑处理器像一个监工一样通过将不同的处于运行状态协程（**G**）交给不同的系统线程（**M**）来执行。 **一个协程在同一时刻只能在一个系统线程中执行**。**一个执行中的协程运行片刻后将自发地脱离让出一个系统线程，从而使得其它处于等待子状态的协程得到执行机会**。

**在运行时刻，我们可以调用[`runtime.GOMAXPROCS`](https://golang.google.cn/pkg/runtime/#GOMAXPROCS)函数来获取和设置逻辑处理器的数量**。 对于官方标准编译器，在Go 1.5之前，默认初始逻辑处理器的数量为1；自从Go 1.5之后，**默认初始逻辑处理器的数量和逻辑CPU的数量一致**。 此新的默认设置在大多数情况下是最佳选择。但是对于某些文件操作十分频繁的程序，设置一个大于`runtime.NumCPU()`的`GOMAXPROCS`值可能是有好处的。

我们也可以通过设置`GOMAXPROCS`环境变量来设置一个Go程序的初始逻辑处理器数量。

### 延迟函数调用（deferred function call）

**在Go中，一个函数调用可以跟在一个`defer`关键字后面，成为一个延迟函数调用**。 此`defer`关键字和此延迟函数调用一起形成一个**延迟调用语句**。 和协程调用类似，**被延迟的函数调用的所有返回值（如果存在）必须全部被舍弃**。

**当一个延迟调用语句被执行时，其中的延迟函数调用不会立即被执行，而是被推入由当前协程维护的一个延迟调用队列（一个后进先出队列）**。 当一个函数调用返回（此时可能尚未完全退出）并进入它的[退出阶段](https://gfw.go101.org/article/function-declarations-and-calls.html#exiting-phase)后，所有在执行此函数调用的过程中已经被推入延迟调用队列的调用将被按照它们被推入的顺序逆序被弹出队列并执行。 当所有这些延迟调用执行完毕后，此函数调用也就完全退出了。

下面这个例子展示了如何使用延迟调用函数。

```go
package main

import "fmt"

func main() {
	defer fmt.Println("The third line.")
	defer fmt.Println("The second line.")
	fmt.Println("The first line.")
}
```

输出结果：

```bash
The first line.
The second line.
The third line.
```

下面是另一个略微复杂一点的使用了延迟调用的例子程序。此程序将按照自然数的顺序打印出0到9十个数字。

```go
package main

import "fmt"

func main() {
	defer fmt.Println("9")
	fmt.Println("0")
	defer fmt.Println("8")
	fmt.Println("1")
	if false {
		defer fmt.Println("not reachable")
	}
	defer func() {
		defer fmt.Println("7")
		fmt.Println("3")
		defer func() {
			fmt.Println("5")
			fmt.Println("6")
		}()
		fmt.Println("4")
	}()
	fmt.Println("2")
	return
	defer fmt.Println("not reachable")
}
```

### 一个延迟调用可以修改包含此延迟调用的最内层函数的返回值

一个例子：

```go
package main

import "fmt"

func Triple(n int) (r int) {
	defer func() {
		r += n // 修改返回值
	}()

	return n + n // <=> r = n + n; return
}

func main() {
	fmt.Println(Triple(5)) // 15
}
```

### 延迟函数调用的必要性和好处

事实上，上面的几个使用了延迟函数调用的例子中的延迟函数调用并非绝对必要。 但是**延迟调用对于下面将要介绍的恐慌/恢复特性是必要的**。

另外延迟函数调用可以帮助我们写出更整洁和更鲁棒的代码。我们可以在后面的[更多关于延迟调用](https://gfw.go101.org/article/defer-more.html)一文中读到这样的例子。

### 协程和延迟调用的实参的估值时刻

**一个延迟调用的实参是在此调用对应的延迟调用语句被执行时被估值的**。 或者说，它们是**在此延迟调用被推入延迟调用队列时被估值的**。 这些被估值的结果将在以后此延迟调用被执行的时候使用。

**一个匿名函数体内的表达式是在此函数被执行的时候才会被逐渐估值的，不管此函数是被普通调用还是延迟/协程调用**。

一个例子：

```go
package main

import "fmt"

func main() {
	func() {
		for i := 0; i < 3; i++ {
			defer fmt.Println("a:", i)
		}
	}()
	fmt.Println()
	func() {
		for i := 0; i < 3; i++ {
			defer func() {
				fmt.Println("b:", i)
			}()
		}
	}()
}
```

运行之，将得到如下结果：

```
a: 2
a: 1
a: 0

b: 3
b: 3
b: 3
```

第一个匿名函数中的循环打印出`2`、`1`和`0`这个序列，但是第二个匿名函数中的循环打印出三个`3`。 因为第一个循环中的`i`是在`fmt.Println`函数调用被推入延迟调用队列的时候估的值，而第二个循环中的`i`是在第二个匿名函数调用的退出阶段估的值（此时循环变量`i`的值已经变为`3`）。

我们可以对第二个循环略加修改（使用两种方法），使得它和第一个循环打印出相同的结果。

```go
		for i := 0; i < 3; i++ {
			defer func(i int) {
				// 此i为形参i，非实参循环变量i。
				fmt.Println("b:", i)
			}(i)
		}
```

或者

```go
		for i := 0; i < 3; i++ {
			i := i // 在下面的调用中，左i遮挡了右i。
			       // <=> var i = i
			defer func() {
				// 此i为上面的左i，非循环变量i。
				fmt.Println("b:", i)
			}()
		}
```

同样的估值时刻规则也适用于协程调用。下面这个例子程序将打印出`123 789`。

```go
package main

import "fmt"
import "time"

func main() {
	var a = 123
	go func(x int) {
		time.Sleep(time.Second)
		fmt.Println(x, a) // 123 789
	}(a)

	a = 789

	time.Sleep(2 * time.Second)
}
```

顺便说一句，使用`time.Sleep`调用来做并发同步不是一个好的方法。 如果上面这个程序运行在一个满负荷运行的电脑上，此程序可能在新启动的协程可能还未得到执行机会的时候就已经退出了。 在正式的项目中，我们应该使用[并发同步技术](https://gfw.go101.org/article/concurrent-synchronization-overview.html)一文中列出的方法来实现并发同步。

### 恐慌（panic）和恢复（recover）

**Go不支持异常抛出和捕获，而是推荐使用返回值显式返回错误**。 不过，**Go支持一套和异常抛出/捕获类似的机制。此机制称为恐慌/恢复（panic/recover）机制**。

我们**可以调用内置函数`panic`来产生一个恐慌以使当前协程进入恐慌状况**。

**进入恐慌状况是另一种使当前函数调用开始返回的途径**。 **一旦一个函数调用产生一个恐慌，此函数调用将立即进入它的退出阶段**。

**通过在一个延迟函数调用之中调用内置函数`recover`，当前协程中的一个恐慌可以被消除，从而使得当前协程重新进入正常状况**。

**如果一个协程在恐慌状况下退出，它将使整个程序崩溃**。

内置函数`panic`和`recover`的声明原型如下：

```go
func panic(v interface{})
func recover() interface{}
```

接口（interface）类型和接口值将在以后的文章[接口](https://gfw.go101.org/article/interface.html)中详解。 目前，**我们可以暂时将空接口类型`interface{}`视为很多其它语言中的`any`或者`Object`类型**。 换句话说，在一个`panic`函数调用中，我们**可以传任何实参值**。

一个**`recover`函数的返回值**为其**所恢复的恐慌**在产生时被一个`panic`函数调用**所消费的参数**。

下面这个例子展示了如何产生一个恐慌和如何消除一个恐慌。

```go
package main

import "fmt"

func main() {
	defer func() {
		fmt.Println("正常退出")
	}()
	fmt.Println("嗨！")
	defer func() {
		v := recover()
		fmt.Println("恐慌被恢复了：", v)
	}()
	panic("拜拜！") // 产生一个恐慌
	fmt.Println("执行不到这里")
}
```

它的输出结果：

```bash
嗨！
恐慌被恢复了： 拜拜！
正常退出
```

下面的例子在一个新协程里面产生了一个恐慌，并且此协程在恐慌状况下退出，所以整个程序崩溃了。

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("hi!")

	go func() {
		time.Sleep(time.Second)
		panic(123)
	}()

	for {
		time.Sleep(time.Second)
	}
}
```

运行之，输出如下：

```bash
hi!
panic: 123

goroutine 5 [running]:
...
```

Go运行时（runtime）会在若干情形下产生恐慌，比如**一个整数被0除的时候**。下面这个程序将崩溃退出。

```go
package main

func main() {
	a, b := 1, 0
	_ = a/b
}
```

它的输出：

```bash
panic: runtime error: integer divide by zero

goroutine 1 [running]:
...
```

**一般说来，恐慌用来表示正常情况下不应该发生的逻辑错误**。 如果这样的一个错误在运行时刻发生了，则它肯定是由于某个bug引起的。 另一方面，**非逻辑错误是现实中难以避免的错误，它们不应该导致恐慌。 我们必须正确地对待和处理非逻辑错误**。

更多可能由Go运行时产生的恐慌将在以后其它文章中提及。

以后，我们可以了解[一些恐慌/恢复用例](https://gfw.go101.org/article/panic-and-recover-use-cases.html)和[更多关于恐慌/恢复机制的细节](https://gfw.go101.org/article/panic-and-recover-more.html)。

### 一些致命性错误不属于恐慌

对于官方标准编译器来说，很多**致命性错误（比如栈溢出和内存不足）不能被恢复。它们一旦产生，程序将崩溃。**

------



# Go类型系统

## Go类型系统概述

将介绍Go中的各个类型种类。Go类型系统中的各种概念也将被介绍。如果不熟知这些概念，则很难精通Go编程

### 概念：基本类型（basic type）

内置基本类型已经在前面的文章[基本类型和它们的字面量表示](https://gfw.go101.org/article/basic-types-and-value-literals.html)一文中介绍过了。 为了本文的完整性，这些内置类型重新被列在这里：

- 内置字符串类型：`string`.
- 内置布尔类型：`bool`.
- 内置数值类型：
  - `int8`、`uint8`（`byte`）、`int16`、`uint16`、`int32`（`rune`）、`uint32`、`int64`、`uint64`、`int`、`uint`、`uintptr`。
  - `float32`、`float64`。
  - `complex64`、`complex128`。

注意，`byte`是`uint8`的一个内置别名，`rune`是`int32`的一个内置别名。 下面将要提到如何声明自定义的类型别名。

除了[字符串类型](https://gfw.go101.org/article/string.html)，《Go语言101》后续其它文章将不再对其它基本类型做详细讲解。

这17个内置基本类型属于预声明类型（predeclared type）。

### 概念：组合类型（composite type）

Go支持下列组合类型：

- [指针类型](https://gfw.go101.org/article/pointer.html) - 类C指针
- [结构体类型](https://gfw.go101.org/article/struct.html) - 类C结构体
- [函数类型](https://gfw.go101.org/article/function.html) - 函数类型在Go中是一种一等公民类别
- 容器类型，包括:
  - 数组类型 - 定长容器类型
  - 切片类型 - 动态长度和容量容器类型
  - 映射类型（map）- 也常称为字典类型。在标准编译器中映射是使用哈希表实现的。
- [通道类型](https://gfw.go101.org/article/channel.html) - 通道用来同步并发的协程
- [接口类型](https://gfw.go101.org/article/interface.html) - 接口在反射和多态中发挥着重要角色

无名组合类型可以用它们各自的字面表示形式来表示。 下面是一些各种不同种类的无名组合类型字面表示形式的例子（具名和无名类型将在下面解释）：

```go
// 假设T为任意一个类型，Tkey为一个支持比较的类型。

*T         // 一个指针类型
[5]T       // 一个元素类型为T、元素个数为5的数组类型
[]T        // 一个元素类型为T的切片类型
map[Tkey]T // 一个键值类型为Tkey、元素类型为T的映射类型

// 一个结构体类型
struct {
	name string
	age  int
}

// 一个函数类型
func(int) (bool, string)

// 一个接口类型
interface {
	Method0(string) int
	Method1() (int, bool)
}

// 几个通道类型
chan T
chan<- T
<-chan T
```

[支持和不支持比较的类型](https://gfw.go101.org/article/type-system-overview.html#types-not-support-comparison)将在下面介绍。

### 事实：类型的种类

每种上面提到的基本类型和组合类型都对应着一个类型种类（kind）。除了这些种类，今后将要介绍的非类型安全指针类型属于另外一个新的类型种类。

所以，目前（Go 1.21），Go有26个类型种类。

### 语法：类型定义（type definition declaration）

*（**类型定义**又称类型定义声明。在Go 1.9之前，类型定义被称为类型声明并且是唯一的一种类型声明形式。 但是自从Go 1.9，类型定义变成了两种类型声明形式之一。另一种新的类型声明形式为后面的一节中将要介绍的类型别名声明。）*

在Go中，我们可以用如下形式来定义新的类型。在此语法中，`type`为一个关键字。

```go
// 定义单个类型。
type NewTypeName SourceType

// 定义多个类型（将多个类型描述合并在一个声明中）。
type (
	NewTypeName1 SourceType1
	NewTypeName2 SourceType2
)
```

新的类型名必须为标识符。但是请注意：包级类型（以及下一节将要介绍的类型别名）的名称不能为[`init`](https://gfw.go101.org/article/packages-and-imports.html#init)。

上例中的第二个类型声明中包含两个类型描述（type specification）。 如果一个类型声明包含多于一个的类型描述，这些类型描述必须用一对小括号`()`括起来。

每个类型描述创建了一个全新的定义类型（defined type）。

注意：

- 一个新定义的类型和它的源类型为两个不同的类型。
- 在两个不同的类型定义中所定义的两个类型肯定是两个不同的类型。
- 一个新定义的类型和它的源类型的底层类型（将在下面介绍）一致并且它们的值可以相互显式转换。
- 类型定义可以出现在函数体内。

一些类型定义的例子：

```go
// 下面这些新定义的类型和它们的源类型都是基本类型。
// 它们的源类型均为预声明类型。
type (
	MyInt int
	Age   int
	Text  string
)

// 下面这些新定义的类型和它们的源类型都是组合类型。
// 它们的源类型均为无名类型（见下下节）。
type IntPtr *int
type Book struct{author, title string; pages int}
type Convert func(in0 int, in1 bool)(out0 int, out1 string)
type StringArray [5]string
type StringSlice []string

func f() {
	// 这三个新定义的类型名称只能在此函数内使用。
	type PersonAge map[string]int
	type MessageQueue chan string
	type Reader interface{Read([]byte) int}
}
```

请注意：从Go 1.9到Go 1.17，Go白皮书曾经把预声明类型视为定义类型。 但是从Go 1.18开始，Go白皮书明确说明预声明类型不再属于定义类型。

### 概念：自定义泛型类型和实例化类型（generic type and instantiated types）

从Go 1.18开始，Go开始支持自定义泛型类型（和函数）。 一个泛型类型必须被实例化才能被用做值类型。

一个泛型类型是一个定义类型；它的实例化类型为具名类型。具名类型将在下一节解释。

自定义泛型中的另外两个重要的概念为类型约束（constarint）和类型参数（type parameter）。

本书不详细阐述自定义泛型。关于如何声明和使用泛型类型和函数，请阅读[《Go自定义泛型101》](https://gfw.go101.org/generics/101.html)。

### 概念：具名类型和无名类型（named type and unnamed type）

在Go 1.9之前，**具名类型**这个术语在Go白皮书中是精确定义的。 在那时，一个具名类型被定义为一个可以用标识符表示的类型。 随着在Go 1.9中引入了自定义类型别名（见下一节），**具名类型**这个术语被从白皮书中删除了；取而代之的是**定义类型**。 随着Go 1.18中引入了自定义泛型，**具名类型**这个术语又被重新加回到白皮书。

一个具名类型可能为

- 一个预声明类型；
- 一个定义（非自定义泛型）类型；
- 一个（泛型类型的）实例化类型；
- 一个类型参数类型（使用在自定义泛型中）。

其它类型称为无名类型。一个无名类型肯定是一个组合类型（反之则未必）。

### 语法：类型别名声明（type alias declaration）

从Go 1.9开始，我们可以使用下面的语法来声明自定义类型别名。此语法和类型定义类似，但是请注意每个类型描述中多了一个等号`=`。

```go
type (
	Name = string
	Age  = int
)

type table = map[string]int
type Table = map[Name]Age
```

类型别名也必须为标识符。同样地，类型别名可以被声明在函数体内。

在上面的类型别名声明的例子中，`Name`是内置类型`string`的一个别名，它们表示同一个类型。 同样的关系对下面的几对类型表示也成立：

- 别名`Age`和内置类型`int`。
- 别名`table`和映射类型`map[string]int`。
- 别名`Table`和映射类型`map[Name]Age`。

事实上，文字表示形式`map[string]int`和`map[Name]Age`也表示同一类型。 所以，`table`和`Table`一样表示同一个类型。

注意：尽管一个类型别名有一个名字，但是它可能表示一个无名类型。 比如，`table`和`Table`这两个别名都表示同一个无名类型`map[string]int`。

### 概念：底层类型（underlying type）

在Go中，每个类型都有一个底层类型。规则：

- 一个内置类型的底层类型为它自己。
- `unsafe`标准库包中定义的`Pointer`类型的底层类型是它自己。 （至少我们可以认为是这样。事实上，关于`unsafe.Pointer`类型的底层类型，官方文档中并没有清晰的说明。我们也可以认为`unsafe.Pointer`类型的底层类型为`*T`，其中`T`表示一个任意类型。） `unsafe.Pointer`也被视为一个内置类型。
- 一个无名类型（必为一个组合类型）的底层类型为它自己。
- 在一个类型声明中，新声明的类型和源类型共享底层类型。

一个例子：

```go
// 这四个类型的底层类型均为内置类型int。
type (
	MyInt int
	Age   MyInt
)

// 下面这三个新声明的类型的底层类型各不相同。
type (
	IntSlice   []int   // 底层类型为[]int
	MyIntSlice []MyInt // 底层类型为[]MyInt
	AgeSlice   []Age   // 底层类型为[]Age
)

// 类型[]Age、Ages和AgeSlice的底层类型均为[]Age。
type Ages AgeSlice
```



如何溯源一个声明的类型的底层类型？规则很简单，在溯源过程中，当遇到一个内置类型或者无名类型时，溯源结束。 以上面这几个声明的类型为例，下面是它们的底层类型的溯源过程：

```
MyInt → int
Age → MyInt → int
IntSlice → []int
MyIntSlice → []MyInt → []int
AgeSlice → []Age → []MyInt → []int
Ages → AgeSlice → []Age → []MyInt → []int
```



在Go中，

- 底层类型为内置类型`bool`的类型称为**布尔类型**；
- 底层类型为任一内置整数类型的类型称为**整数类型**；
- 底层类型为内置类型`float32`或者`float64`的类型称为**浮点数类型**；
- 底层类型为内置类型`complex64`或`complex128`的类型称为**复数类型**；
- 整数类型、浮点数类型和复数类型统称为**数字值类型**；
- 底层类型为内置类型`string`的类型称为**字符串类型**。

底层类型这个概念在[类型转换、赋值和比较规则](https://gfw.go101.org/article/value-conversions-assignments-and-comparisons.html)中扮演着重要角色。

### 概念：值（value）

一个类型的一个实例称为此类型的一个值。一个类型可以有很多不同的值，其中一个为它的零值。 同一类型的不同值共享很多相同的属性。

每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。 预声明的标识符`nil`可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示。 我们以后可以在[Go中的nil](https://gfw.go101.org/article/nil.html)一文中了解到关于`nil`的各种事实。

在源代码中，值可以呈现为若干种形式，包括[字面量](https://gfw.go101.org/article/basic-types-and-value-literals.html)、[具名常量](https://gfw.go101.org/article/constants-and-variables.html#constant)、[变量](https://gfw.go101.org/article/constants-and-variables.html#variable)和[表达式](https://gfw.go101.org/article/expressions-and-statements.html)。前三种形式可以看作是最后一种形式的特例。

值分为[类型确定的和类型不确定的](https://gfw.go101.org/article/constants-and-variables.html#untyped-value)。

基本类型和它们的字面量表示已经在[前面一文](https://gfw.go101.org/article/basic-types-and-value-literals.html)中介绍过了。 另外，Go中还有另外两种的字面量表示形式：函数字面量表示形式和组合字面量表示形式（composite literal）。

函数字面量表示形式用来表示函数值。事实上，一个[函数声明](https://gfw.go101.org/article/function-declarations-and-calls.html#declaration)是由一个标识符（函数名）和一个函数字面量表示形式组成。

组合字面量表示形式用来表示结构体类型值和容器类型（数组、切片和映射）值。 详见[结构体](https://gfw.go101.org/article/struct.html)和[容器类型](https://gfw.go101.org/article/container.html)两文。

指针类型、通道类型和接口类型的值没有字面量表示形式。



### 概念：值部（value part）

在运行时刻，很多值是存储在内存的。每个这样的值都有一个直接部分，但是有一些值还可能有一个或多个间接部分。每个值部分在内存中都占据一段连续空间。 通过[安全](https://gfw.go101.org/article/pointer.html)或者[非安全](https://gfw.go101.org/article/unsafe.html)指针，一个值的间接部分被此值的直接部分所引用。

[**值部**](https://gfw.go101.org/article/value-part.html)这个术语并没有在Go白皮书中定义。它仅使用在《Go语言101》这本书中，用来简化一些解释并帮助Go程序员更好地理解Go类型和值。



### 概念：值尺寸（value size）

一个值存储在内存中是要占据一定的空间的。此空间的大小称为此值的尺寸。值尺寸是用字节数来衡量的。 在Go中，当我们谈及一个值的尺寸，如果没有特殊说明，我们一般是指此值的直接部分的尺寸。 某个特定类别的所有类型的值的尺寸都是一样的。因为这个原因，我们也常将一个值的尺寸说成是它的类型的尺寸（或值尺寸）。

我们可以用`unsafe`标准库包中的`Sizeof`函数来取得任何一个值的尺寸。

Go白皮书没有规定非数值类型值的尺寸。对数值类型值的尺寸的要求已经在[基本类型和它们的字面量表示](https://gfw.go101.org/article/basic-types-and-value-literals.html)一文中提及了。



### 概念：指针类型的基类型（base type）

如果一个指针类型的底层类型表示为`*T`，则此指针类型的基类型为`T`所表示的类型。

[指针类](https://gfw.go101.org/article/pointer.html)一文详细解释了指针类类型和指针值。

### 概念：结构体类型的字段（field）

一个结构体类型由若干成员变量组成。每个这样的成员变量称为此结构体的一个字段。 比如，下面这个结构体类型含有三个字段：`author`、`title`和`pages`。

```go
struct {
	author string
	title  string
	pages  int
}
```

[结构体](https://gfw.go101.org/article/struct.html)一文详细解释了结构体类型和结构体值。

### 概念：函数类型的签名（signature）

一个函数和其类型的签名由此函数的输入参数和返回结果的类型列表组成。 函数名称和函数体不属于函数签名的构成部分。

[函数](https://gfw.go101.org/article/function.html)一文详细解释了函数类型和函数值。

### 概念：类型的方法（method）和方法集（method set）

在Go中，我们可以给满足某些条件的类型声明[方法](https://gfw.go101.org/article/method.html)。方法也常被称为成员函数。 一个类型的所有方法组成了此类型的方法集。

### 概念：接口类型的动态类型和动态值

接口类型的值称为接口值。一个接口值可以包裹装载一个非接口值。包裹在一个接口值中的非接口值称为此接口值的动态值。此动态值的类型称为此接口值的动态类型。 一个什么也没包裹的接口值为一个零值接口值。零值接口值的动态值和动态类型均为不存在。

一个接口类型可以指定若干个（可以是零个）方法，这些方法形成了此接口类型的方法集。

如果一个类型（可以是接口或者非接口类型）的方法集是一个接口类型的方法集的超集，则我们说此类型[实现](https://gfw.go101.org/article/interface.html#implementation)了此接口类型。

[接口](https://gfw.go101.org/article/interface.html)一文详细解释了接口类型和接口值。



### 概念：一个值的具体类型（concrete type）和具体值（concrete value）

对于一个（类型确定的）非接口值，它的具体类型就是它的类型，它的具体值就是它自己。

一个零值接口值没有具体类型和具体值。 对于一个非零值接口值，它的具体类型和具体值就是它的动态类型和动态值。

### 概念：容器类型

数组、切片和映射是Go中的三种正式意义上的内置容器类型。

有时候，字符串和通道类型也可以被非正式地看作是容器类型。

（正式和非正式的）容器类型的每个值都有一个长度属性。

[数组、切片和映射](https://gfw.go101.org/article/container.html)一文详细解释了各种正式容器类型和它们的值。

### 概念：映射类型的键值（key）类型

如果一个映射类型的底层类型表示为`map[Tkey]T`，则此映射类型的键值类型为`Tkey`。 `Tkey`必须为一个可比较类型（见下）。

### 概念：容器类型的元素（element）类型

存储在一个容器值中的所有元素的类型必须为同一个类型。此同一类型称为此容器值的（容器）类型的元素类型。

- 如果一个数组类型的底层类型表示为`[N]T`，则此数组类型的元素类型为`T`所表示的类型。
- 如果一个切片类型的底层类型表示为`[]T`，则此切片类型的元素类型为`T`所表示的类型。
- 如果一个映射类型的底层类型表示为`map[Tkey]T`，则此映射类型的元素类型为`T`所表示的类型。
- 如果一个通道类型的底层类型表示为`chan T`、`chan<- T`或者`<-chan T`，则此通道类型的元素类型为`T`所表示的类型。
- 一个字符串类型的元素类型总是内置类型`byte`（亦即`uint8`）。

### 概念：通道类型的方向

一个通道值可以被看作是先入先出（first-in-first-out，FIFO）队列。一个通道值可能是可读可写的、只读的（receive-only）或者只写的（send-only）。

- 一个可读可写的通道值也称为一个双向通道。 一个双向通道类型的底层类型可以被表示为`chan T`。
- 我们只能向一个只写的通道值发送数据，而不能从其中接收数据。 只写通道类型的底层类型可以被表示为`chan<- T`。
- 我们只能从一个只读的通道值接收数据，而不能向其发送数据。 只读通道类型的底层类型可以被表示为`<-chan T`。

[通道](https://gfw.go101.org/article/channel.html)一文详细解释了通道类型和通道值。



### 事实：可比较类型和不可比较类型

目前（Go 1.21），下面这些类型的值不支持（使用`==`和`!=`运算标识符）比较。这些类型称为不可比较类型。

- 切片类型
- 映射类型
- 函数类型
- 任何包含有不可比较类型的字段的结构体类型和任何元素类型为不可比较类型的数组类型。

其它类型称为可比较类型。

映射类型的键值类型必须为可比较类型。

我们可以在[类型转换、赋值和值比较规则大全](https://gfw.go101.org/article/value-conversions-assignments-and-comparisons.html#comparison-rules)一文中了解到更详细的比较规则。

### 事实：Go对面向对象编程（object-oriented programming）的支持

Go并不全面支持面向对象编程，但是Go确实支持一些面向对象编程的元素。请阅读以下几篇文章以获取详细信息：

- [方法](https://gfw.go101.org/article/method.html)
- [实现](https://gfw.go101.org/article/interface.html#implementation)
- [类型内嵌](https://gfw.go101.org/article/type-embedding.html)

### 事实：Go对泛型（generics）的支持

在1.18版本以前，Go中泛型支持只局限在内置类型和内置函数中。 从1.18版本开始，Go也支持自定义泛型。 请阅读[泛型](https://gfw.go101.org/article/generic.html)一文来了解内置泛型和[《Go自定义泛型101》](https://gfw.go101.org/generics/101.html)一书来了解自定义泛型。

------



## 指针

虽然Go吸收融合了很多其语言中的各种特性，但是Go主要被归入C语言家族。其中一个重要的原因就是Go和C一样，也支持指针。 当然Go中的指针相比C指针有很多限制。本篇文章将介绍指针相关的各种概念和Go指针相关的各种细节。

### 内存地址

在编程中，一个内存地址用来定位一段内存。

通常地，一个内存地址用一个操作系统原生字（native word）来存储。 一个原生字在32位操作系统上占4个字节，在64位操作系统上占8个字节。 所以，32位操作系统上的理论最大支持内存容量为4GB（1GB == 230字节），64位操作系统上的理论最大支持内存容量为264Byte，即16EB（EB：艾字节，1EB == 1024PB, 1PB == 1024TB, 1TB == 1024GB）。

内存地址的字面形式常用整数的十六进制字面量来表示，比如`0x1234CDEF`。

以后我们常简称内存地址为地址。

### 值的地址

一个值的地址是指此值的直接部分占据的内存的起始地址。在Go中，每个值都包含一个直接部分，但有些值可能还包含一个或多个间接部分，[下下章](https://gfw.go101.org/article/value-part.html)将对此详述。

### 什么是指针？

指针是Go中的一种类型分类（kind）。 一个指针可以存储一个内存地址；从地址通常为另外一个值的地址。

和C指针不一样，为了安全起见，Go指针有很多限制，详见下面的章节。

### 指针类型和值

在Go中，一个无名指针类型的字面形式为`*T`，其中`T`为一个任意类型。类型`T`称为指针类型`*T`的基类型（base type）。 如果一个指针类型的基类型为`T`，则我们可以称此指针类型为一个`T`指针类型。

虽然我们可以声明具名指针类型，但是一般不推荐这么做，因为无名指针类型的可读性更高。

如果一个指针类型的[底层类型](https://gfw.go101.org/article/type-system-overview.html#underlying-type)是`*T`，则它的基类型为`T`。

如果两个无名指针类型的基类型为同一类型，则这两个无名指针类型亦为同一类型。

一些指针类型的例子：

```go
*int  // 一个基类型为int的无名指针类型。
**int // 一个多级无名指针类型，它的基类型为*int。

type Ptr *int // Ptr是一个具名指针类型，它的基类型为int。
type PP *Ptr  // PP是一个具名多级指针类型，它的基类型为Ptr。
```



指针类型的零值的字面量使用预声明的`nil`来表示。一个nil指针（常称为空指针）中不存储任何地址。

如果一个指针类型的基类型为`T`，则此指针类型的值只能存储类型为`T`的值的地址。



### 关于引用（reference）这个术语

在《Go语言101》中，术语“引用”暗示着一个关系。比如，如果一个指针中存储着另外一个值的地址，则我们可以说此指针值引用着另外一个值；同时另外一个值当前至少有一个引用。 本书对此术语的使用和Go白皮书是一致的。

当一个指针引用着另外一个值，我们也常说此指针指向另外一个值。

### 如何获取一个指针值？

有两种方式来得到一个指针值：

1. 我们可以用内置函数`new`来为任何类型的值开辟一块内存并将此内存块的起始地址做为此值的地址返回。 假设`T`是任一类型，则函数调用`new(T)`返回一个类型为`*T`的指针值。 存储在返回指针值所表示的地址处的值（可被看作是一个匿名变量）为`T`的零值。
2. 我们也可以使用前置取地址操作符`&`来获取一个可寻址的值的地址。 对于一个类型为`T`的可寻址的值`t`，我们可以用`&t`来取得它的地址。`&t`的类型为`*T`。



一般说来，一个可寻址的值是指被放置在内存中某固定位置处的一个值（但放置在某固定位置处的一个值并非一定是可寻址的）。 目前，我们只需知道所有变量都是可以寻址的；但是所有常量、函数返回值和强制转换结果都是不可寻址的。 当一个变量被声明的时候，Go运行时将为此变量开辟一段内存。此内存的起始地址即为此变量的地址。

更多可被（或不可被）寻址的值将在以后的文章中逐渐提及。 如果你已经对Go比较熟悉，你可以阅读[此条总结](https://gfw.go101.org/article/summaries.html#not-addressable)来了解在Go中哪些值可以或不可以被寻址。

下一节中的例子将展示如何获取一些值的地址。

### 指针（地址）解引用

我们可以使用前置解引用操作符`*`来访问存储在一个指针所表示的地址处的值（即此指针所引用着的值）。 比如，对于基类型为`T`的指针类型的一个指针值`p`，我们可以用`*p`来表示地址`p`处的值。 此值的类型为`T`。`*p`称为指针`p`的解引用。解引用是取地址的逆过程。

解引用一个nil指针将产生一个[恐慌](https://gfw.go101.org/article/control-flows-more.html#panic-recover)。

下面这个例子展示了如何取地址和解引用。

```go
package main

import "fmt"

func main() {
	p0 := new(int)   // p0指向一个int类型的零值
	fmt.Println(p0)  // （打印出一个十六进制形式的地址）
	fmt.Println(*p0) // 0

	x := *p0              // x是p0所引用的值的一个复制。
	p1, p2 := &x, &x      // p1和p2中都存储着x的地址。
	                      // x、*p1和*p2表示着同一个int值。
	fmt.Println(p1 == p2) // true
	fmt.Println(p0 == p1) // false
	p3 := &*p0            // <=> p3 := &(*p0)
	                      // <=> p3 := p0
	                      // p3和p0中存储的地址是一样的。
	fmt.Println(p0 == p3) // true
	*p0, *p1 = 123, 789
	fmt.Println(*p2, x, *p3) // 789 789 123

	fmt.Printf("%T, %T \n", *p0, x) // int, int
	fmt.Printf("%T, %T \n", p0, p1) // *int, *int
}
```



下面这张图描绘了上面这个例子中各个值之间的关系。

![指针值](https://gfw.go101.org/article/res/pointer.png)



### 我们为什么需要指针？

让我们先看一个例子：

```go
package main

import "fmt"

func double(x int) {
	x += x
}

func main() {
	var a = 3
	double(a)
	fmt.Println(a) // 3
}
```

我们本期望上例中的`double`函数将变量`a`的值放大为原来的两倍，但是事实证明我们的期望没有得到实现。 为什么呢？因为在Go中，所有的赋值（包括函数调用传参）过程都是一个值复制过程。 所以在上面的`double`函数体内修改的是变量`a`的一个副本，而没有修改变量`a`本身。

当然我们可以让`double`函数返回输入参数的两倍数，但是此方法并非适用于所有场合。 下面这个例子通过将输入参数的类型改为一个指针类型来达到同样的目的。

```go
package main

import "fmt"

func double(x *int) {
	*x += *x
	x = nil // 此行仅为讲解目的
}

func main() {
	var a = 3
	double(&a)
	fmt.Println(a) // 6
	p := &a
	double(p)
	fmt.Println(a, p == nil) // 12 false
}
```

从上例可以看出，通过将`double`函数的输入参数的类型改为`*int`，传入的实参`&a`和它在此函数体内的一个副本`x`都引用着变量`a`。 所以对`*x`的修改等价于对`*p`（也就是变量`a`）的修改。 换句话说，新版本的`double`函数内的操作可以反映到此函数外了。

当然，在此函数体内对传入的指针实参的修改`x = nil`依旧不能反映到函数外，因为此修改发生在此指针的一个副本上。 所以在`double`函数调用之后，局部变量`p`的值并没有被修改为`nil`。

简而言之，指针提供了一种间接的途径来访问和修改一些值。 虽然很多语言中没有指针这个概念，但是指针被隐藏其它概念之中。

### 在Go中返回一个局部变量的地址是安全的

和C不一样，Go是支持垃圾回收的，所以一个函数返回其内声明的局部变量的地址是绝对安全的。比如：

```go
func newInt() *int {
	a := 3
	return &a
}
```



### Go指针的一些限制

为了安全起见，Go指针在使用上相对于C指针有很多限制。 通过施加这些限制，Go指针保留了C指针的好处，同时也避免了C指针的危险性。

#### Go指针不支持算术运算

在Go中，指针是不能参与算术运算的。比如，对于一个指针`p`， 运算`p++`和`p-2`都是非法的。

如果`p`为一个指向一个数值类型值的指针，`*p++`将被编译器认为是合法的并且等价于`(*p)++`。 换句话说，解引用操作符`*`的优先级都高于自增`++`和自减`--`操作符。

例子：

```go
package main

import "fmt"

func main() {
	a := int64(5)
	p := &a

	// 下面这两行编译不通过。
	/*
	p++
	p = (&a) + 8
	*/

	*p++
	fmt.Println(*p, a)   // 6 6
	fmt.Println(p == &a) // true

	*&a++
	*&*&a++
	**&p++
	*&*p++
	fmt.Println(*p, a) // 10 10
}
```

#### 一个指针类型的值不能被随意转换为另一个指针类型

在Go中，只有如下某个条件被满足的情况下，一个类型为`T1`的指针值才能被显式转换为另一个指针类型`T2`：

1. 类型`T1`和`T2`的底层类型必须一致（忽略结构体字段的标签）。 特别地，如果类型`T1`和`T2`中只要有一个是[无名类型](https://gfw.go101.org/article/type-system-overview.html#named-type)并且它们的底层类型一致（考虑结构体字段的标签），则此转换可以是隐式的。 关于结构体，请参阅[下一篇文章](https://gfw.go101.org/article/struct.html)。
2. 类型`T1`和`T2`都为无名类型并且它们的基类型的底层类型一致（忽略结构体字段的标签）。

比如，

```go
type MyInt int64
type Ta    *int64
type Tb    *MyInt
```

对于上面所示的这些指针类型，下面的事实成立：

1. 类型`*int64`的值可以被隐式转换到类型`Ta`，反之亦然（因为它们的底层类型均为`*int64`）。
2. 类型 `*MyInt`的值可以被隐式转换到类型`Tb`，反之亦然（因为它们的底层类型均为`*MyInt`）。
3. 类型`*MyInt`的值可以被显式转换为类型`*int64`，反之亦然（因为它们都是无名的并且它们的基类型的底层类型均为`int64`）。
4. 类型`Ta`的值不能直接被转换为类型`Tb`，即使是显式转换也是不行的。 但是，通过上述三条事实，通过三层显式转换`Tb((*MyInt)((*int64)(ta)))`，一个类型为`Ta`的值`ta`可以被间接地转换为类型`Tb`。

这些指针类型的任何值都无法被转换到类型`*uint64`。

#### 一个指针值不能和其它任一指针类型的值进行比较

Go指针值是支持（使用比较运算符`==`和`!=`）比较的。 但是，两个指针只有在下列任一条件被满足的时候才可以比较：

1. 这两个指针的类型相同。
2. 其中一个指针可以被隐式转换为另一个指针的类型。换句话说，这两个指针的类型的底层类型必须一致并且至少其中一个指针类型为无名的（考虑结构体字段的标签）。
3. 其中一个并且只有一个指针用类型不确定的`nil`标识符表示。

例子：

```go
package main

func main() {
	type MyInt int64
	type Ta    *int64
	type Tb    *MyInt

	// 4个不同类型的指针：
	var pa0 Ta
	var pa1 *int64
	var pb0 Tb
	var pb1 *MyInt

	// 下面这6行编译没问题。它们的比较结果都为true。
	_ = pa0 == pa1
	_ = pb0 == pb1
	_ = pa0 == nil
	_ = pa1 == nil
	_ = pb0 == nil
	_ = pb1 == nil

	// 下面这三行编译不通过。
	/*
	_ = pa0 == pb0
	_ = pa1 == pb1
	_ = pa0 == Tb(nil)
	*/
}
```



#### 一个指针值不能被赋值给其它任意类型的指针值

一个指针值可以被赋值给另一个指针值的条件和这两个指针值可以比较的条件（见上一小节）是一致的。

### 上述Go指针的限制是可以被打破的

[`unsafe`标准库包](https://gfw.go101.org/article/unsafe.html)中提供的非类型安全指针（`unsafe.Pointer`）机制可以被用来打破上述Go指针的安全限制。 `unsafe.Pointer`类型类似于C语言中的`void*`。 但是，通常地，非类型安全指针机制不推荐在Go日常编程中使用。

------



## 结构体

和C语言类似，Go也支持结构体类型。此篇文章将介绍Go中的结构体类型和结构体值做一个详细的解释。

### 结构体类型和结构体字面量表示形式

每个无名结构体类型的字面形式均由`struct`关键字开头，后面跟着用一对大括号`{}`，其中包裹着的一系列字段（field）声明。 一般来说，每个字段声明由一个字段名和字段类型组成。一个结构体类型的字段数目可以为0。下面是一个无名结构体类型的字面形式：

```go
struct {
	title  string
	author string
	pages  int
}
```

上面这个结构体类型含有三个字段。前两个字段（`title`和`author`）的类型均为`string`。 最后一个字段`pages`的类型为`int`。

有时字段也称为成员变量。

相邻的同类型字段可以声明在一起。比如上面这个类型也可表示成下面这样：

```go
struct {
	title, author string
	pages         int
}
```

一个结构体类型的尺寸为它的所有字段的（类型）尺寸之和加上一些填充字节的数目。 常常地，编译器（和运行时）会在一个结构体值的两个相邻字段之间填充一些字节来保证一些字段的地址总是某个整数的倍数。 我们可以在后面的[内存布局](https://gfw.go101.org/article/memory-layout.html)一文中了解到字节填充（padding）和内存地址对齐（memory address alignment）。

一个零字段结构体的尺寸为零。

每个结构体字段在它的声明中可以被指定一个标签（tag）。从语法上讲，字段标签可以是任意字符串，它们是可选的，默认为空字符串。 但在实践中，它们应该被表示成用空格分隔的键值对形式，并且每个标签尽量使用直白字面形式（``...``）表示，而键值对中的值使用解释型字面形式（`"..."`）表示。 比如下例：

```go
struct {
	Title  string `json:"title" myfmt:"s1"`
	Author string `json:"author,omitempty" myfmt:"s2"`
	Pages  int    `json:"pages,omitempty" myfmt:"n1"`
	X, Y   bool   `myfmt:"b1"`
}
```

注意：上例中的`X`和`Y`字段的标签是一样的（尽管在实践中基本上从不会这样使用字段标签）。

我们可以使用[反射](https://gfw.go101.org/article/reflection.html#struct-field-tag)来检视字段的标签信息。

每个字段标签的目的取决于具体应用。上面这个例子中的字段标签用来帮助`encoding/json`标准库包来将上面这个结构体类型的某个值编码成JSON数据或者从一份JSON数据解码到上面这个结构体类型的某个值中。在编码和解码过程中，`encoding/json`标准库包中的函数将只考虑导出的结构体字段。这是为什么上面这个结构体的字段均为导出的。

把字段标签当成字段注释来使用不是一个好主意。

和C语言不一样，Go结构体不支持字段联合（union）。

上面的例子中展示的结构体类型都是无名的。在实践中，具名结构体类型用得更流行。

只有导出字段可以被使用在其它代码包中。非导出字段类以于很多其它语言中的私有或者保护型的成员变量。

一个结构体类型中的字段标签和字段的声明顺序对此结构体类型的身份识别很重要。 如果两个无名结构体类型的各个对应字段声明都相同（按照它们的出现顺序），则此两个无名结构体类型是等同的。 两个字段声明只有在它们的名称、类型和标签都等同的情况下才相同。 注意：**两个声明在不同的代码包中的非导出字段将总被认为是不同的字段。**

一个结构体类型不能（直接或者间接）含有一个类型为此结构类型的字段。

### 结构体字面量表示形式和结构体值的使用

在Go中，语法形式`T{...}`称为一个组合字面量形式（composite literal），其中`T`必须为一个类型名或者类型字面形式。 组合字面量形式可以用来表示结构体类型和内置容器类型（将在后面的文章中介绍）的值。

注意：组合字面量`T{...}`是一个类型确定值，它的类型为`T`。

假设`S`是一个结构体类型并且它的底层类型为`struct{x int; y bool}`，`S`的零值可以表示成下面所示的组合字面量两种变种形式：

1. `S{0, false}`。在此变种形式中，所有的字段名称均不出现，但每个字段的值必须指定，并且每个字段的出现顺序和它们的声明顺序必须一致。
2. `S{x: 0, y: false}`、`S{y: false, x: 0}`、`S{x: 0}`、`S{y: false}`和`S{}`。 在此变种形式中，字段的名称和值必须成对出现，但是每个字段都不是必须出现的，并且字段的出现顺序并不重要。 没有出现的字段的值被编译器认为是它们各自类型的零值。`S{}`是最常用的类型`S`的零值的表示形式。

如果`S`是声明在另一个代码包中的一个结构体类型，则推荐使用上面所示的第二种变种形式来表示它的值。 因为另一个代码包的维护者今后可能会在此结构体中添加新的字段，从而导致当前使用的第一种变种形式在今后可能编译不通过。

当然，上面所示的结构体值的组合字面量也可以用来表示结构体类型的非零值。

对于类型`S`的一个值`v`，我们可以用`v.x`和`v.y`来表示它的字段。 `v.x`（或`v.y`）这种形式称为一个选择器（selector）。其中的`v`称为此选择器的属主。 今后，我们称一个选择器中的句点`.`为属性选择操作符。

一个例子：

```go
package main

import (
	"fmt"
)

type Book struct {
	title, author string
	pages         int
}

func main() {
	book := Book{"Go语言101", "老貘", 256}
	fmt.Println(book) // {Go语言101 老貘 256}

	// 使用带字段名的组合字面量来表示结构体值。
	book = Book{author: "老貘", pages: 256, title: "Go语言101"}
	// title和author字段的值都为空字符串""，pages字段的值为0。
	book = Book{}
	// title字段空字符串""，pages字段为0。
	book = Book{author: "老貘"}

	// 使用选择器来访问和修改字段值。
	var book2 Book // <=> book2 := Book{}
	book2.author = "Tapir"
	book2.pages = 300
	fmt.Println(book2.pages) // 300
}
```



如果一个组合字面量中最后一项和结尾的`}`处于同一行，则此项后的逗号`,`是可选的；否则此逗号不可省略。 我们可以阅读后面的[Go代码断行规则](https://gfw.go101.org/article/line-break-rules.html)一文了解更多断行规则。

```go
var _ = Book {
	author: "老貘",
	pages: 256,
	title: "Go语言101", // 这里行尾的逗号不可省略
}

// 下行}前的逗号可以省略。
var _ = Book{author: "老貘", pages: 256, title: "Go语言101",}
```



### 关于结构体值的赋值

当一个（源）结构体值被赋值给另外一个（目标）结构体值时，其效果和逐个将源结构体值的各个字段赋值给目标结构体值的各个对应字段的效果是一样的。

```go
func f() {
	book1 := Book{pages: 300}
	book2 := Book{"Go语言101", "老貘", 256}

	book2 = book1
	// 上面这行和下面这三行是等价的。
	book2.title = book1.title
	book2.author = book1.author
	book2.pages = book1.pages
}
```

如果两个结构体值的类型不同，则只有在它们的底层类型相同（要考虑字段标签）并且其中至少有一个结构体值的类型为[无名类型](https://gfw.go101.org/article/type-system-overview.html#named-type)时（换句话说，只有它们可以被隐式转换为对方的类型的时候，见下）才可以互相赋值。



### 结构体字段的可寻址性

如果一个结构体值是可寻址的，则它的字段也是可寻址的；反之，一个不可寻址的结构体值的字段也是不可寻址的。 不可寻址的字段的值是不可更改的。所有的组合字面量都是不可寻址的。

一个例子：

```go
package main

import "fmt"

func main() {
	type Book struct {
		Pages int
	}
	var book = Book{} // 变量值book是可寻址的
	p := &book.Pages
	*p = 123
	fmt.Println(book) // {123}

	// 下面这两行编译不通过，因为Book{}是不可寻址的，
	// 继而Book{}.Pages也是不可寻址的。
	/*
	Book{}.Pages = 123
	p = &Book{}.Pages // <=> p = &(Book{}.Pages)
	*/
}
```

注意：选择器中的属性选择操作符`.`的优先级比取地址操作符`&`的优先级要高。



### 组合字面量不可寻址但可被取地址

一般来说，只有可被寻址的值才能被取地址，但是Go中有一个语法糖（语法例外）：虽然所有的组合字面量都是不可寻址的，但是它们都可被取地址。

例子：

```go
package main

func main() {
	type Book struct {
		Pages int
	}
	// Book{100}是不可寻址的，但是它可以被取地址。
	p := &Book{100} // <=> tmp := Book{100}; p := &tmp
	p.Pages = 200
}
```



### 在字段选择器中，属主结构体值可以是指针，它将被隐式解引用

比如，在下面的例子中，为了简洁，`(*bookN).pages`可以被写成`bookN.pages`。 换句话说，在这种简写形式中，`bookN`将被隐式解引用。

```go
package main

func main() {
	type Book struct {
		pages int
	}
	book1 := &Book{100} // book1是一个指针
	book2 := new(Book)  // book2是另外一个指针
	// 像使用结构值一样来使用结构体值的指针。
	book2.pages = book1.pages
	// 上一行等价于下一行。换句话说，上一行
	// 两个选择器中的指针属主将被自动解引用。
	(*book2).pages = (*book1).pages
}
```





### 关于结构体值的比较

如果一个结构体类型是可比较的，则它肯定不包含[不可比较类型](https://gfw.go101.org/article/type-system-overview.html#types-not-support-comparison)的字段（这里不忽略名为空标识符`_`的字段）。

和结构体值的赋值规则类似，如果两个不同类型的结构体值均为可比较的，则它们仅在它们的底层类型相同（要考虑字段标签）并且其中至少有一个结构体值的类型为无名类型时（换句话说，只有它们可以被隐式转换为对方的类型的时候，见下）才可以互相比较。

如果两个结构体值可以相互比较，则它们的比较结果等同于逐个比较它们的相应字段（按照字段在代码中的声明顺序）。 两个结构体值只有在它们的相应字段都相等的情况下才相等；当一对字段被发现不相等的或者[在比较中产生恐慌](https://gfw.go101.org/article/interface.html#comparison)的时候，对结构体的比较将提前结束结束。 在比较中，名为空标识符`_`的字段将被忽略掉。

### 关于结构体值的类型转换

两个类型分别为`S1`和`S2`的结构体值只有在`S1`和`S2`的底层类型相同（忽略掉字段标签）的情况下才能相互转换为对方的类型。 特别地，如果`S1`和`S2`的底层类型相同（要考虑字段标签）并且只要它们其中有一个为无名类型，则此转换可以是隐式的。

比如，对于下面的代码片段中所示的五个结构体类型：`S0`、`S1`、`S2`、`S3`和`S4`：

- 类型`S0`的值不能被转换为其它四个类型中的任意一个，原因是它与另外四个类型的对应字段名不同（因此底层类型不同）。
- 类型`S1`、`S2`、`S3`和`S4`的任意两个值可以转换为对方的类型。

特别地，

- `S2`表示的类型的值可以被隐式转化为类型`S3`，反之亦然。
- `S2`表示的类型的值可以被隐式转换为类型`S4`，反之亦然。

但是，

- `S2`表示的类型的值必须被显式转换为类型`S1`，反之亦然。
- 类型`S3`的值必须被显式转换为类型`S4`，反之亦然。

```go
package main

type S0 struct {
	y int "foo"
	x bool
}

type S1 = struct { // S1是一个无名类型
	x int "foo"
	y bool
}

type S2 = struct { // S2也是一个无名类型
	x int "bar"
	y bool
}

type S3 S2 // S3是一个定义类型（因而具名）。
type S4 S3 // S4是一个定义类型（因而具名）。
// 如果不考虑字段标签，S3（S4）和S1的底层类型一样。
// 如果考虑字段标签，S3（S4）和S1的底层类型不一样。

var v0, v1, v2, v3, v4 = S0{}, S1{}, S2{}, S3{}, S4{}
func f() {
	v1 = S1(v2); v2 = S2(v1)
	v1 = S1(v3); v3 = S3(v1)
	v1 = S1(v4); v4 = S4(v1)
	v2 = v3; v3 = v2 // 这两个转换可以是隐式的
	v2 = v4; v4 = v2 // 这两个转换也可以是隐式的
	v3 = S3(v4); v4 = S4(v3)
}
```



事实上，两个结构体值只有在它们可以相互隐式转换为对方的类型的时候才能相互赋值和比较。

### 匿名结构体类型可以使用在结构体字段声明中

匿名结构体类型允许出现在结构体字段声明中。匿名结构体类型也允许出现在组合字面量中。

一个例子：

```go
var aBook = struct {
	author struct { // 此字段的类型为一个匿名结构体类型
		firstName, lastName string
		gender              bool
	}
	title string
	pages int
}{
	author: struct {
		firstName, lastName string
		gender              bool
	}{
		firstName: "Mark",
		lastName: "Twain",
	}, // 此组合字面量中的类型为一个匿名结构体类型
	title: "The Million Pound Note",
	pages: 96,
}
```

通常来说，为了代码可读性，最好少使用匿名结构体类型。

### 更多关于结构体类型

Go中有一些和结构体类型相关的进阶知识点。这些知识点将后面的[类型内嵌](https://gfw.go101.org/article/type-embedding.html)和[内存布局](https://gfw.go101.org/article/memory-layout.html#size-and-padding)两篇文章中介绍。

------



## 值部

此篇文章后续的若干文章将介绍Go中更多的类型。为了更容易和更深刻地理解那些类型，最好先阅读一下本文。

### Go类型分为两大类别（category）

Go可以被看作是一门C语言血统的语言，这可以通过此前的[指针](https://gfw.go101.org/article/pointer.html)和[结构体](https://gfw.go101.org/article/struct.html)两篇文章得以验证。 Go中的指针和结构体类型的内存结构和C语言很类似。

另一方面，Go也可以被看作是C语言的一个扩展框架。 在C中，值的内存结构都是很透明的；但在Go中，对于某些类型的值，其内存结构却不是很透明。 在C中，每个值在内存中只占据一个[内存块](https://gfw.go101.org/article/memory-block.html)（一段连续内存）；但是，一些Go类型的值可能占据多个内存块。

以后，我们称一个Go值分布在不同内存块上的部分为此值的各个值部（value part）。 一个分布在多个内存块上的值含有一个直接值部和若干被此直接值部[引用着](https://gfw.go101.org/article/pointer.html#references)的间接值部。

上面的段落描述了两个类别的Go类型。下表将列出这两个类别（category）中的类型（type）种类（kind）：

| 每个值在内存中只分布在一个内存块上的类型                     | 每个值在内存中会分布在多个内存块上的类型                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![单值部](https://gfw.go101.org/article/res/value-parts-single.png) | ![多值部](https://gfw.go101.org/article/res/value-parts-multiple.png) |
| 布尔类型 各种数值类型 指针类型 非类型安全指针类型 结构体类型 数组类型 | 切片类型 映射类型 通道类型 函数类型 接口类型 字符串类型      |

表中列出的很多类型将在后续文章中逐一详细讲解。本文的目的就是为了给后续的讲解做一个铺垫。

注意：

- 接口类型和字符串类型值是否包含间接部分取决于具体编译器实现。 如果不使用今后将介绍的非类型安全途径，我们无法从这两类类型的值的外在表现来判定它们的值是否含有间接部分。 在《Go语言101》中，我们认为这两类类型的值是可能包含间接值部的。
- 同样地，函数类型的值是否包含间接部分几乎也是不可能验证的。 在《Go语言101》中，我们认为函数值是可能包含间接值部的。

通过封装了很多具体的实现细节，第二个类别中的类型给Go编程带来了很大的便利。 不同的编译器实现会采用不同的内部结构来实现这些类型，但是这些类型的值的外在表现必须满足Go白皮书中的要求。 此分类中的类型对于编程来说并非是很基础的类型。 我们可以使用第一个分类中的类型来实现此分类中的类型。 但是，通过将一些常用或者很独特的功能封装到此第二个分类中的类型里，使用Go编程的效率将得到大大提升，体验将得到大大增强。

另一方面，这些封装同时也隐藏了这些类型的值的内部结构，使得Go程序员不能对这些类型有一个更全局更深刻的认识。有时候这会对更好地理解Go带来了一些障碍。

为了帮助Go程序员更好的理解第二个分类中的类型和它们的值，本文余下的内容将对这些类型的内在实现做一个简单介绍。 这些实现的细节将不会在本文中谈及。本文的介绍主要基于（但并不完全符合）官方标准编译器的实现。

### Go中的两种指针类型

在继续下面的内容之前，我们先了解一下Go中的两种指针类型并明确一下“引用”这个词的含义。

我们已经在[上上篇文章](https://gfw.go101.org/article/pointer.html)中了解了Go中的指针。 那篇文章中所介绍的指针属于类型安全的指针。事实上，Go还支持另一种称为[非类型安全的指针类型](https://gfw.go101.org/article/unsafe.html)。 非类型安全的指针类型提供在`unsafe`标准库包中。 非类型安全指针类型通常使用`unsafe.Pointer`来表示。 `unsafe.Pointer`类似于C语言中的`void*`。

在《Go语言101》中的大多数文章中，如果没有特别说明，当一个指针类型被谈及，它表示一个类型安全指针。 但是在本文的余下内容中，当一个指针被谈及，它可能表示一个类型安全指针，也可能表示一个非类型安全指针。

一个指针值存储着另一个值的地址，除非此指针值是一个nil空指针。 我们可以说此指针[引用着](https://gfw.go101.org/article/pointer.html#references)另外一个值，或者说另外一个值正被此指针所引用。 一个值可能被间接引用，比如

- 如果一个结构体值`a`含有一个指针字段`b`并且这个指针字段`b`引用着另外一个值`c`，那么我们可以说结构体值`a`也引用着值`c`。
- 如果一个值`x`（直接或者间接地）引用着另一个值`y`，并且值`y`（直接或者间接地）引用着第三个值`z`，则我们可以说值`x`间接地引用着值`z`。

以后，我们将一个含有（直接或者间接）指针字段的结构体类型称为一个**指针包裹类型**，将一个含有（直接或者间接）指针的类型称为**指针持有者类型**。 指针类型和指针包裹类型都属于指针持有者类型。元素类型为指针持有者类型的数组类型也是指针持有者类型（数组将在下一篇文章中介绍）。



### 第二个分类中的类型的（可能的）内部实现结构定义

为了更好地理解第二个分类中的类型的值的运行时刻行为，我们可以认为这些类型在内部是使用第一个分类中的类型来定义的（如下所示）。 如果你以前并没有很多使用过Go中各种类型的经验，目前你不必深刻地理解这些定义。 对这些定义拥有一个粗糙的印象足够对理解后续文章中将要讲解的类型有所帮助。 你可以在今后有了更多的Go编程经验之后再重读一下本文。

#### 映射、通道和函数类型的内部定义

映射、通道和函数类型的内部定义很相似：

```go
// 映射类型
type _map *hashtableImpl // 目前，官方标准编译器是使用
                         // 哈希表来实现映射的。

// 通道类型
type _channel *channelImpl

// 函数类型
type _function *functionImpl
```

从这些定义，我们可以看出来，这三个种类的类型的内部结构其实是一个指针类型。 或者说，这些类型的值的直接部分在内部是一个指针。 这些类型的每个值的直接部分引用着它的具体实现的底层间接部分。

#### 切片类型的内部定义

切片类型的内部定义：

```go
type _slice struct {
	elements unsafe.Pointer // 引用着底层的元素
	len      int            // 当前的元素个数
	cap      int            // 切片的容量
}
```

从这个定义可以看出来，一个切片类型在内部可以看作是一个指针包裹类型。 每个非零切片值包含着一个底层间接部分用来存储此切片的元素。 一个切片值的底层元素序列（间接部分）被此切片值的`elements`字段所引用。

#### 字符串类型的内部结构

```go
type _string struct {
	elements *byte // 引用着底层的byte元素
	len      int   // 字符串的长度
}
```

从此定义可以看出，每个字符串类型在内部也可以看作是一个指针包裹类型。 每个非零字符串值含有一个指针字段 `elements`。 这个指针字段引用着此字符串值的底层字节元素序列。



#### 接口类型的内部定义

我们可以认为接口类型在内部是如下定义的：

```go
type _interface struct {
	dynamicType  *_type         // 引用着接口值的动态类型
	dynamicValue unsafe.Pointer // 引用着接口值的动态值
}
```

从这个定义来看，接口类型也可以看作是一个指针包裹类型。一个接口类型含有两个指针字段。 每个非零接口值的（两个）间接部分分别存储着此接口值的动态类型和动态值。 这两个间接部分被此接口值的直接字段`dynamicType`和`dynamicValue`所引用。

事实上，上面这个内部定义只用于表示空接口类型的值。空接口类型没有指定任何方法。 后面的[接口](https://gfw.go101.org/article/interface.html)一文详细解释了接口类型和值。 非空接口类型的内部定义如下：

```go
type _interface struct {
	dynamicTypeInfo *struct {
		dynamicType *_type       // 引用着接口值的动态类型
		methods     []*_function // 引用着动态类型的对应方法列表
	}
	dynamicValue unsafe.Pointer // 引用着动态值
}
```

一个非空接口类型的值的`dynamicTypeInfo`字段的`methods`字段引用着一个方法列表。 此列表中的每一项为此接口值的动态类型上定义的一个方法，此方法对应着此接口类型所指定的一个的同描述的方法。



### 在赋值中，底层间接值部将不会被复制

现在我们了解了第二个分类中的类型的内部结构是一个指针持有（指针或者指针包裹）类型。 这对于我们理解Go中的值复制行为有很大帮助。

在Go中，每个赋值操作（包括函数调用传参等）都是一个值的浅复制过程（假设源值和目标值的类型相同）。 换句话说，在一个赋值操作中，只有源值的直接部分被复制给了目标值。 如果源值含有间接部分，则在此赋值操作完成之后，目标值和源值的直接部分将引用着相同的间接部分。 换句话说，两个值将共享底层的间接值部，如下图所示：

![值复制](https://gfw.go101.org/article/res/value-parts-copy.png)



事实上，对于字符串值和接口值的赋值，上述描述在理论上并非百分百正确。 [官方FAQ](https://golang.google.cn/doc/faq#pass_by_value)明确说明了在一个接口值的赋值中，接口的底层动态值将被复制到目标值。 但是，因为一个接口值的动态值是只读的，所以在接口值的赋值中，官方标准编译器并没有复制底层的动态值。这可以被视为是一个编译器优化。 对于字符串值的赋值，道理是一样的。所以对于官方标准编译器来说，上一段的描述是100%正确的。

因为一个间接值部可能并不专属于任何一个值，所以在使用`unsafe.Sizeof`函数计算一个值的尺寸的时候，此值的间接部分所占内存空间未被计算在内。



### 关于术语“引用类型”和“引用值”

“引用”这个术语在Go社区中使用得有些混乱。很多Go程序员在Go编程中可能由此产生了一些困惑。 一些文档或者网络文章，包括一些[官方文档](https://golang.google.cn/doc/faq#references)，把“引用”（reference）看作是“值”（value）的一个对立面。 《Go语言101》强烈不推荐这种定义。在这一点上，本人不想争论什么。这里仅仅列出一些肯定错误地使用了“引用”这个术语的例子：

- 在Go中，只有切片、映射、通道和函数类型属于***引用类型\***。 （如果我们确实需要***引用类型\***这个术语，那么我们不应把其它指针持有者类型排除在引用类型之外。）
- 一些函数调用的参数是通过引用来传递的。 （对不起，在Go中，所有的函数调用的参数都是通过值复制**直接值部**的方式来传递的。）

我并不是想说***引用类型\***这个术语在Go中是完全没有价值的， 我只是想表达这个术语是完全没有必要的，并且它常常在Go的使用中导致一些困惑。我推荐使用指针持有者类型来代替这个术语。 另外，我个人的观点是最好将***引用\***这个词限定到只表示值之间的关系，把它当作一个动词或者名词来使用，永远不要把它当作一个形容词来使用。 这样将在使用Go的过程中避免很多困惑。

------



## 数组、切片和映射

在严格意义上，Go中有三种一等公民容器类型：数组、切片和映射。 有时候，我们可以认为字符串类型和通道类型也属于容器类型。 但是，此篇文章只谈及数组、切片和映射类型。

Go中有很多和容器类型相关的细节，本文将逐一列出这些细节。

### 容器类型和容器值概述

每个容器（值）用来表示和存储一个元素（element）序列或集合。一个容器中的所有元素的类型是相同的。此相同的类型称为此容器的类型的元素类型（或简称此容器的元素类型）。

存储在一个容器中的每个元素值都关联着一个键值（key）。每个元素可以通过它的键值而被访问到。 一个映射类型的键值类型必须为一个[可比较类型](https://gfw.go101.org/article/type-system-overview.html#types-not-support-comparison)。 数组和切片类型的键值类型均为内置类型`int`。 一个数组或切片的一个元素对应的键值总是一个非负整数下标，此非负整数表示该元素在该数组或切片所有元素中的顺序位置。此非负整数下标亦常称为一个元素索引（index）。

每个容器值有一个长度属性，用来表明此容器中当前存储了多少个元素。 一个数组或切片中的每个元素所关联的非负整数索引键值的合法取值范围为左闭右开区间`[0, 此数组或切片的长度)`。 一个映射值类型的容器值中的元素关联的键值可以是任何此映射类型的键值类型的任何值。

这三种容器类型的值在使用上有很多的差别。这些差别多源于它们的内存结构的差异。 通过上一篇文章[值部](https://gfw.go101.org/article/value-part.html)，我们得知每个数组值仅由一个直接部分组成，而一个切片或者映射值是由一个直接部分和一个可能的被此直接部分引用着的间接部分组成。

一个数组或者切片的所有元素紧挨着存放在一块连续的内存中。一个数组中的所有元素均存放在此数组值的直接部分，一个切片中的所有元素均存放在此切片值的间接部分。 在官方标准编译器和运行时中，映射是使用哈希表算法来实现的。所以一个映射中的所有元素也均存放在一块连续的内存中，但是映射中的元素并不一定紧挨着存放。 另外一种常用的映射实现算法是二叉树算法。无论使用何种算法，一个映射中的所有元素的键值也存放在此映射值（的间接部分）中。

我们可以通过一个元素的键值来访问此元素。 对于这三种容器，元素访问的时间复杂度均为`*O*(1)`。 但是一般来说，映射元素访问消耗的时长要数倍于数组和切片元素访问消耗的时长。 但是映射相对于数组和切片有两个优点：

- 映射的键值类型可以是任何可比较类型。
- 对于大多数元素为零值的情况，使用映射可以节省大量的内存。

从上一篇文章中，我们已经了解到，在任何赋值中，源值的底层间接部分不会被复制。 换句话说，当一个赋值结束后，一个含有间接部分的源值和目标值将共享底层间接部分。 这就是数组和切片/映射值会有很多行为差异（将在下面逐一介绍）的原因。

### 无名容器类型的字面表示形式

无名容器类型的字面表示形式如下：

- 数组类型：`[N]T`
- 切片类型：`[]T`
- 映射类型：`map[K]T`

其中，

- `T`可为任意类型。它表示一个容器类型的元素类型。某个特定容器类型的值中只能存储此容器类型的元素类型的值。
- `N`必须为一个非负整数常量。它指定了一个数组类型的长度，或者说它指定了此数组类型的任何一个值中存储了多少个元素。 一个数组类型的长度是此数组类型的一部分。比如`[5]int`和`[8]int`是两个不同的类型。
- `K`必须为一个[可比较类型](https://gfw.go101.org/article/type-system-overview.html#types-not-support-comparison)。它指定了一个映射类型的键值类型。

下面列出了一些无名容器类型的字面表示：

```go
const Size = 32

type Person struct {
	name string
	age  int
}

// 数组类型
[5]string
[Size]int
[16][]byte  // 元素类型为一个切片类型：[]byte
[100]Person // 元素类型为一个结构体类型：Person

// 切片类型
[]bool
[]int64
[]map[int]bool // 元素类型为一个映射类型：map[int]bool
[]*int         // 元素类型为一个指针类型：*int

// 映射类型
map[string]int
map[int]bool
map[int16][6]string     // 元素类型为一个数组类型：[6]string
map[bool][]string       // 元素类型为一个切片类型：[]string
map[struct{x int}]*int8 // 元素类型为一个指针类型：*int8；
                        // 键值类型为一个结构体类型。
```



所有切片类型的[尺寸](https://gfw.go101.org/article/type-system-overview.html#value-size)都是一致的，所有映射类型的尺寸也都是一致的。 一个数组类型的尺寸等于它的元素类型的尺寸和它的长度的乘积。长度为零的数组的尺寸为零；元素类型尺寸为零的任意长度的数组类型的尺寸也为零。



### 容器字面量的表示形式

和结构体值类似，容器值的文字表示也可以用组合字面量形式（composite literal）来表示。 比如对于一个容器类型`T`，它的值可以用形式`T{...}`来表示（除了切片和映射的零值外）。 下面是一些容器字面量：

```go
// 一个含有4个布尔元素的数组值。
[4]bool{false, true, true, false}

// 一个含有三个字符串值的切片值。
[]string{"break", "continue", "fallthrough"}

// 一个映射值。
map[string]int{"C": 1972, "Python": 1991, "Go": 2009}
```

映射组合字面量中大括号中的每一项称为一个键值元素对（key-value pair），或者称为一个条目（entry）。

数组和切片组合字面量有一些微小的变种：

```go
// 下面这些切片字面量都是等价的。
[]string{"break", "continue", "fallthrough"}
[]string{0: "break", 1: "continue", 2: "fallthrough"}
[]string{2: "fallthrough", 1: "continue", 0: "break"}
[]string{2: "fallthrough", 0: "break", "continue"}

// 下面这些数组字面量都是等价的。
[4]bool{false, true, true, false}
[4]bool{0: false, 1: true, 2: true, 3: false}
[4]bool{1: true, true}
[4]bool{2: true, 1: true}
[...]bool{false, true, true, false}
[...]bool{3: false, 1: true, true}
```

上例中最后两行中的`...`表示让编译器推断出相应数组值的类型的长度。

从上面的例子中，我们可以看出数组和切片组合字面量中的索引下标（即数组和切片的键值）是可选的。 在一个数组或者切片组合字面量中：

- 如果一个索引下标出现，它的类型不必是数组和切片类型的键值类型`int`，但它必须是一个可以表示为int值的非负常量； 如果它是一个类型确定值，则它的类型必须为一个内置整数类型。
- **在一个数组或切片组合字面量中，如果一个元素的索引下标缺失，则编译器认为它的索引下标为出现在它之前的元素的索引下标加一。**
- 如果出现的第一个元素的索引下标缺失，则它的索引下标被认为是0。

映射组合字面量中元素对应的键值不可缺失，并且它们可以为非常量。

```go
var a uint = 1
var _ = map[uint]int {a : 123} // 没问题
var _ = []int{a: 100}          // error: 下标必须为常量
var _ = [5]int{a: 100}         // error: 下标必须为常量
```



一个容器组合字面量中的[常量键值（包括索引下标）不可重复](https://gfw.go101.org/article/details.html#constant-keys-in-composite-literals)。

### 容器类型零值的字面量表示形式

和结构体类似，一个数组类型`A`的零值可以表示为`A{}`。 比如，数组类型`[100]int`的零值可以表示为`[100]int{}`。 一个数组零值中的所有元素均为对应数组元素类型的零值。

和指针一样，所有切片和映射类型的零值均用预声明的标识符`nil`来表示。

顺便说一句，除了刚提到的三种类型，以后将介绍的函数、通道和接口类型的零值也用预声明的标识符`nil`来表示。

在运行时刻，即使一个数组变量在声明的时候未指定初始值，它的元素所占的内存空间也已经被开辟出来。 但是一个nil切片或者映射值的元素的内存空间尚未被开辟出来。

注意：`[]T{}`表示类型`[]T`的一个空切片值，它和`[]T(nil)`是不等价的。 同样，`map[K]T{}`和`map[K]T(nil)`也是不等价的。



### 容器字面量是不可寻址的但可以被取地址

我们已经了解到[结构体（组合）字面量是不可寻址的但却是可以被取地址的](https://gfw.go101.org/article/struct.html#take-composite-literal-address)。 容器字面量也不例外。

一个例子：

```go
package main

import "fmt"

func main() {
	pm := &map[string]int{"C": 1972, "Go": 2009}
	ps := &[]string{"break", "continue"}
	pa := &[...]bool{false, true, true, false}
	fmt.Printf("%T\n", pm) // *map[string]int
	fmt.Printf("%T\n", ps) // *[]string
	fmt.Printf("%T\n", pa) // *[4]bool
}
```





### 内嵌组合字面量可以被简化

在某些情形下，内嵌在其它组合字面量中的组合字面量可以简化为`{...}`（即类型部分被省略掉了）。 内嵌组合字面量前的取地址操作符`&`有时也可以被省略。

比如，下面的组合字面量

```go
// heads为一个切片值。它的类型的元素类型为*[4]byte。
// 此元素类型为一个基类型为[4]byte的指针类型。
// 此指针基类型为一个元素类型为byte的数组类型。
var heads = []*[4]byte{
	&[4]byte{'P', 'N', 'G', ' '},
	&[4]byte{'G', 'I', 'F', ' '},
	&[4]byte{'J', 'P', 'E', 'G'},
}
```

可以被简化为

```go
var heads = []*[4]byte{
	{'P', 'N', 'G', ' '},
	{'G', 'I', 'F', ' '},
	{'J', 'P', 'E', 'G'},
}
```



下面这个数组组合字面量

```go
type language struct {
	name string
	year int
}

var _ = [...]language{
	language{"C", 1972},
	language{"Python", 1991},
	language{"Go", 2009},
}
```

可以被简化为

```go
var _ = [...]language{
	{"C", 1972},
	{"Python", 1991},
	{"Go", 2009},
}
```



下面这个映射组合字面量

```go
type LangCategory struct {
	dynamic bool
	strong  bool
}

// 此映射值的类型的键值类型为一个结构体类型，
// 元素类型为另一个映射类型：map[string]int。
var _ = map[LangCategory]map[string]int{
	LangCategory{true, true}: map[string]int{
		"Python": 1991,
		"Erlang": 1986,
	},
	LangCategory{true, false}: map[string]int{
		"JavaScript": 1995,
	},
	LangCategory{false, true}: map[string]int{
		"Go":   2009,
		"Rust": 2010,
	},
	LangCategory{false, false}: map[string]int{
		"C": 1972,
	},
}
```

可以被简化为

```go
var _ = map[LangCategory]map[string]int{
	{true, true}: {
		"Python": 1991,
		"Erlang": 1986,
	},
	{true, false}: {
		"JavaScript": 1995,
	},
	{false, true}: {
		"Go":   2009,
		"Rust": 2010,
	},
	{false, false}: {
		"C": 1972,
	},
}
```

注意，在上面的几个例子中，最后一个元素后的逗号不能被省略。原因详见后面的[断行规则](https://gfw.go101.org/article/line-break-rules.html)一文。



### 容器值的比较

在[Go类型系统概述](https://gfw.go101.org/article/type-system-overview.html#types-not-support-comparison)一文中，我们已经了解到映射和切片类型都属于不可比较类型。 所以任意两个映射值（或切片值）是不能相互比较的。

尽管两个映射值和切片值是不能比较的，但是一个映射值或者切片值可以和预声明的`nil`标识符进行比较以检查此映射值或者切片值是否为一个零值。

大多数数组类型都是可比较类型，除了元素类型为不可比较类型的数组类型。

当比较两个数组值时，它们的对应元素将按照逐一被比较（可以认为按照下标顺序比较）。这两个数组只有在它们的对应元素都相等的情况下才相等；当一对元素被发现不相等的或者[在比较中产生恐慌](https://gfw.go101.org/article/interface.html#comparison)的时候，对数组的比较将提前结束。

一个例子：

```go
package main

import "fmt"

func main() {
	var a [16]byte
	var s []int
	var m map[string]int

	fmt.Println(a == a)   // true
	fmt.Println(m == nil) // true
	fmt.Println(s == nil) // true
	fmt.Println(nil == map[string]int{}) // false
	fmt.Println(nil == []int{})          // false

	// 下面这些行编译不通过。
	/*
	_ = m == m
	_ = s == s
	_ = m == map[string]int(nil)
	_ = s == []int(nil)
	var x [16][]int
	_ = x == x
	var y [16]map[int]bool
	_ = y == y
	*/
}
```





### 查看容器值的长度和容量

除了上面已提到的容器长度属性（此容器中含有有多少个元素），每个容器值还有一个容量属性。 一个数组值的容量总是和它的长度相等；一个非零映射值的容量可以被认为是无限大的。切片值的容量的含义将在后续章节介绍。 一个切片值的容量总是不小于此切片值的长度。在编程中，只有切片值的容量有实际意义。

我们可以调用内置函数`len`来获取一个容器值的长度，或者调用内置函数`cap`来获取一个容器值的容量。 这两个函数都返回一个`int`类型确定结果值或者一个默认类型为`int`的类型不确定结果，具体取决于传递给它们的实参是否为常量表达式。 因为非零映射值的容量是无限大，所以`cap`并不适用于映射值。

一个数组值的长度和容量永不改变。同一个数组类型的所有值的长度和容量都总是和此数组类型的长度相等。 切片值的长度和容量可在运行时刻改变（一般只能通过被赋值的途径来修改，两者一般不可单独被修改）。 因为此原因，切片可以被认为是动态数组。 切片在使用上相比数组更为灵活，所以切片（相对数组）在编程用得更为广泛。

一个例子：

```go
package main

import "fmt"

func main() {
	var a [5]int
	fmt.Println(len(a), cap(a)) // 5 5
	var s []int
	fmt.Println(len(s), cap(s)) // 0 0
	s, s2 := []int{2, 3, 5}, []bool{}
	fmt.Println(len(s), cap(s), len(s2), cap(s2)) // 3 3 0 0
	var m map[int]bool
	fmt.Println(len(m)) // 0
	m, m2 := map[int]bool{1: true, 0: false}, map[int]int{}
	fmt.Println(len(m), len(m2)) // 2 0
}
```

上面这个特定的例子中的每个切片值的长度和容量都相等，但这并不是一个普遍定律。 我们将在后面的章节中展示一些长度和容量不相等的切片值。



### 读取和修改容器的元素

一个容器值`v`中存储的对应着键值`k`的元素用语法形式`v[k]`来表示。 今后我们称`v[k]`为一个元素索引表达式。

假设`v`是一个数组或者切片，在`v[k]`中，

- 如果`k`是一个常量，则它必须满足上面列出的[对出现在组合字面量中的索引的要求](https://gfw.go101.org/article/container.html#value-literals)。 另外，如果`v`是一个数组，则`k`必须小于此数组的长度。
- 如果`k`不是一个常量，则它必须为一个整数。 另外它必须为一个非负数并且小于`len(v)`，否则，在运行时刻将产生一个恐慌。
- 如果`v`是一个零值切片，则在运行时刻将产生一个恐慌。

假设`v`是一个映射值，在`v[k]`中，`k`的类型必须为（或者可以隐式转换为）`v`的类型的元素类型。另外，

- 如果`k`是一个动态类型为不可比较类型的接口值，则`v[k]`在运行时刻将造成一个恐慌；
- 如果`v[k]`被用做一个赋值语句中的目标值并且`v`是一个零值nil映射，则`v[k]`在运行时刻将造成一个恐慌；
- 如果`v[k]`用来表示读取映射值`v`中键值`k`对应的元素，则它无论如何都不会产生一个恐慌，即使`v`是一个零值nil映射（假设`k`的估值没有造成恐慌）；
- 如果`v[k]`用来表示读取映射值`v`中键值`k`对应的元素，并且映射值`v`中并不含有对应着键值`k`的条目，则`v[k]`返回一个此映射值的类型的元素类型的零值。 一般情况下，`v[k]`被认为是一个单值表达式。但是在一个`v[k]`被用为唯一源值的赋值语句中，`v[k]`可以返回一个可选的第二个返回值。 此第二个返回值是一个类型不确定布尔值，用来表示是否有对应着键值`k`的条目存储在映射值`v`中。

一个展示了容器元素修改和读取的例子：

```go
package main

import "fmt"

func main() {
	a := [3]int{-1, 0, 1}
	s := []bool{true, false}
	m := map[string]int{"abc": 123, "xyz": 789}
	fmt.Println (a[2], s[1], m["abc"])    // 读取
	a[2], s[1], m["abc"] = 999, true, 567 // 修改
	fmt.Println (a[2], s[1], m["abc"])    // 读取

	n, present := m["hello"]
	fmt.Println(n, present, m["hello"]) // 0 false 0
	n, present = m["abc"]
	fmt.Println(n, present, m["abc"]) // 567 true 567
	m = nil
	fmt.Println(m["abc"]) // 0

	// 下面这两行编译不通过。
	/*
	_ = a[3]  // 下标越界
	_ = s[-1] // 下标越界
	*/

	// 下面这几行每行都会造成一个恐慌。
	_ = a[n]         // panic: 下标越界
	_ = s[n]         // panic: 下标越界
	m["hello"] = 555 // panic: m为一个零值映射
}
```



### 重温一下切片的内部结构

为了更好的理解和解释切片类型和切片值，我们最好对切片的内部结构有一个基本的印象。 在上一篇文章[值部](https://gfw.go101.org/article/value-part.html)中，我们已经了解到官方标准编译器对切片类型的内部定义大致如下：

```go
type _slice struct {
	elements unsafe.Pointer // 引用着底层存储在间接部分上的元素
	len      int            // 长度
	cap      int            // 容量
}
```

虽然其它编译器中切片类型的内部结构可能并不完全和官方标准编译器一致，但应该大体上是相似的。 下面的解释均基于官方标准编译器对切片类型的内部定义。

上面展示的切片的内部定义为切片的直接部分的定义。直接部分的`len`字段表示一个切片当前存储了多少个元素；直接部分的`cap`表示一个切片的容量。 下面这张图描绘了一个切片值的内存布局。

![切片值内存布局](https://gfw.go101.org/article/res/slice-internal.png)



尽管一个切片值的底层元素部分可能位于一个比较大的内存片段上，但是此切片值只能感知到此内存片段上的一个子片段。 比如，上图中的切片值只能感知到灰色的子片段。

在上图中，从下标`len`（包含）到下标`cap`（不包含）对应的元素并不属于图中所示的切片值。 它们只是此切片之中的一些冗余元素槽位，但是它们可能是其它切片（或者数组）值中的有效元素。

下一节将要介绍如何通过调用内置`append`函数来向一个基础切片添加元素而得到一个新的切片。 这个新的结果切片可能和这个基础切片共享起始元素，也可能不共享，具体取决于基础切片的容量（以及长度）和添加的元素数量。

当一个切片被用做一个`append`函数调用中的基础切片，

- 如果添加的元素数量大于此（基础）切片的冗余元素槽位的数量，则一个新的底层内存片段将被开辟出来并用来存放结果切片的元素。 这时，基础切片和结果切片不共享任何底层元素。
- 否则，不会有底层内存片段被开辟出来。这时，基础切片中的所有元素也同时属于结果切片。两个切片的元素都存放于同一个内存片段上。

下下一节将展示一张包含了上述两种情况的图片。

一些其它切片操作也可能会造成两个切片共享底层内存片段的情况。这些操作将在后续章节逐一介绍。

注意，一般我们不能单独修改一个切片值的某个内部字段，除非使用[反射](https://gfw.go101.org/article/container.html#modify-slice-length-and-capacity)或者[非类型安全指针](https://gfw.go101.org/article/unsafe.html)。 换句话说，一般我们只能通过将其它切片赋值给一个切片来同时修改这个切片的三个字段。



### 容器赋值

当一个映射赋值语句执行完毕之后，目标映射值和源映射值将共享底层的元素。 向其中一个映射中添加（或从中删除）元素将体现在另一个映射中。

和映射一样，当一个切片赋值给另一个切片后，它们将共享底层的元素。它们的长度和容量也相等。 但是和映射不同，如果以后其中一个切片改变了长度或者容量，此变化不会体现到另一个切片中。

当一个数组被赋值给另一个数组，所有的元素都将被从源数组复制到目标数组。赋值完成之后，这两个数组不共享任何元素。

一个例子：

```go
package main

import "fmt"

func main() {
	m0 := map[int]int{0:7, 1:8, 2:9}
	m1 := m0
	m1[0] = 2
	fmt.Println(m0, m1) // map[0:2 1:8 2:9] map[0:2 1:8 2:9]

	s0 := []int{7, 8, 9}
	s1 := s0
	s1[0] = 2
	fmt.Println(s0, s1) // [2 8 9] [2 8 9]

	a0 := [...]int{7, 8, 9}
	a1 := a0
	a1[0] = 2
	fmt.Println(a0, a1) // [7 8 9] [2 8 9]
}
```





### 添加和删除容器元素

向一个映射中添加一个条目的语法和修改一个映射元素的语法是一样的。 比如，对于一个非零映射值`m`，如果当前`m`中尚未存储条目`(k, e)`，则下面的语法形式将把此条目存入`m`；否则，下面的语法形式将把键值`k`对应的元素值更新为`e`。

```go
m[k] = e
```



内置函数`delete`用来从一个映射中删除一个条目。比如，下面的`delete`调用将把键值`k`对应的条目从映射`m`中删除。 如果映射`m`中未存储键值为`k`的条目，则此调用为一个空操作，它不会产生一个恐慌，即使`m`是一个nil零值映射。

```go
delete(m, k)
```



下面的例子展示了如何向一个映射添加和从一个映射删除条目。

```go
package main

import "fmt"

func main() {
	m := map[string]int{"Go": 2007}
	m["C"] = 1972     // 添加
	m["Java"] = 1995  // 添加
	fmt.Println(m)    // map[C:1972 Go:2007 Java:1995]
	m["Go"] = 2009    // 修改
	delete(m, "Java") // 删除
	fmt.Println(m)    // map[C:1972 Go:2009]
}
```

注意，在Go 1.12之前，映射打印结果中的条目顺序并不固定，两次打印结果可能并不相同。

一个数组中的元素个数总是恒定的，我们无法向其中添加元素，也无法从其中删除元素。但是可寻址的数组值中的元素是可以被修改的。

我们可以通过调用内置`append`函数，以一个切片为基础，来添加不定数量的元素并返回一个新的切片。 此新的结果切片包含着基础切片中所有的元素和所有被添加的元素。 注意，基础切片并未被此`append`函数调用所修改。 当然，如果我们愿意（事实上在实践中常常如此），我们可以将结果切片赋值给基础切片以修改基础切片。

Go中并未提供一个内置方式来从一个切片中删除一个元素。 我们必须使用`append`函数和后面将要介绍的子切片语法一起来实现元素删除操作。 切片元素的删除和插入将在后面的[更多切片操作](https://gfw.go101.org/article/container.html#slice-manipulations)一节中介绍。 本节仅展示如何使用`append`内置函数。

下面是一个如何使用`append`内置函数的例子。

```go
package main

import "fmt"

func main() {
	s0 := []int{2, 3, 5}
	fmt.Println(s0, cap(s0)) // [2 3 5] 3
	s1 := append(s0, 7)      // 添加一个元素
	fmt.Println(s1, cap(s1)) // [2 3 5 7] 6
	s2 := append(s1, 11, 13) // 添加两个元素
	fmt.Println(s2, cap(s2)) // [2 3 5 7 11 13] 6
	s3 := append(s0)         // <=> s3 := s0
	fmt.Println(s3, cap(s3)) // [2 3 5] 3
	s4 := append(s0, s0...)  // 以s0为基础添加s0中所有的元素
	fmt.Println(s4, cap(s4)) // [2 3 5 2 3 5] 6

	s0[0], s1[0] = 99, 789
	fmt.Println(s2[0], s3[0], s4[0]) // 789 99 2
}
```



注意，内置`append`函数是一个[变长参数函数](https://gfw.go101.org/article/function.html#variadic-function)（下下篇文章中介绍）。 它有两个参数，其中第二个参数（形参）为一个[变长参数](https://gfw.go101.org/article/function.html#variadic-parameter)。

变长参数函数将在下下篇文章中解释。目前，我们只需知道变长参数函数调用中的实参有两种传递方式。 在上面的例子中，第*8*行、第*10*行和第*12*行使用了同一种方式，第*14*行使用了另外一种方式。 在第一种方式中，零个或多个实参元素值可以传递给`append`函数的第二个形参。 在第二种方式中，一个（和第一个实参同元素类型的）实参切片传递给了第二个形参，此切片实参必须跟随三个点`...`。 关于变长参数函数调用，详见[下下篇文章](https://gfw.go101.org/article/function.html#variadic-call)。

在上例中，第*14*行等价于

```go
	s4 := append(s0, s0[0], s0[1], s0[2])
```



第*8*行等价于

```go
	s1 := append(s0, []int{7}...)
```



第*10*行等价于

```go
	s2 := append(s1, []int{11, 13}...)
```



对于三个点方式，`append`函数并不要求第二个实参的类型和第一个实参一致，但是它们的元素类型必须一致。 换句话说，它们的[底层类型](https://gfw.go101.org/article/type-system-overview.html#underlying-type)必须一致。

在上面的程序中，

- 第*8*行的`append`函数调用将为结果切片`s1`开辟一段新的内存。 原因是切片`s0`中没有足够的冗余元素槽位来容纳新添加的元素。 第*14*行的`append`函数调用也是同样的情况。
- 第*10*行的`append`函数调用不会为结果切片`s2`开辟新的内存片段。 原因是切片`s1`中的冗余元素槽位足够容纳新添加的元素。

所以，上面的程序中在退出之前，切片`s1`和`s2`共享一些元素，切片`s0`和`s3`共享所有的元素。 下面这张图描绘了在上面的程序结束之前各个切片的状态。

![各个切片状态](https://gfw.go101.org/article/res/slice-append.png)



请注意，当一个`append`函数调用需要为结果切片开辟内存时，结果切片的容量取决于具体编译器实现。 在这种情况下，对于官方标准编译器，如果基础切片的容量较小，则结果切片的容量至少为基础切片的两倍。 这样做的目的是使结果切片有足够多的冗余元素槽位，以防止此结果切片被用做后续其它`append`函数调用的基础切片时再次开辟内存。

上面提到了，在实际编程中，我们常常将`append`函数调用的结果赋值给基础切片。 比如：

```go
package main

import "fmt"

func main() {
	var s = append([]string(nil), "array", "slice")
	fmt.Println(s)      // [array slice]
	fmt.Println(cap(s)) // 2
	s = append(s, "map")
	fmt.Println(s)      // [array slice map]
	fmt.Println(cap(s)) // 4
	s = append(s, "channel")
	fmt.Println(s)      // [array slice map channel]
	fmt.Println(cap(s)) // 4
}
```



截至目前（Go 1.21），`append`函数调用的第一个实参不能为类型不确定的`nil`。



### 使用内置`make`函数来创建切片和映射

除了使用组合字面量来创建映射和切片，我们还可以使用内置`make`函数来创建映射和切片。 数组不能使用内置`make`函数来创建。

顺便说一句，内置`make`函数也可以用来创建以后将要介绍的[通道](https://gfw.go101.org/article/channel.html)值。

假设`M`是一个映射类型并且`n`是一个整数，我们可以用下面的两种函数调用来各自生成一个类型为`M`的映射值。

```go
make(M, n)
make(M)
```

第一个函数调用形式创建了一个可以容纳至少`n`个条目而无需再次开辟内存的空映射值。 第二个函数调用形式创建了一个可以容纳一个小数目的条目而无需再次开辟内存的空映射值。此小数目的值取决于具体编译器实现。

注意：第二个参数`n`可以为负或者零，这时对应的调用将被视为上述第二种调用形式。

假设`S`是一个切片类型，`length`和`capacity`是两个非负整数，并且`length`小于等于`capacity`，我们可以用下面的两种函数调用来各自生成一个类型为`S`的切片值。`length`和`capacity`的类型必须均为整数类型（两者可以不一致）。

```go
make(S, length, capacity)
make(S, length) // <=> make(S, length, length)
```

第一个函数调用创建了一个长度为`length`并且容量为`capacity`的切片。 第二个函数调用创建了一个长度为`length`并且容量也为`length`的切片。

使用`make`函数创建的切片中的所有元素值均被初始化为（结果切片的元素类型的）零值。

下面是一个展示了如何使用`make`函数来创建映射和切片的例子：

```go
package main

import "fmt"

func main() {
	// 创建映射。
	fmt.Println(make(map[string]int)) // map[]
	m := make(map[string]int, 3)
	fmt.Println(m, len(m)) // map[] 0
	m["C"] = 1972
	m["Go"] = 2009
	fmt.Println(m, len(m)) // map[C:1972 Go:2009] 2

	// 创建切片。
	s := make([]int, 3, 5)
	fmt.Println(s, len(s), cap(s)) // [0 0 0] 3 5
	s = make([]int, 2)
	fmt.Println(s, len(s), cap(s)) // [0 0] 2 2
}
```





### 使用内置`new`函数来创建容器值

在前面的[指针](https://gfw.go101.org/article/pointer.html)一文中，我们已经了解到内置`new`函数可以用来为一个任何类型的值开辟内存并返回一个存储有此值的地址的指针。 用`new`函数开辟出来的值均为零值。因为这个原因，`new`函数对于创建映射和切片值来说没有任何价值。

使用`new`函数来用来创建数组值并非是完全没有意义的，但是在实践中很少这么做，因为使用组合字面量来创建数组值更为方便。

一个使用`new`函数创建容器值的例子：

```go
package main

import "fmt"

func main() {
	m := *new(map[string]int)   // <=> var m map[string]int
	fmt.Println(m == nil)       // true
	s := *new([]int)            // <=> var s []int
	fmt.Println(s == nil)       // true
	a := *new([5]bool)          // <=> var a [5]bool
	fmt.Println(a == [5]bool{}) // true
}
```





### 容器元素的可寻址性

一些关于容器元素的可寻址性的事实：

- 如果一个数组是可寻址的，则它的元素也是可寻址的；反之亦然，即如果一个数组是不可寻址的，则它的元素也是不可寻址的。 原因很简单，因为一个数组只含有一个（直接）[值部](https://gfw.go101.org/article/value-part.html)，并且它的所有元素和此直接值部均承载在同一个[内存块](https://gfw.go101.org/article/memory-block.html)上。
- 一个切片值的任何元素都是可寻址的，即使此切片本身是不可寻址的。 这是因为一个切片的底层元素总是存储在一个被开辟出来的内存片段（间接值部）上。
- 任何映射元素都是不可寻址的。原因详见[此条问答](https://gfw.go101.org/article/unofficial-faq.html#maps-are-unaddressable)。

一个例子：

```go
package main

import "fmt"

func main() {
	a := [5]int{2, 3, 5, 7}
	s := make([]bool, 2)
	pa2, ps1 := &a[2], &s[1]
	fmt.Println(*pa2, *ps1) // 5 false
	a[2], s[1] = 99, true
	fmt.Println(*pa2, *ps1) // 99 true
	ps0 := &[]string{"Go", "C"}[0]
	fmt.Println(*ps0) // Go

	m := map[int]bool{1: true}
	_ = m
	// 下面这几行编译不通过。
	/*
	_ = &[3]int{2, 3, 5}[0]
	_ = &map[int]bool{1: true}[1]
	_ = &m[1]
	*/
}
```



一般来说，一个不可寻址的值的直接部分是不可修改的。但是映射元素是个例外。 映射元素虽然不可寻址，但是每个映射元素可以被整个修改（但不能被部分修改）。 对于大多数做为映射元素类型的类型，在修改它们的值的时候，一般体现不出来整个修改和部分修改的差异。 但是如果一个映射的元素类型为数组或者结构体类型，这个差异是很明显的。

在上一篇文章[值部](https://gfw.go101.org/article/value-part.html)中，我们了解到每个数组或者结构体值都是仅含有一个直接部分。所以

- 如果一个映射类型的元素类型为一个结构体类型，则我们无法修改此映射类型的值中的每个结构体元素的单个字段。 我们必须整体地同时修改所有结构体字段。
- 如果一个映射类型的元素类型为一个数组类型，则我们无法修改此映射类型的值中的每个数组元素的单个元素。 我们必须整体地同时修改所有数组元素。

一个例子：

```go
package main

import "fmt"

func main() {
	type T struct{age int}
	mt := map[string]T{}
	mt["John"] = T{age: 29} // 整体修改是允许的
	ma := map[int][5]int{}
	ma[1] = [5]int{1: 789} // 整体修改是允许的

	// 这两个赋值编译不通过，因为部分修改一个映射
	// 元素是非法的。这看上去确实有些反直觉。
	/*
	ma[1][1] = 123      // error
	mt["John"].age = 30 // error
	*/

	// 读取映射元素的元素或者字段是没问题的。
	fmt.Println(ma[1][1])       // 789
	fmt.Println(mt["John"].age) // 29
}
```



为了让上例中的两行编译不通过的两行赋值语句编译通过，欲修改的映射元素必须先存放在一个临时变量中，然后修改这个临时变量，最后再用这个临时变量整体覆盖欲修改的映射元素。比如：

```go
package main

import "fmt"

func main() {
	type T struct{age int}
	mt := map[string]T{}
	mt["John"] = T{age: 29}
	ma := map[int][5]int{}
	ma[1] = [5]int{1: 789}

	t := mt["John"] // 临时变量
	t.age = 30
	mt["John"] = t // 整体修改

	a := ma[1] // 临时变量
	a[1] = 123
	ma[1] = a // 整体修改

	fmt.Println(ma[1][1], mt["John"].age) // 123 30
}
```

注意：刚提到的这个限制[可能会在以后被移除](https://github.com/golang/go/issues/3117)。



### 从数组或者切片派生切片（取子切片）

我们可以从一个基础切片或者一个可寻址的基础数组派生出另一个切片。此派生操作也常称为一个取子切片操作。 派生出来的切片的元素和基础切片（或者数组）的元素位于同一个内存片段上。或者说，派生出来的切片和基础切片（或者数组）将共享一些元素。

Go中有两种取子切片的语法形式（假设`baseContainer`是一个切片或者数组）：

```go
baseContainer[low : high]       // 双下标形式
baseContainer[low : high : max] // 三下标形式
```

上面所示的双下标形式等价于下面的三下标形式：

```go
baseContainer[low : high : cap(baseContainer)]
```

所以双下标形式是三下标形式的特例。在实践中，双下标形式使用得相对更为广泛。

（注意：三下标形式是从Go 1.2开始支持的。）

上面所示的取子切片表达式的语法形式中的下标必须满足下列关系，否则代码要么编译不通过，要么在运行时刻将造成恐慌。

```go
// 双下标形式
0 <= low <= high <= cap(baseContainer)

// 三下标形式
0 <= low <= high <= max <= cap(baseContainer)
```

不满足上述关系的取子切片表达式要么编译不通过，要么在运行时刻将导致一个恐慌。

注意：

- 只要上述关系均满足，下标`low`和`high`都可以大于`len(baseContainer)`。但是它们一定不能大于`cap(baseContainer)`。
- 如果`baseContainer`是一个零值nil切片，只要上面所示的子切片表达式中下标的值均为`0`，则这两个子切片表达式不会造成恐慌。 在这种情况下，结果切片也是一个nil切片。

子切片表达式的结果切片的长度为`high - low`、容量为`max - low`。 派生出来的结果切片的长度可能大于基础切片的长度，但结果切片的容量绝不可能大于基础切片的容量。

在实践中，我们常常在子切片表达式中省略若干下标，以使代码看上去更加简洁。省略规则如下：

- 如果下标`low`为零，则它可被省略。此条规则同时适用于双下标形式和三下标形式。
- 如果下标`high`等于`len(baseContainer)`，则它可被省略。此条规则同时只适用于双下标形式。
- 三下标形式中的下标`max`在任何情况下都不可被省略。

比如，下面的子切片表达式都是相互等价的：

```go
baseContainer[0 : len(baseContainer)]
baseContainer[: len(baseContainer)]
baseContainer[0 :]
baseContainer[:]
baseContainer[0 : len(baseContainer) : cap(baseContainer)]
baseContainer[: len(baseContainer) : cap(baseContainer)]
```

一个使用了子切片语法的例子：

```go
package main

import "fmt"

func main() {
	a := [...]int{0, 1, 2, 3, 4, 5, 6}
	s0 := a[:]     // <=> s0 := a[0:7:7]
	s1 := s0[:]    // <=> s1 := s0
	s2 := s1[1:3]  // <=> s2 := a[1:3]
	s3 := s1[3:]   // <=> s3 := s1[3:7]
	s4 := s0[3:5]  // <=> s4 := s0[3:5:7]
	s5 := s4[:2:2] // <=> s5 := s0[3:5:5]
	s6 := append(s4, 77)
	s7 := append(s5, 88)
	s8 := append(s7, 66)
	s3[1] = 99
	fmt.Println(len(s2), cap(s2), s2) // 2 6 [1 2]
	fmt.Println(len(s3), cap(s3), s3) // 4 4 [3 99 77 6]
	fmt.Println(len(s4), cap(s4), s4) // 2 4 [3 99]
	fmt.Println(len(s5), cap(s5), s5) // 2 2 [3 99]
	fmt.Println(len(s6), cap(s6), s6) // 3 4 [3 99 77]
	fmt.Println(len(s7), cap(s7), s7) // 3 4 [3 4 88]
	fmt.Println(len(s8), cap(s8), s8) // 4 4 [3 4 88 66]
}
```



下面这张图描绘了上面的程序在退出之前各个数组和切片的状态。

![数字和切片状态](https://gfw.go101.org/article/res/slice-subslice-2.png)

从这张图片可以看出，切片`s7`和`s8`共享存储它们的元素的底层内存片段，其它切片和数组`a`共享同一个存储元素的内存片段。

请注意，子切片操作有可能会造成暂时性的内存泄露。 比如，下面在这个函数中开辟的内存块中的前50个元素槽位在它的调用返回之后将不再可见。 这50个元素槽位所占内存浪费了，这属于暂时性的内存泄露。 当这个函数中开辟的内存块今后不再被任何切片所引用，此内存块将被回收，这时内存才不再继续泄漏。

```go
func f() []int {
	s := make([]int, 10, 100)
	return s[50:60]
}
```

请注意，在上面这个函数中，子切片表达式中的起始下标（`50`）比`s`的长度（`10`）要大，这是允许的。



### 切片转化为数组指针

从Go 1.17开始，一个切片可以被转化为一个相同元素类型的数组的指针类型。 但是如果数组的长度大于被转化切片的长度，则将导致恐慌产生。 转换结果和被转化切片将共享底层元素。 一个例子：

```go
package main

type S []int
type A [2]int
type P *A

func main() {
	var x []int
	var y = make([]int, 0)
	var x0 = (*[0]int)(x) // okay, x0 == nil
	var y0 = (*[0]int)(y) // okay, y0 != nil
	_, _ = x0, y0

	var z = make([]int, 3, 5)
	var _ = (*[3]int)(z) // okay
	var _ = (*[2]int)(z) // okay
	var _ = (*A)(z)      // okay
	var _ = P(z)         // okay

	var w = S(z)
	var _ = (*[3]int)(w) // okay
	var _ = (*[2]int)(w) // okay
	var _ = (*A)(w)      // okay
	var _ = P(w)         // okay

	var _ = (*[4]int)(z) // 会产生恐慌
}
```



### 切片转化为数组

从Go 1.20开始，一个切片可以被转化为一个相同元素类型的数组。 但是如果数组的长度大于被转化切片的长度，则将导致恐慌产生。 转换过程中将复制所需的元素，因此结果数组和被转化切片不共享底层元素。 一个例子：

```go
package main

import "fmt"

func main() {
	var s = []int{0, 1, 2, 3}
	var a = [3]int(s[1:])
	s[2] = 9
	fmt.Println(s) // [0 1 9 3]
	fmt.Println(a) // [1 2 3]
	
	_ = [3]int(s[:2]) // panic
}
```



### 使用内置`copy`函数来复制切片元素

我们可以使用内置`copy`函数来将一个切片中的元素复制到另一个切片。 这两个切片的类型可以不同，但是它们的元素类型必须相同。 换句话说，这两个切片的类型的底层类型必须相同。 `copy`函数的第一个参数为目标切片，第二个参数为源切片。 传递给一个`copy`函数调用的两个实参可以共享一些底层元素。 `copy`函数返回复制了多少个元素，此值（`int`类型）为这两个切片的长度的较小值。

结合上一节介绍的子切片语法，我们可以使用`copy`函数来在两个数组之间或者一个数组与一个切片之间复制元素。

一个例子：

```go
package main

import "fmt"

func main() {
	type Ta []int
	type Tb []int
	dest := Ta{1, 2, 3}
	src := Tb{5, 6, 7, 8, 9}
	n := copy(dest, src)
	fmt.Println(n, dest) // 3 [5 6 7]
	n = copy(dest[1:], dest)
	fmt.Println(n, dest) // 2 [5 5 6]

	a := [4]int{} // 一个数组
	n = copy(a[:], src)
	fmt.Println(n, a) // 4 [5 6 7 8]
	n = copy(a[:], a[2:])
	fmt.Println(n, a) // 2 [7 8 7 8]
}
```



注意，做为一个特例，`copy`函数可以用来[将一个字符串中的字节复制到一个字节切片](https://gfw.go101.org/article/string.html#use-string-as-byte-slice)。

截至目前（Go 1.21），`copy`函数调用的两个实参均不能为类型不确定的`nil`。



### 遍历容器元素

在Go中，我们可以使用下面的语法形式来遍历一个容器中的键值和元素：

```go
for key, element = range aContainer {
	// 使用key和element ...
}
```

在此语法形式中，`for`和`range`为两个关键字，`key`和`element`称为循环变量。 如果`aContainer`是一个切片或者数组（或者数组指针，见后），则`key`的类型必须为内置类型`int`。

上面所示的`for-range`语法形式中的等号`=`也可以是一个变量短声明符号`:=`。 当短声明符号被使用的时候，`key`和`element`总是两个新声明的变量，这时如果`aContainer`是一个切片或者数组（或者数组指针），则`key`的类型被推断为内置类型`int`。

和传统的`for`循环流程控制一样，每个`for-range`循环流程控制形成了两个代码块，其中一个是隐式的，另一个是显式的（花括号`之间`的部分）。 此显式的代码块内嵌在隐式的代码块之中。

和`for`循环流程控制一样，`break`和`continue`也可以使用在一个`for-range`循环流程控制中的显式代码块中。

一个例子：

```go
package main

import "fmt"

func main() {
	m := map[string]int{"C": 1972, "C++": 1983, "Go": 2009}
	for lang, year := range m {
		fmt.Printf("%v: %v \n", lang, year)
	}

	a := [...]int{2, 3, 5, 7, 11}
	for i, prime := range a {
		fmt.Printf("%v: %v \n", i, prime)
	}

	s := []string{"go", "defer", "goto", "var"}
	for i, keyword := range s {
		fmt.Printf("%v: %v \n", i, keyword)
	}
}
```



`for-range`循环代码块有一些变种形式：

```go
// 忽略键值循环变量。
for _, element = range aContainer {
	// ...
}

// 忽略元素循环变量。
for key, _ = range aContainer {
	element = aContainer[key]
	// ...
}

// 舍弃元素循环变量。此形式和上一个变种等价。
for key = range aContainer {
	element = aContainer[key]
	// ...
}

// 键值和元素循环变量均被忽略。
for _, _ = range aContainer {
	// 这个变种形式没有太大实用价值。
}

// 键值和元素循环变量均被舍弃。此形式和上一个变种等价。
for range aContainer {
	// 这个变种形式没有太大实用价值。
}
```

遍历一个nil映射或者nil切片是允许的。这样的遍历可以看作是一个空操作。

一些关于遍历映射条目的细节：

- 映射中的条目的遍历顺序是不确定的（可以认为是随机的）。或者说，同一个映射中的条目的两次遍历中，条目的顺序很可能是不一致的，即使在这两次遍历之间，此映射并未发生任何改变。
- 如果在一个映射中的条目的遍历过程中，一个还没有被遍历到的条目被删除了，则此条目保证不会被遍历出来。
- 如果在一个映射中的条目的遍历过程中，一个新的条目被添加入此映射，则此条目并不保证将在此遍历过程中被遍历出来。

如果可以确保没有其它协程操纵一个映射`m`，则下面的代码保证将清空`m`中所有条目（除了那些键值为`NaN`的条目）。

```go
for key := range m {
	delete(m, key)
}
```

*（Go 1.21引入了一个[`clear`内置函数](https://gfw.go101.org/article/container.html#clear)，此函数可以用来清空一个映射中所有条目，包括那些键值为`NaN`的条目。）*



当然，数组和切片元素也可以用传统的`for`循环来遍历。

```go
for i := 0; i < len(anArrayOrSlice); i++ {
	// ... 使用 anArrayOrSlice[i]
}
```



对一个`for-range`循环代码块（不论在`range`前面的是`=`还是`:=`）

```go
for key, element = range aContainer {...}
```

有两个重要的事实存在：

1. 被遍历的容器值是

   ```
   aContainer
   ```

   的

   一个副本

   。 注意，

   只有`aContainer`的直接部分被复制了

   。 此副本是一个匿名的值，所以它是不可被修改的。

   - 如果`aContainer`是一个数组，那么在遍历过程中对此数组元素的修改不会体现到循环变量中。 原因是此数组的副本（被真正遍历的容器）和此数组不共享任何元素。
   - 如果`aContainer`是一个切片（或者映射），那么在遍历过程中对此切片（或者映射）元素的修改将体现到循环变量中。 原因是此切片（或者映射）的副本和此切片（或者映射）共享元素（或条目）。

2. 在遍历中的每个循环步，`aContainer`副本中的一个键值元素对将被赋值（复制）给循环变量。 所以对循环变量的直接部分的修改将不会体现在`aContainer`中的对应元素中。 （因为这个原因，并且`for-range`循环是遍历映射条目的唯一途径，所以最好不要使用大尺寸的映射键值和元素类型，以避免较大的复制负担。）

下面这个例子验证了上述两个事实。

```go
package main

import "fmt"

func main() {
	type Person struct {
		name string
		age  int
	}
	persons := [2]Person {{"Alice", 28}, {"Bob", 25}}
	for i, p := range persons {
		fmt.Println(i, p)
		// 此修改将不会体现在这个遍历过程中，
		// 因为被遍历的数组是persons的一个副本。
		persons[1].name = "Jack"

		// 此修改不会反映到persons数组中，因为p
		// 是persons数组的副本中的一个元素的副本。
		p.age = 31
	}
	fmt.Println("persons:", &persons)
}
```

输出结果：

```
0 {Alice 28}
1 {Bob 25}
persons: &[{Alice 28} {Jack 25}]
```



如果我们将上例中的数组改为一个切片，则在循环中对此切片的修改将在循环过程中体现出来。 但是对循环变量的修改仍然不会体现在此切片中。

```go
...

	// 数组改为切片
	persons := []Person {{"Alice", 28}, {"Bob", 25}}
	for i, p := range persons {
		fmt.Println(i, p)
		// 这次，此修改将反映在此次遍历过程中。
		persons[1].name = "Jack"
		// 这个修改仍然不会体现在persons切片容器中。
		p.age = 31
	}
	fmt.Println("persons:", &persons)
}
```

输出结果变成了：

```
0 {Alice 28}
1 {Jack 25}
persons: &[{Alice 28} {Jack 25}]
```



下面这个例子验证了上述第二个事实。

```go
package main

import "fmt"

func main() {
	m := map[int]struct{ dynamic, strong bool } {
		0: {true, false},
		1: {false, true},
		2: {false, false},
	}
	
	for _, v := range m {
		// This following line has no effects on the map m.
		v.dynamic, v.strong = true, true
	}
	
	fmt.Println(m[0]) // {true false}
	fmt.Println(m[1]) // {false true}
	fmt.Println(m[2]) // {false false}
}
```



复制一个切片或者映射的代价很小，但是复制一个大尺寸的数组的代价比较大。 所以，一般来说，`range`关键字后跟随一个大尺寸数组不是一个好主意。 如果我们要遍历一个大尺寸数组中的元素，我们以遍历从此数组派生出来的一个切片，或者遍历一个指向此数组的指针（详见下一节）。

对于一个数组或者切片，如果它的元素类型的尺寸较大，则一般来说，用第二个循环变量来存储每个循环步中被遍历的元素不是一个好主意。 对于这样的数组或者切片，我们最好忽略或者舍弃`for-range`代码块中的第二个循环变量，或者使用传统的`for`循环来遍历元素。 比如，在下面这个例子中，函数`fa`中的循环效率比函数`fb`中的循环低得多。

```go
type Buffer struct {
	start, end int
	data       [1024]byte
}

func fa(buffers []Buffer) int {
	numUnreads := 0
	for _, buf := range buffers {
		numUnreads += buf.end - buf.start
	}
	return numUnreads
}

func fb(buffers []Buffer) int {
	numUnreads := 0
	for i := range buffers {
		numUnreads += buffers[i].end - buffers[i].start
	}
	return numUnreads
}
```



在Go 1.22之前，对一个如下`for-range`循环代码块（注意`range`前面是`:=`）

```go
for key, element := range aContainer {...}
```

所有被遍历的键值元素对将被赋值给**同一对**循环变量实例。 但是从Go 1.22版本开始，每组键值元素对将被赋值给一对**与众不同**的循环变量实例（既循环变量在每个循环步都会生成一份新的实例）。



下面这个例子展示了Go 1.21-和Go 1.22+之间的行为差异。

```go
// forrange1.go
package main

import "fmt"

func main() {
	for i, n := range []int{0, 1, 2} {
		defer func() {
			fmt.Println(i, n)
		}()
	}
}
```

使用不同版本的Go编译器运行之（[gotv](https://gfw.go101.org/apps-and-libs/gotv.html)是一个管理运行多个Go工具链版本的工具；未来的Go 1.22版本将来从tip版本开出来），将得到不同的输出：

```go
$ gotv 1.21. run forrange1.go
[Run]: $HOME/.cache/gotv/tag_go1.21.2/bin/go run forrange1.go
2 3
2 3
2 3
$ gotv :tip run forrange1.go
[Run]: $HOME/.cache/gotv/bra_master/bin/go run forrange1.go
2 3
1 2
0 1
```



另一个例子：

```go
// forrange2.go
package main

import "fmt"

func main() {
	var m = map[*int]uint32{}
	for i, n := range []int{1, 2, 3} {
		m[&i]++
		m[&n]++
	}
	fmt.Println(len(m))
}
```

使用不同版本的Go编译器运行之，得到如下输出：

```go
$ gotv 1.21. run forrange2.go
[Run]: $HOME/.cache/gotv/tag_go1.21.2/bin/go run forrange2.go
2
$ gotv :tip run forrange2.go
[Run]: $HOME/.cache/gotv/bra_master/bin/go run forrange2.go
6
```

因此，这是一个破坏了向后兼容性的语义改变。 但是新的语义更符合人们的直觉；并且从理论上，到目前还没有发现旧的在逻辑上正确的代码因为此改变而导致行为变化的情况。



### 把数组指针当做数组来使用

对于某些情形，我们可以把数组指针当做数组来使用。

我们可以通过在`range`关键字后跟随一个数组的指针来遍历此数组中的元素。 对于大尺寸的数组，这种方法比较高效，因为复制一个指针比复制一个大尺寸数组的代价低得多。 下面的例子中的两个循环是等价的，它们的效率也基本相同。

```go
package main

import "fmt"

func main() {
	var a [100]int

	for i, n := range &a { // 复制一个指针的开销很小
		fmt.Println(i, n)
	}

	for i, n := range a[:] { // 复制一个切片的开销很小
		fmt.Println(i, n)
	}
}
```



如果一个`for-range`循环中的第二个循环变量既没有被忽略，也没有被舍弃，并且`range`关键字后跟随一个nil数组指针，则此循环将造成一个恐慌。 在下面这个例子中，前两个循环都将打印出5个下标，但最后一个循环将导致一个恐慌。

```go
package main

import "fmt"

func main() {
	var p *[5]int // nil

	for i, _ := range p { // okay
		fmt.Println(i)
	}

	for i := range p { // okay
		fmt.Println(i)
	}

	for i, n := range p { // panic
		fmt.Println(i, n)
	}
}
```



我们可以通过数组的指针来访问和修改此数组中的元素。如果此指针是一个nil指针，将导致一个恐慌。

```go
package main

import "fmt"

func main() {
	a := [5]int{2, 3, 5, 7, 11}
	p := &a
	p[0], p[1] = 17, 19
	fmt.Println(a) // [17 19 5 7 11]
	p = nil
	_ = p[0] // panic
}
```



我们可以从一个数组的指针派生出一个切片。从一个nil数组指针派生切片将导致一个恐慌。

```go
package main

import "fmt"

func main() {
	pa := &[5]int{2, 3, 5, 7, 11}
	s := pa[1:3]
	fmt.Println(s) // [3 5]
	pa = nil
	s = pa[0:0] // panic
	// 如果下一行能被执行到，则它也会产生恐慌。
	_ = (*[0]byte)(nil)[:]
}
```



内置`len`和`cap`函数调用接受数组指针做为实参。 nil数组指针实参不会导致恐慌。

```go
var pa *[5]int // == nil
fmt.Println(len(pa), cap(pa)) // 5 5
```





### `memclr`优化

假设`t0`是一个类型`T`的零值字面量，并且`a`是一个元素类型为`T`的数组或者切片，则官方标准编译器将把下面的单循环变量`for-range`代码块优化为一个[内部的`memclr`调用](https://github.com/golang/go/issues/5373)。 大多数情况下，此`memclr`调用比一个一个地重置元素要快。

```go
for i := range a {
	a[i] = t0
}
```

此优化在官方标准编译器1.5版本中被引入。

从官方Go工具链1.19开始，此优化也适用于`a`为一个数组指针的情形。

注意：Go 1.21引入了一个`clear`内置函数，用来清空一个映射中的所有条目或者重置一个切片中的所有元素。 我们应该尽量使用此内置函数而不是依赖于此`memclr`优化来重置切片或者数组的元素。 `clear`内置函数见下一节。



### 使用内置`clear`函数来清空映射条目或者重置切片元素

Go 1.21引入了一个`clear`内置函数。 此函数可以用来清空映射条目或者重置切片元素。

一个例子：

```go
package main

import "fmt"

func main() {
	s := []int{1, 2, 3}
	clear(s)
	fmt.Println(s) // [0 0 0]
	
	a := [4]int{5, 6, 7, 8}
	clear(a[1:3])
	fmt.Println(a) // [5 0 0 8]
	
	m := map[float64]float64{}
	x := 0.0
	m[x] = x
	x /= x // x变成了NaN
	m[x] = x
	fmt.Println(len(m)) // 2
	for k := range m {
		delete(m, k)
	}
	fmt.Println(len(m)) // 1
	clear(m)
	fmt.Println(len(m)) // 0
}
```

从上例中，我们可以发现此`clear`函数甚至可以清除那些键值为`NaN`的映射条目.



### 内置函数`len`和`cap`的调用可能会在编译时刻被估值

如果传递给内置函数`len`或者`cap`的一个调用的实参是一个数组或者数组指针，则此调用将在编译时刻被估值。 此估值结果是一个类型为内置类型`int`的类型确定常量值。

一个例子：

```go
package main

import "fmt"

var a [5]int
var p *[7]string

// N和M都是类型为int的类型确定值。
const N = len(a)
const M = cap(p)

func main() {
	fmt.Println(N) // 5
	fmt.Println(M) // 7
}
```





### 单独修改一个切片的长度或者容量

上面已经提到了，一般来说，一个切片的长度和容量不能被单独修改。一个切片只有通过赋值的方式被整体修改。 但是，事实上，我们可以通过反射的途径来单独修改一个切片的长度或者容量。 反射将在[后面的一篇文章](https://gfw.go101.org/article/reflection.html)中详解。

一个例子：

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	s := make([]int, 2, 6)
	fmt.Println(len(s), cap(s)) // 2 6

	reflect.ValueOf(&s).Elem().SetLen(3)
	fmt.Println(len(s), cap(s)) // 3 6

	reflect.ValueOf(&s).Elem().SetCap(5)
	fmt.Println(len(s), cap(s)) // 3 5
}
```

传递给函数`reflect.SetLen`调用的第二个实参值必须不大于第一个实参切片值的容量。 传递给函数`reflect.SetCap`调用的第二个实参值必须不小于第一个实参切片值的长度并且须不大于第一个实参切片值的容量。 否则，在运行时刻将产生一个恐慌。

此反射方法的效率很低，远低于一个切片的赋值。



### 更多切片操作

Go不支持更多的内置切片操作，比如切片克隆、元素删除和插入。 我们必须用上面提到的各种内置操作来实现这些操作。

在下面当前大节中的例子中，假设`s`是被谈到的切片、`T`是它的元素类型、`t0`是类型`T`的零值字面量。

#### 切片克隆

对于当前的Go版本（1.21），最简单的克隆一个切片的方法为：

```go
sClone := append(s[:0:0], s...)
```

我们也可以使用下面这种实现。但是和上面这个实现相比，它有一个不完美之处：如果源切片`s`是一个空切片（但是非nil），则结果切片是一个nil切片。

```go
sClone := append([]T(nil), s...)
```

上面这两种append实现都有一个缺点：它们开辟的内存块常常会比需要的略大一些从而可能造成一点小小的不必要的性能损失。 我们可以使用这两种方法来避免这个缺点：

```go
// 两行make+copy实现：
sClone := make([]T, len(s))
copy(sClone, s)

// 或者下面的make+append实现。
// 对于目前的官方Go工具链1.21版本来说，
// 这种实现比上面的make+copy实现略慢一点。
sClone := append(make([]T, 0, len(s)), s...)
```



上面这两种make方法都有一个缺点：如果`s`是一个nil切片，则使用此方法将得到一个非nil切片。 不过，在编程实践中，我们常常并不需要追求克隆的完美性。如果我们确实需要，则需要多写几行：

```go
var sClone []T
if s != nil {
	sClone = make([]T, len(s))
	copy(sClone, s)
}
```





#### 删除一段切片元素

前面已经提到了切片的元素在内存中是连续存储的，相邻元素之间是没有间隙的。所以，当切片的一个元素段被删除时，

- 如果剩余元素的次序必须保持原样，则被删除的元素段后面的每个元素都得前移。
- 如果剩余元素的次序不需要保持原样，则我们可以将尾部的一些元素移到被删除的元素的位置上。

在下面的例子中，假设`from`（包括）和`to`（不包括）是两个合法的下标，并且`from`不大于`to`。

```go
// 第一种方法（保持剩余元素的次序）：
s = append(s[:from], s[to:]...)

// 第二种方法（保持剩余元素的次序）：
s = s[:from + copy(s[from:], s[to:])]

// 第三种方法（不保持剩余元素的次序）：
if n := to-from; len(s)-to < n {
	copy(s[from:to], s[to:])
} else {
	copy(s[from:to], s[len(s)-n:])
}
s = s[:len(s)-(to-from)]
```

如果切片的元素可能引用着其它值，则我们应该重置因为删除元素而多出来的元素槽位上的元素值，以避免暂时性的内存泄露：

```go
// "len(s)+to-from"是删除操作之前切片s的长度。
temp := s[len(s):len(s)+to-from]
for i := range temp {
	temp[i] = t0 // t0是类型T的零值字面量
}
```

前面已经提到了，上面这个`for-range`循环将被官方标准编译器优化为一个`memclr`调用。



#### 删除一个元素

删除一个元素是删除一个元素段的特例。在实现上可以简化一些。

在下面的例子中，假设`i`将被删除的元素的下标，并且它是一个合法的下标。

```go
// 第一种方法（保持剩余元素的次序）：
s = append(s[:i], s[i+1:]...)

// 第二种方法（保持剩余元素的次序）：
s = s[:i + copy(s[i:], s[i+1:])]

// 上面两种方法都需要复制len(s)-i-1个元素。

// 第三种方法（不保持剩余元素的次序）：
s[i] = s[len(s)-1]
s = s[:len(s)-1]
```



如果切片的元素可能引用着其它值，则我们应该重置刚多出来的元素槽位上的元素值，以避免暂时性的内存泄露：

```go
s[len(s):len(s)+1][0] = t0
// 或者
s[:len(s)+1][len(s)] = t0
```



#### 条件性地删除切片元素

有时，我们需要删除满足某些条件的切片元素。

```go
// 假设T是一个小尺寸类型。
func DeleteElements(s []T, keep func(T) bool, clear bool) []T {
	// result := make([]T, 0, len(s))
	result := s[:0] // 无须开辟内存
	for _, v := range s {
		if keep(v) {
			result = append(result, v)
		}
	}
	if clear { // 避免暂时性的内存泄露。
		temp := s[len(result):]
		for i := range temp {
			temp[i] = t0 // t0是类型T的零值
		}
	}
	return result
}
```

注意：如果`T`是一个大尺寸类型，请[慎用](https://gfw.go101.org/article/value-copy-cost.html#copy-costs)`T`做为参数类型和使用双循环变量`for-range`代码块遍历元素类型为`T`的切片。

#### 将一个切片中的所有元素插入到另一个切片中

假设插入位置`i`是一个合法的下标并且切片`elements`中的元素将被插入到另一个切片`s`中。

```go
// 第一种方法:单行实现。
s = append(s[:i], append(elements, s[i:]...)...)

// 上面这种单行实现把s[i:]中的元素复制了两次，并且它可能
// 最多导致两次内存开辟（最少一次）。
// 下面这种繁琐的实现只把s[i:]中的元素复制了一次，并且
// 它最多只会导致一次内存开辟（最少零次）。
// 但是，在当前的官方标准编译器实现中（1.21版本），此
// 繁琐实现中的make调用将会把部分刚开辟出来的元素清零。
// 这其实是没有必要的。所以此繁琐实现并非总是比上面的
// 单行实现效率更高。事实上，它仅在处理小切片时更高效。

if cap(s) >= len(s) + len(elements) {
	s = s[:len(s)+len(elements)]
	copy(s[i+len(elements):], s[i:])
	copy(s[i:], elements)
} else {
	x := make([]T, 0, len(elements)+len(s))
	x = append(x, s[:i]...)
	x = append(x, elements...)
	x = append(x, s[i:]...)
	s = x
}

// Push（插入到结尾）。
s = append(s, elements...)

// Unshift（插入到开头）。
s = append(elements, s...)
```



#### 插入若干独立的元素

插入若干独立的元素和插入一个切片中的所有元素类似。 我们可以使用切片组合字面量构建一个临时切片，然后使用上面的方法插入这些元素。

#### 特殊的插入和删除：前推/后推，前弹出/后弹出

假设被推入和弹出的元素为`e`并且切片`s`拥有至少一个元素。

```go
// 前弹出（pop front，又称shift）
s, e = s[1:], s[0]
// 后弹出（pop back）
s, e = s[:len(s)-1], s[len(s)-1]
// 前推（push front）
s = append([]T{e}, s...)
// 后推（push back）
s = append(s, e)
```

请注意：使用`append`函数来插入元素常常是比较低效的，因为插入点后的所有元素都要向后挪，并且当空余容量不足时还需要开辟一个更大的内存空间来容纳插入完成后所有的元素。 对于元素个数不多的切片来说，这些可能并不是严重的问题；但是在元素个数很多的切片上进行如上的插入操作常常是耗时的。所以如果元素个数很多，最好使用链表来实现元素插入操作。

#### 关于上面各种切片操控的例子

在实践中，需求是各种各样的。对于某些特定的情形，上面的例子中的代码实现可能并非是最优化的，甚至是不满足要求的。 所以，请在实践中根据具体情况来实现代码。或许，这就是Go没有支持更多的内置切片操作的原因。

### 用映射来模拟集合（set）

Go不支持内置集合（**set**）类型。但是，集合类型可以用轻松使用映射类型来模拟。 在实践中，我们常常使用映射类型`map[K]struct{}`来模拟一个元素类型为`K`的集合类型。 类型`struct{}`的尺寸为零，所以此映射类型的值中的元素不消耗内存。

### 上述各种容器操作内部都未同步

请注意，上述所有各种容器操作的内部实现都未进行同步。如果不使用今后将要介绍的各种并发同步技术，在没有协程修改一个容器值和它的元素的时候，多个协程并发读取此容器值和它的元素是安全的。但是并发修改同一个容器值则是不安全的。 不使用并发同步技术而并发修改同一个容器值将会造成数据竞争。请阅读以后的[并发同步概述](https://gfw.go101.org/article/concurrent-synchronization-overview.html)一文以了解Go支持的各种并发同步技术。

------



