# Go - [基础篇]

## Go官方工具链

介绍如何配置Go开发环境和如何使用Go官方工具链中提供的`go`命令

### 安装Go官方工具

[Go官方网站](https://go.dev/doc/install)下载Go官方工具链 :)

> 为了从任意目录运行Go官方工具链中工具命令（通过`go`命令）， Go官方工具链安装目录下的`bin`子目录路径必须配置在`PATH`环境变量中

Go官方工具链近来的版本均支持一个称为Go模块（Go modules）的特性，用来管理项目依赖（更多请了解[go mod说明](./go mod说明.md)）

> 从版本1.16开始被默认支持Go mod

了解环境变量：`GOPATH`

此环境变量的默认值为当前用户的HOME目录下的名为`go`文件夹对应的目录路径。 `GOPATH`环境变量可以被手动地配置多个路径。 以后，当`GOPATH`文件夹被提及的时候，它表示`GOPATH`环境变量中的第一个路径对应的文件夹

* `GOPATH`文件夹中的`pkg`子文件夹用来缓存被本地项目所依赖的Go模块（一个Go模块为若干Go库包的集合）的版本

了解环境变量：`GOBIN`

此环境变量用来指定`go install`子命令产生的Go应用程序二进制可执行文件应该存储在何处。 它的默认值为`GOPATH`文件夹中的`bin`子目录所对应的目录路径。 `GOBIN`路径需配置在`PATH`环境变量中，以便从任意目录运行这些Go应用程序

### 运行一个Go程序

最简单的一个Go程序

```go
package main

func main() {
}
```

> 在此程序中，单词`package`和`func`是两个关键字。 两个`main`是两个标识符
>
> 此程序的第一行指定了当前源代码文件所处的包的包名（此处为`main`）。 第二行是一个空行，用来增强可读性。 第三和第四行声明了一个名为`main`的函数。 此函数为程序的入口函数

Go官方工具链工具要求所有的Go源代码文件必须以`.go`后缀结尾。

假设上面展示的最简单的Go程序存放在一个名叫`simplest-go-program.go`的文件中

打开一个终端（控制台）并进入上述源文件所在的目录，然后运行

```bash
go run simplest-go-program.go
```

如果一个程序的`main`包中有若干Go源代码文件，我们也可以使用下面的命令运行此程序

```bash
go run .
```

注：

* `go run`子命令并不推荐在正式的大项目中使用

* `go run`子命令只是一种方便的方式来运行简单的Go程序
* 对于正式的项目，最好使用`go build`或者`go install`子命令构建可执行程序文件来运行Go程序

支持Go模块特性的Go项目的**根目录下**需要一个`go.mod`文件。此文件可以使用`go mod init`子命令来生成

名称以`_`和`.`开头的源代码文件将被Go官方工具链工具忽略掉

### 更多go子命令

`go run`、`go build`和`go install`构建可执行程序文件来运行Go程序，只会输出代码语法错误

`go vet`子命令可以用来检查可能的代码逻辑错误（即警告）

`go fmt`子命令用同一种代码风格格式化Go代码

`go test`子命令运行单元和基准测试用例

`go doc`子命令（在终端中）查看Go代码库包的文档

让你的Go项目支持Go模块特性来简化依赖管理：

* `go mod init example.com/myproject`命令可以用来在当前目录中生成一个`go.mod`文件。 当前目录将被视为一个名为`example.com/myproject`的模块（即当前项目）的**根目录**。 此`go.mod`文件将被用来记录当前项目需要的依赖模块和版本信息。 我们可以手动编辑或者使用`go`子命令来修改此文件
* `go mod tidy`命令用来通过扫描当前项目中的所有代码来**添加**未被记录的依赖至`go.mod`文件或从`go.mod`文件中**删除**不再被使用的依赖
* `go get`命令用拉添加、升级、降级或者删除单个依赖

从Go官方工具链1.16版本开始，我们可以运行`go install example.com/program@latest`来安装一个第三方Go程序的最新版本（至`GOBIN`目录）

`go help aSubCommand`来查看一个子命令`aSubCommand`的帮助信息

`go`命令将会列出所有支持的`go`子命令

更多go命令请在[go命令官网]((https://golang.google.cn/cmd/go/))查看 :)

### 查看Go标准库文档

请查看Go官方文档库：[Standard library - Go Packages](https://pkg.go.dev/std) :)

------



## 程序源代码基本元素介绍

将介绍编程中常用的代码元素，并展示一份简单的Go程序代码

### 编程和程序代码元素

编程可以看作是以各种方式控制和组合计算机运行中的各种操作，以达到各种各样的目的

一个操作可能从一个硬件设备读取、或者向一个硬件设备写入一些数据，从而完成一个特定的任务

对于现代计算机来说，最基本的操作是底层计算机指令，比如CPU和GPU指令

直接操控底层计算机指令进行编程是非常繁琐和容易出错的

高级编程语言通过对底层指令进行一些封装和对数据进行一些抽象，从而使得编程变得直观和易于理解

一个操作通常是通过**函数**（function）调用或者使用**操作符**（operator）运算来完成的

数据通常被抽象为各种**类型**（type）和**值**（value）。 一个类型可以看作是值的模板。一个值可以看作是某个类型的实例

 一些在编码阶段可确定的值可以用它们的**字面形式**（literal，即字面量）来表示，其它的值一般使用**变量**（variable）和**（具名）常量**（named constant）来表示

具名的函数、具名的值（包括变量和具名常量）、以及定义类型和类型别名将被统称为**代码要素**。 代码要素名必须为**[标识符（identifier）](#关键字和标识符)**。

高级编程语言代码将被编译器或者解释器转换为底层机器码进行执行。 为了帮助编译器和解释器解析高级语言代码，一些单词将被用做**[关键字（keyword）](#关键字和标识符)**。 这些单词不能被当做标识符使用

很多现代高级语言使用**包**（package）来组织代码。 一个包必须**引入**（import）另一个包才能使用另一个包中的公有（导出的）代码要素。 包名和包的引入名也都必须是标识符

和很多其流行语言一样，Go使用`//`来起始一个行注释，使用一个`/*`和`*/`对来包裹一个块注释

### 一个简单的Go示例程序

让我们来看一个简短的Go示例程序

```go
package main // 指定当前源文件所在的包名

import "math/rand" // 引入一个标准库包

const MaxRand = 16 // 声明一个具名整型常量

// 一个函数声明
/*
 StatRandomNumbers生成一些不大于MaxRand的非负
 随机整数，并统计和返回小于和大于MaxRand/2的随机数
 个数。输入参数numRands指定了要生成的随机数的总数。
*/
func StatRandomNumbers(numRands int) (int, int) {
	// 声明了两个变量（类型都为int，初始值都为0）
	var a, b int
	// 一个for循环代码块
	for i := 0; i < numRands; i++ {
		// 一个if-else条件控制代码块
		if rand.Intn(MaxRand) < MaxRand/2 {
			a = a + 1
		} else {
			b++ // 等价于：b = b + 1
		}
	}
	return a, b // 此函数返回两个结果
}

// main函数，或主函数，是一个程序的入口函数。
func main() {
	var num = 100
	// 调用上面声明的StatRandomNumbers函数，
	// 并将结果赋给使用短声明语句声明的两个变量。
	x, y := StatRandomNumbers(num)
	// 调用两个内置函数（print和println）。
	print("Result: ", x, " + ", y, " = ", num, "? ")
	println(x+y == num)
}
```

将上面的程序代码存盘到一个名为`basic-code-element-demo.go` 的文件中并使用下列命令运行此程序：

```bash
$ go run basic-code-element-demo.go
Result: 46 + 54 = 100? true
```

在上面的示例程序中，单词`package`、`import`、`const`、`func`、`var`、`for`、`if`、`else`和`return`均为关键字。 其它大多数单词均为标识符

四个`int`（一个在第*15*行，另三个在第*13*行） 表示内置基本类型`int`。int类型是Go中的内置基本整数类型之一。 

第*5*行中的`16`、第*17*行中的`0`、 第*20*行中的`1`以及第*30*行的`100`均为整型字面量。 

第*35*行的`"Result: "`是一个字符串字面量

第*20*行是一个赋值语句。

第*5*行声明了一个具名常量，叫做`MaxRand`。 

第*15*行和第*30*行使用标准变量声明语句声明了三个变量。 

第*17*行的变量`i`以及第*33*行的变量`x`和`y`是使用变量短声明语句声明的。 

变量`a`和`b`在声明的时候被指定为`int`类型。 编译器会自动推导出变量`i`、`num`、`x`和`y`的类型均为`int`类型，因为它们的初始值都是整型字面量表示的

上面的示例程序中使用了很多操作符，比如第*17*和*19*行的小于比较符`<`，第*36*行的等于比较符`==`，还有第*20*和*36*行的加法运算符`+`。 第*35*行中的`+`不是一个运算符，它是一个字符串字面量中的一个字符。 一个使用操作符的操作中涉及到的值称为操作值（有时也可称为运算数）

第*35*和*36*行调用了两个内置函数`print`和`println`。 从第*13*行到第*26*行声明的函数`StatRandomNumbers`在第*33*行被调用。 第*19*行也调用了一个函数 `Intn`。 这个函数声明在`math/rand`标准库包中

第*1*行指定了当前源文件所处的包的名称。 一个Go程序的主函数（`main`函数）必须被声明在一个名称为`main`的包中。 第*3*行引入了`math/rand`标准库包，并以`rand`做为引入名。 在这个包中声明的`Intn`函数将在第*19*行被调用

此处列出了所有的简单语句类型。 在Go代码中，各种流程控制代码块中的某些部分必须为简单语句，某些部分必须为表达式

`StatRandomNumbers`函数的声明体中使用了两个流程控制代码块。 其中一个是`for`循环代码块，它内嵌了另外一个代码块。 另外一个代码块是一个`if-else`条件控制代码块

### 代码断行

像很多其它流行编程语言一样，Go也使用一对大括号`{` and `}`来形成一个显式代码块

但是在Go代码中，编码样式风格有一些限制。比如，很多左大括号`{`不能被放到下一行

我们最好避免将左大括号放在下一行。 或者说，每行的非空起始字符不能是左大括号

------



## 关键字和标识符

将介绍Go中的关键字和标识符

### 关键字

关键字是一些特殊的用来帮助编译器理解和解析源代码的单词

截至目前（Go 1.20），Go中共有25个关键字

```go
break     default      func    interface  select
case      defer        go      map        struct
chan      else         goto    package    switch
const     fallthrough  if      range      type
continue  for          import  return     var
```

这些关键字可以分为四组：

- `const`、`func`、`import`、`package`、`type`和`var`用来声明各种代码元素。
- `chan`、`interface`、`map`和`struct`用做 一些组合类型的字面表示中。
- `break`、`case`、`continue`、`default`、 `else`、`fallthrough`、`for`、 `goto`、`if`、`range`、 `return`、`select`和`switch`用在流程控制语句中。 详见[基本流程控制语法](#)。
- `defer`和`go`也可以看作是流程控制关键字， 但它们有一些特殊的作用。详见[协程和延迟函数调用](#)。

### 标识符

一个标识符是一个以Unicode字母或者`_`开头并且完全由Unicode字母和Unicode数字组成的单词

注意：**关键字不能被用做标识符**

标识符`_`是一个特殊字符，它叫做**空标识符**

所有的类型名、变量名、常量名、跳转标签、包名和包的引入名都必须是标识符

一个由Unicode大写字母开头的标识符称为**导出标识符**。 这里**导出**可以被理解为**公开**（public）

其它（即非Unicode大写字母开头的）标识符称为非导出标识符。 ***非导出***可以被理解为**私有**（private）

下面是一些合法的导出标识符：

```go
Player_9
DoSomething
VERSION
Ĝo
Π
```

下面是一些合法的未导出标识符：

```go
_
_status
memStat
book
π
一个类型
변수
エラー
```

下面这些不能被用做标识符：

```go
// Unicode数字开头
123
3apples

// 含有不符合要求的Unicode字符
a.b
*ptr
$name
a@b.c

// 这两个是关键字
type
range
```

------



## 基本类型和它们的字面量表示

类型（type）可以被看作是值（value）的模板，值可以被看作是类型的实例。将介绍内置（或称为预声明的）基本类型和它们字面量的表示形式。不介绍组合类型。

### 基本内置类型

Go支持如下内置基本类型：

- 一种内置布尔类型：`bool`。
- 11种内置整数类型：`int8`、`uint8`、`int16`、`uint16`、`int32`、`uint32`、`int64`、`uint64`、`int`、`uint`和`uintptr`。
- 两种内置浮点数类型：`float32`和`float64`。
- 两种内置复数类型：`complex64`和`complex128`。
- 一种内置字符串类型：`string`。

内置类型也称为预声明类型

这17种内置基本类型（type）各自属于一种Go中的类型种类（kind）。 尽管所有的内置基本类型的名称都是[非导出标识符](#identifier)， 我们可以不用引入任何代码包而直接使用这些类型

除了`bool`和`string`类型，其它的15种内置基本类型都称为数值类型（整型、浮点数型和复数型）

Go中有两种内置类型别名（type alias）：

- `byte`是`uint8`的内置别名。 我们可以将`byte`和`uint8`看作是同一个类型
- `rune`是`int32`的内置别名。 我们可以将`rune`和`int32`看作是同一个类型

以`u`开头的整数类型称为无符号整数类型。 无符号整数类型的值都是非负的。 一个数值类型名称中的数字表示每个这个类型的值将在内存中占有多少二进制位（以后简称位）。二进制位常称为比特（bit）。 比如，一个`uint8`的值将占有8位。 我们称`uint8`类型的值的尺寸是8位。 因此，最大的`uint8`值是`255`（28-1）， 最大的`int8`值是`127`（27-1）， 最小的`int8`值是`-128`（-27）。

任一个类型的所有值的尺寸都是相同的，所以一个值的尺寸也常称为它的类型的尺寸。

更多的时候，我们使用字节（byte）做为值尺寸的度量单位。 一个字节相当于8个比特。所以`uint32`类型的尺寸为4，即每个`uint32`值占用4个字节。

`uintptr`、`int`以及`uint`类型的值的尺寸依赖于具体编译器实现。 通常地，在64位的架构上，`int`和`uint`类型的值是64位的；在32位的架构上，它们是32位的。 编译器必须保证`uintptr`类型的值的尺寸能够存下任意一个内存地址。

一个`complex64`复数值的实部和虚部都是`float32`类型的值。 一个`complex128`复数值的实部和虚部都是`float64`类型的值

在内存中，所有的浮点数都使用**IEEE-754格式**存储

一个布尔值表示一个真假。在内存中，一个布尔值只有两种可能的状态。 这两种状态使用两个预声明（或称为内置）的常量（`false`和`true`）来表示

从逻辑上说，一个字符串值表示一段文本。 在内存中，一个字符串存储为一个字节（byte）序列。 此字节序列体现了此字符串所表示的文本的UTF-8编码形式

尽管布尔和字符串类型分类各自只有一种内置类型， 我们可以声明定义更多自定义布尔和字符串类型。 所以，Go代码中可以出现很多布尔和字符串类型（数值类型也同样）。 下面是一个类型声明的例子。 在这些例子中，`type`是一个关键字

```go
// 一些类型定义声明
type status bool     // status和bool是两个不同的类型
type MyString string // MyString和string是两个不同的类型
type Id uint64       // Id和uint64是两个不同的类型
type real float32    // real和float32是两个不同的类型

// 一些类型别名声明
type boolean = bool // boolean和bool表示同一个类型
type Text = string  // Text和string表示同一个类型
type U8 = uint8     // U8、uint8和 byte表示同一个类型
type char = rune    // char、rune和int32表示同一个类型
```

我们将上面定义的`real`类型和内置类型`float32`都称为float32类型 （注意这里的第二个float32是一个泛指，而第一个高亮的float32是一个特指）。 同样地，`MyString`和`string`都被称为字符串（string）类型，`status`和`bool`都被称为布尔（bool）类型。

### 零值

每种类型都有一个零值。一个类型的零值可以看作是此类型的默认值。

- 一个布尔类型的零值表示真假中的假。
- 数值类型的零值都是零（但是不同类型的零在内存中占用的空间可能不同）。
- 一个字符串类型的零值是一个空字符串。

### 基本类型的字面量表示形式

一个值的字面形式称为一个字面量，它表示此值在代码中文字体现形式（和内存中的表现形式相对应）。一个值可能会有很多种字面量形式。

#### 布尔值的字面量形式

Go白皮书没有定义布尔类型值字面量形式。 我们可以将`false`和`true`这两个预声明的具名常量当作布尔类型的字面量形式。 但是，我们应该知道，从严格意义上说，它们不属于字面量。

布尔类型的零值可以使用预声明的`false`来表示。

#### 整数类型值的字面量形式

整数类型值有四种字面量形式：十进制形式（decimal）、八进制形式（octal）、十六进制形式（hex）和二进制形式（binary）。比如，下面的三个字面量均表示十进制的15：

```go
0xF // 十六进制表示（必须使用0x或者0X开头）
0XF

017 // 八进制表示（必须使用0、0o或者0O开头）
0o17
0O17

0b1111 // 二进制表示（必须使用0b或者0B开头）
0B1111

15  // 十进制表示（必须不能用0开头）
```

整数类型的零值的字面量一般使用`0`表示。 当然，`00`和`0x0`等也是合法的整数类型零值的字面量形式

#### 浮点数类型值的字面量形式

一个浮点数的完整十进制字面量形式可能包含一个十进制整数部分、一个小数点、一个十进制小数部分和一个以10为底数的整数指数部分。 整数指数部分由字母`e`或者`E`带一个十进制的整数字面量组成（`xEn`表示`x`乘以`10n`的意思，而`xE-n`表示`x`除以`10n`的意思）。 常常地，某些部分可以根据情况省略掉。一些例子：

```go
1.23
01.23 // == 1.23
.23
1.
// 一个e或者E随后的数值是指数值（底数为10）。
// 指数值必须为一个可以带符号的十进制整数字面量。
1.23e2  // == 123.0
123E2   // == 12300.0
123.E+2 // == 12300.0
1e-1    // == 0.1
.1e0    // == 0.1
0010e-2 // == 0.1
0e+5    // == 0.0
```

从Go 1.13开始，Go也支持另一种浮点数字面量形式：十六进制浮点数字面量。 在一个十六进制浮点数字面量中，

- 一个十六进制浮点数字面量必须以一个以2为底数的整数指数部分。 这样的一个整数指数部分由字母`p`或者`P`带一个十进制的整数字面量组成（`yPn`表示`y`乘以`2n`的意思，而`yP-n`表示`y`除以`2n`的意思）。
- 和整数的十六进制字面量一样，一个十六进制浮点数字面量也必须使用`0x`或者`0X`开头。 和整数的十六进制字面量不同的是，一个十六进制浮点数字面量可以包括一个小数点和一个十六进制小数部分。

一些合法的浮点数的十六进制字面量例子：

```go
0x1p-2     // == 1.0/4 = 0.25
0x2.p10    // == 2.0 * 1024 == 2048.0
0x1.Fp+0   // == 1+15.0/16 == 1.9375 F是十六进制数15
0X.8p1     // == 8.0/16 * 2 == 1.0
0X1FFFP-16 // == 0.1249847412109375
```

不合法的浮点数的十六进制字面量：

```go
0x.p1    // 整数部分表示必须包含至少一个数字
1p-2     // p指数形式只能出现在浮点数的十六进制字面量中
0x1.5e-2 // e和E不能出现在十六进制浮点数字面量的指数部分中
```

注意：下面这个表示是合法的，但是它不是浮点数的十六进制字面量。事实上，它是一个减法算术表达式。其中的`e`为是十进制中的`14`，`0x15e`为一个整数十六进制字面量，`-2`并不是此整数十六进制字面量的一部分

```go
0x15e-2 // == 0x15e - 2 (整数相减表达式)
```

浮点类型的零值的标准字面量形式为`0.0`。 当然其它很多形式也是合法的，比如`0.`、`.0`、`0e0`和`0x0p0`等

#### 虚部字面量形式

一个虚部值的字面量形式由一个浮点数字面量或者一个整数字面量和其后跟随的一个小写的字母`i`组成。 在Go 1.13之前，如果虚部中`i`前的部分为一个整数字面量，则其必须为并且总是被视为十进制形式。

```go
1.23i
1.i
.23i
123i
0123i   // == 123i（兼容性使然。见下）
1.23E2i // == 123i
1e-1i
011i   // == 11i（兼容性使然。见下）
00011i // == 11i（兼容性使然。见下）
// 下面这几行从Go 1.13开始才能编译通过。
0o11i    // == 9i
0x11i    // == 17i
0b11i    // == 3i
0X.8p-0i // == 0.5i
```

注意：在Go 1.13之前，虚部字面量中字母`i`前的部分只能为浮点数字面量。 为了兼容老的Go版本，从Go 1.13开始，一些虚部字面量中表现为（不以`0o`和`0O`开头的）八进制形式的整数字面量仍被视为浮点数字面量。 比如上例中的`011i`、`0123i`和`00011i`。

虚部字面量用来表示复数的虚部

```go
1 + 2i       // == 1.0 + 2.0i
1. - .1i     // == 1.0 + -0.1i
1.23i - 7.89 // == -7.89 + 1.23i
1.23i        // == 0.0 + 1.23i
```

复数零值的标准字面表示为`0.0+0.0i`。 当然`0i`、`.0i`、`0+0i`等表示也是合法的。

#### rune值的字面量形式

`rune`类型是`int32`类型的别名。 因此，rune类型（泛指）是特殊的整数类型。

一个rune值可以用上面已经介绍的整数类型的字面量形式表示。 另一方面，很多各种整数类型的值也可以用rune字面量形式来表示。

在Go中，一个rune值表示一个Unicode码点。 一般说来，我们可以将一个Unicode码点看作是一个Unicode字符。但是，我们也应该知道，有些Unicode字符由多个Unicode码点组成。 每个英文或中文Unicode字符值含有一个Unicode码点。

一个rune字面量由若干包在一对单引号中的字符组成。包在单引号中的字符序列表示一个Unicode码点值。rune字面量形式有几个变种

```go
'a' // 一个英文字符
'π'
'众' // 一个中文字符

//下面这些rune字面量形式的变种和'a'是等价的 （字符a的Unicode值是97）。
'\141'   // 141是97的八进制表示
'\x61'   // 61是97的十六进制表示
'\u0061'
'\U00000061'
```

注意：<u>`\`之后必须跟随三个八进制数字字符（0-7）表示一个byte值</u>， <u>`\x`之后必须跟随两个十六进制数字字符（0-9，a-f和A-F）表示一个byte值</u>， `\u`之后必须跟随四个十六进制数字字符表示一个rune值（此rune值的高四位都为0）， `\U`之后必须跟随八个十六进制数字字符表示一个rune值。 这些八进制和十六进制的数字字符序列表示的整数必须是一个合法的Unicode码点值，否则编译将失败。

下面这些`println`函数调用都将打印出`true`。

```go
package main

func main() {
	println('a' == 97)
	println('a' == '\141')
	println('a' == '\x61')
	println('a' == '\u0061')
	println('a' == '\U00000061')
	println(0x61 == '\x61')
	println('\u4f17' == '众')
}
```

在日常编程中，这四种rune字面量形式的变种很少用来表示rune值。 它们多用做字符串的双引号字面量形式中的转义字符。

如果一个rune字面量中被单引号包起来的部分含有两个字符， 并且第一个字符是`\`，第二个字符不是`x`、 `u`和`U`，那么这两个字符将被转义为一个特殊字符。目前支持的转义组合为：

```go
\a   (rune值：0x07) 铃声字符
\b   (rune值：0x08) 退格字符（backspace）
\f   (rune值：0x0C) 换页符（form feed）
\n   (rune值：0x0A) 换行符（line feed or newline）
\r   (rune值：0x0D) 回车符（carriage return）
\t   (rune值：0x09) 水平制表符（horizontal tab）
\v   (rune值：0x0b) 竖直制表符（vertical tab）
\\   (rune值：0x5c) 一个反斜杠（backslash）
\'   (rune值：0x27) 一个单引号（single quote）
```

其中，`\n`在日常编程中用得最多。

一个例子：

```go
	println('\n') // 10
	println('\r') // 13
	println('\'') // 39

	println('\n' == 10)     // true
	println('\n' == '\x0A') // true
```

rune类型的零值常用 `'\000'`、`'\x00'`或`'\u0000'`等来表示。

#### 字符串值的字面量形式

在Go中，字符串值是UTF-8编码的， 甚至所有的Go源代码都必须是UTF-8编码的。

Go字符串的字面量形式有两种。 一种是解释型字面表示（interpreted string literal，双引号风格）。 另一种是直白字面表示（raw string literal，反引号风格）。

下面的两个字符串表示形式是等价的：

```go
// 解释形式
"Hello\nworld!\n\"你好世界\""

// 直白形式
`Hello
world!
"你好世界"`
```

在上面的解释形式（双引号风格）的字符串字面量中，每个`\n`将被转义为一个换行符，每个`\"`将被转义为一个双引号字符。 双引号风格的字符串字面量中支持的转义字符和rune字面量基本一致，除了<u>一个例外：双引号风格的字符串字面量中支持`\"`转义，但不支持`\'`转义；而rune字面量则刚好相反</u>。

以`\`、`\x`、`\u`和`\U`开头的rune字面量（不包括两个单引号）也可以出现在双引号风格的字符串字面量中。比如：

```go
// 这几个字符串字面量是等价的。
"\141\142\143"
"\x61\x62\x63"
"\x61b\x63"
"abc"

// 这几个字符串字面量是等价的。
"\u4f17\xe4\xba\xba"// “众”的Unicode值为4f17，它的UTF-8编码为三个字节：0xe4 0xbc 0x97。
"\xe4\xbc\x97\u4eba"// “人”的Unicode值为4eba，它的UTF-8编码为三个字节：0xe4 0xba 0xba。
"\xe4\xbc\x97\xe4\xba\xba"
"众人"
```

在UTF-8编码中，一个Unicode码点（rune）可能由1到4个字节组成。 每个英文字母的UTF-8编码只需要一个字节；每个中文字符的UTF-8编码需要三个字节。

直白反引号风格的字面表示中是不支持转义字符的。 除了首尾两个反引号，直白反引号风格的字面表示中不能包含反引号。 为了跨平台兼容性，直白反引号风格的字面表示中的回车符（Unicode码点为`0x0D`） 将被忽略掉。

字符串类型的零值在代码里用 `""`或````表示。

#### 数值字面表示中使用下划线分段来增强可读性

从Go 1.13开始，下划线`_`可以出现在整数、浮点数和虚部数字面量中，以用做分段符以增强可读性。

但是要注意，在一个数值字面表示中，一个下划线`_`不能出现在此字面表示的首尾，并且其两侧的字符必须为（相应进制的）数字字符或者进制表示头。

```go
// 合法的使用下划线的例子
6_9          // == 69
0_33_77_22   // == 0337722
0x_Bad_Face  // == 0xBadFace
0X_1F_FFP-16 // == 0X1FFFP-16
0b1011_0111 + 0xA_B.Fp2i

// 非法的使用下划线的例子
_69        // 下划线不能出现在首尾
69_        // 下划线不能出现在首尾
6__9       // 下划线不能相连
0_xBadFace // x不是一个合法的八进制数字
1_.5       // .不是一个合法的十进制数字
1._5       // .不是一个合法的十进制数字
```

### 基本数值类型字面量的适用范围

一个数值型的字面量只有在不需要舍入时，才能用来表示一个整数基本类型的值。 比如，<u>`1.0`可以表示任何基本整数类型的值</u>，但`1.01`却不可以。 当一个数值型的字面量用来表示一个非整数基本类型的值时，舍入（或者精度丢失）是允许的。

每种数值类型有一个能够表示的数值范围。 如果一个字面量超出了一个类型能够表示的数值范围（溢出），则在编译时刻，此字面量不能用来表示此类型的值。

下表是一些例子：

|             字面表示             | 此字面表示可以表示哪些类型的值（在编译时刻）                 |
| :------------------------------: | ------------------------------------------------------------ |
|              `256`               | 除了int8和uint8类型外的所有的基本数值类型。                  |
|              `255`               | 除了int8类型外的所有的基本数值类型。                         |
|              `-123`              | 除了无符号整数类型外的所有的基本数值类型。                   |
|              `123`               | 所有的基本数值类型。                                         |
|            `123.000`             | 所有的基本数值类型。                                         |
|             `1.23e2`             | 所有的基本数值类型。                                         |
|              `'a'`               | 所有的基本数值类型。                                         |
|             `1.0+0i`             | 所有的基本数值类型。                                         |
|              `1.23`              | 所有浮点数和复数基本数值类型。                               |
| `0x10000000000000000` (16 zeros) | 所有浮点数和复数基本数值类型。                               |
|             `3.5e38`             | 除了float32和complex64类型外的所有浮点数和复数基本数值类型。 |
|              `1+2i`              | 所有复数基本数值类型。                                       |
|             `2e+308`             | 无。                                                         |

注意几个溢出的例子：

- 字面量`0x10000000000000000`需要65个比特才能表示，所以在运行时刻，任何基本整数类型都不能精确表示此字面量。
- 在IEEE-754标准中，最大的可以精确表示的float32类型数值为`3.40282346638528859811704183484516925440e+38`，所以`3.5e38`不能表示任何float32和complex64类型的值。
- 在IEEE-754标准中，最大的可以精确表示的float64类型数值为`1.797693134862315708145274237317043567981e+308`，因此`2e+308`不能表示任何基本数值类型的值。
- 尽管`0x10000000000000000`可以用来表示float32类型的值，但是它不能被任何float32类型的值所精确表示。上面已经提到了，当使用字面量来表示非整数基本数值类型的时候，精度丢失是允许的（但溢出是不允许的）。

------



## 常量和变量

将介绍常量和变量相关的知识。 类型不确定值、类型推断和值的显式类型转换等概念也将被介绍。

上一章中提到的[基本类型的字面量表示](#基本类型的字面量表示形式) （除了`false`和`true`）都属于**无名常量（unnamed constant）**，或者叫**字面常量（literal constant）**。 `false`和`true`是预声明的两个**具名常量**。这里将介绍如何声明自定义的具名常量。

### 类型不确定值（untyped value）和类型确定值（typed value）

在Go中，有些值的类型是不确定的。换句话说，<u>有些值的类型有很多可能性</u>。 这些值称为**类型不确定值**。对于大多数类型不确定值来说，它们各自都有一个默认类型

除了预声明的`nil`。`nil`是没有默认类型的。

与类型不确定值相对应的概念称为**类型确定值**

上一章提到的**字面常量（无名常量）**<u>都属于类型不确定值</u>。 事实上，<u>Go中大多数的类型不确定值都属于字面常量和即将介绍的具名常量</u>。 少数类型不确定值包括刚提到的`nil`和以后会逐步接触到的某些操作的布尔返回值。

一个字面（常）量的默认类型取决于它为何种字面量形式：

- 一个字符串字面量的默认类型是预声明的`string`类型。
- 一个布尔字面量的默认类型是预声明的`bool`类型。
- 一个整数型字面量的默认类型是预声明的`int`类型。
- 一个rune字面量的默认类型是预声明的`rune`（亦即`int32`）类型。
- 一个浮点数字面量的默认类型是预声明的`float64`类型。
- 如果一个字面量含有虚部字面量，则此字面量的默认类型是预声明的`complex128`类型

### 类型不确定常量的显式类型转换

和很多语言一样，Go也支持类型转换。 一个**显式类型转换**的形式为`T(v)`，其表示将一个值`v`转换为类型`T`。 编译器将`T(v)`的转换结果视为一个类型为`T`的类型确定值。当然，对于一个特定的类型`T`，`T(v)`并非对任意的值`v`都合法。

对于一个类型不确定常量值`v`，有两种情形显式转换`T(v)`是合法的：

1. `v`可以表示为`T`类型的一个值。 转换结果为一个类型为`T`的类型确定常量值。
2. `v`的默认类型是一个整数类型（`int`或者`rune`） 并且`T`是一个字符串类型。 转换`T(v)`将`v`看作是一个Unicode码点。 转换结果为一个类型为`T`的字符串常量。 此字符串常量只包含一个Unicode码点，并且可以看作是此Unicode码点的UTF-8表示形式。 对于不在合法的Unicode码点取值范围内的整数`v`， 转换结果等同于字符串字面量`"\uFFFD"`（亦即`"\xef\xbf\xbd"`）。 `0xFFFD`是Unicode标准中的（非法码点的）替换字符值。 （但是请注意，今后的Go版本可能[只允许rune或者byte整数被转换为字符串](https://github.com/golang/go/issues/3939)。 从Go官方工具链1.15版本开始，`go vet`命令会对从非rune和非byte整数到字符串的转换做出警告。）

这一规则同时适用于字面常量和类型不确定具名常量。

第二种情形并不要求`v`必须是一个常量。 如果`v`是一个常量，则转换结果也是一个常量。 如果`v`不是一个常量，则转换结果也不是一个常量。

一些合法的转换例子：

```go
// 结果为complex128类型的1.0+0.0i。虚部被舍入了。
complex128(1 + -1e-1000i)
// 结果为float32类型的0.5。这里也舍入了。
float32(0.49999999)
// 只要目标类型不是整数类型，舍入都是允许的。
float32(17000000000000000)
float32(123)
uint(1.0)
int8(-123)
int16(6+0i)
complex128(789)

string(65)          // "A"
string('A')         // "A"
string('\u68ee')    // "森"
string(-1)          // "\uFFFD"
string(0xFFFD)      // "\uFFFD"
string(0x2FFFFFFFF) // "\uFFFD"
```

一些非法的转换例子：

```go
int(1.23)     // 1.23不能被表示为int类型值。
uint8(-1)     // -1不能被表示为uint8类型值。
float64(1+2i) // 1+2i不能被表示为float64类型值。

// -1e+1000不能被表示为float64类型值。不允许溢出。
float64(-1e1000)
// 0x10000000000000000做为int值将溢出。
int(0x10000000000000000)

// 字面量65.0的默认类型是float64（不是一个整数类型）。
string(65.0)
// 66+0i的默认类型是complex128（不是一个整数类型）。
string(66+0i)
```

从上面的例子可以看出，一个类型不确定数字值所表示的值可能溢出它的默认类型的表示范围。 比如上例中的`-1e1000`和`0x10000000000000000`。 一个溢出了它的默认类型的表示范围的类型不确定数字值是不能被转换到它的默认类型的（将编译报错）。

有时一个显式转换形式必须被写成`(T)(v)`以免发生歧义。 这种情况多发生在`T`不为一个标识符的时候。

### 类型推断介绍

Go支持类型推断（type deduction or type inference）。 **类型推断是指在某些场合下，程序员可以在代码中使用一些类型不确定值， 编译器会自动推断出这些类型不确定值在特定情景下应被视为某些特定类型的值**。

在Go代码中，如果某处需要一个特定类型的值并且一个类型不确定值可以表示为此特定类型的值， 则此类型不确定值可以使用在此处。Go编译器将此类型不确定值视为此特定类型的类型确定值。 这种情形常常出现在运算符运算、函数调用和赋值语句中。

有些场景对某些类型不确定值并没有特定的类型要求。在这种情况下，Go编译器将这些类型不确定值视为它们各自的默认类型的类型确定值。

这两条类型推断规则可以被视为**隐式转换规则**。

### （具名）常量声明（constant declaration）

和无名字面常量一样，具名常量也必须都是布尔、数字或者字符串值。 在Go中，关键字`const`用来声明具名常量。

下面是一些常量声明的例子：

```go
package main

// 声明了两个单独的具名常量。（是的，非ASCII字符可以用做标识符。）
const π = 3.1416
const Pi = π // 等价于：const Pi = 3.1416

// 声明了一组具名常量。
const (
	No         = !Yes
	Yes        = true
	MaxDegrees = 360
	Unit1      = "弧度"
)

func main() {
	// 声明了三个局部具名常量。
	const DoublePi, HalfPi, Unit2 = π * 2, π * 0.5, "度"
}
```

Go白皮书把上面每行含有一个等号`=`的语句称为一个常量描述（constant specification）。 每个`const`关键字对应一个常量声明。一个常量声明中可以有若干个常量描述。 上面的例子中含有4个常量声明。除了第3个，其它的常量声明中都各自只有一个常量描述。 第3个常量声明中有4个常量描述。

常量声明中的等号`=`<u>表示“绑定”而非“赋值”</u>。 每个常量描述将一个或多个字面量绑定到各自对应的具名常量上。 或者说，**每个具名常量其实代表着一个字面常量**。

在上面的例子中，具名常量`π`和`Pi`都绑定到（或者说代表着）字面常量`3.1416`。 这两个具名常量可以在程序代码中被多次使用，从而有效避免了字面常量`3.1416`在代码中出现在多处。 如果字面常量`3.1416`在代码中出现在多处， 当我们以后欲将`3.1416`改为`3.14`的时候，所有出现在代码中的`3.1416`都得逐个修改。 有了具名常量的帮助，我们只需修改对应常量描述中的`3.1416`即可。 这是常量声明的主要作用

我们使用**非常量**这一术语表示不是常量的值。将要介绍的变量就属于非常量。

常量可以直接声明在包中，也可以声明在函数体中。 声明在函数体中的常量称为局部常量（local constant），直接声明在包中的常量称为包级常量（package-level constant）。 包级常量也常常被称为全局常量。

包级常量声明中的常量描述的顺序并不重要。比如在上面的例子中， 常量描述`No`和`Yes`的顺序可以掉换一下。

上面例子中声明的所有常量都是类型不确定的。 它们各自的默认类型和它们各自代表的字面量的默认类型是一样的。

#### 类型确定具名常量

我们可以**在声明一些常量的时候指定这些常量的确切类型**。 这样声明的常量称为类型确定具名常量。

在下面这个例子中，所有这4个声明的常量都是类型确定的。 `X`和`Y`的类型都是`float32`， `A`和`B`的类型都是`int64`。

```go
const X float32 = 3.14

const (
	A, B int64   = -3, 5
	Y    float32 = 2.718
)
```

如果一个常量描述中包含多个类型确定常量，则这些常量的类型必然是一样的， 比如上例中的`A`和`B`。

我们也可以使用显式类型转换来声明类型确定常量。 下面的例子和上面的例子是完全等价的。

```go
const X = float32(3.14)

const (
	A, B = int64(-3), int64(5)
	Y    = float32(2.718)
)
```

欲将一个字面常量绑定到一个类型确定具名常量上，此字面常量必须能够表示为此常量的确定类型的值。 否则，编译将报错。比如：

```go
const a uint8 = 256             // error: 256溢出uint8
const b = uint8(255) + uint8(1) // error: 256溢出uint8
const c = int8(-128) / int8(-1) // error: 128溢出int8
const MaxUint_a = uint(^0)      // error: -1溢出uint
const MaxUint_b uint = ^0       // error: -1溢出uint
```

在上面的例子中，符号`^`为位反运算符。

下面这个类型确定常量声明在64位的操作系统上是合法的，但在32位的操作系统上是非法的。 因为一个`uint`值在32位操作系统上的尺寸是32位， `(1 << 64) - 1`将溢出`uint`。（这里，符号`<<`为左移位运算符。）

```go
const MaxUint uint = (1 << 64) - 1
```

那么如何声明一个代表着最大`uint`值的常量呢？ 我们可以用下面这个常量声明来替换上面这个。下面这个声明在64位和32位的操作系统上都是合法的。

```go
const MaxUint = ^uint(0)
```

类似地，我们可以使用下面这个常量声明来声明一个具名常量来表示最大的`int`值。（这里，符号`>>`为右移位运算符。）

```go
const MaxInt = int(^uint(0) >> 1)
```

使用类似的方法，我们可以声明一个常量来表示当前操作系统的位数，或者检查当前操作系统是32位的还是64位的。

```go
const NativeWordBits = 32 << (^uint(0) >> 63) // 64 or 32
const Is64bitOS = ^uint(0) >> 63 != 0
const Is32bitOS = ^uint(0) >> 32 == 0
```

#### 常量声明中的自动补全

在一个包含多个常量描述的常量声明中，除了第一个常量描述，其它后续的常量描述都可以只包含标识符列表部分。 Go编译器将通过照抄前面最紧挨的一个完整的常量描述来自动补全不完整的常量描述。

比如，在编译阶段，编译器会将下面的代码

```go
const (
	X float32 = 3.14
	Y                // 这里必须只有一个标识符
	Z                // 这里必须只有一个标识符

	A, B = "Go", "language"
	C, _
	// 上一行中的空标识符是必需的
	// （如果上一行是一个不完整的常量描述的话）。
)
```

自动补全为

```go
const (
	X float32 = 3.14
	Y float32 = 3.14
	Z float32 = 3.14

	A, B = "Go", "language"
	C, _ = "Go", "language"
)
```

#### 在常量声明中使用`iota`

`iota`是Go中预声明（内置）的<u>一个特殊的具名常量</u>。 `iota`被预声明为`0`，但是它的值在编译阶段并非恒定。 当此预声明的`iota`出现在一个常量声明中的时候，它的值在第n个常量描述中的值为`n`（从0开始）。 所以`iota`只对含有多个常量描述的常量声明有意义

`iota`和常量描述自动补全相结合有的时候能够给Go编程带来很大便利。

比如，下面是一个使用了这两个特性的例子

```go
package main

func main() {
	const (
		k = 3 // 在此处，iota == 0

		m float32 = iota + .5 // m float32 = 1 + .5
		n                     // n float32 = 2 + .5

		p = 9             // 在此处，iota == 3
		q = iota * 2      // q = 4 * 2
		_                 // _ = 5 * 2
		r                 // r = 6 * 2
		s, t = iota, iota // s, t = 7, 7
		u, v              // u, v = 8, 8
		_, w              // _, w = 9, 9
	)

	const x = iota // x = 0 （iota == 0）
	const (
		y = iota // y = 0 （iota == 0）
		z        // z = 1
	)

	println(m)             // +1.500000e+000
	println(n)             // +2.500000e+000
	println(q, r)          // 8 12
	println(s, t, u, v, w) // 7 7 8 8 9
	println(x, y, z)       // 0 0 1
}
```

在实际编程中，我们应该用有意义的方式使用之。比如

```go
const (
	Failed = iota - 1 // == -1
	Unknown           // == 0
	Succeeded         // == 1
)

const (
	Readable = 1 << iota // == 1
	Writable             // == 2
	Executable           // == 4
)
```

### 变量声明和赋值操作语句

变量可以被看作是在运行时刻存储在内存中并且可以被更改的具名的值。

**所有的变量值都是类型确定值**。当声明一个变量的时候，我们必须在代码中给编译器提供足够的信息来让编译器推断出此变量的确切类型。

在一个函数体内声明的变量称为局部变量。 在任何函数体外声明的变量称为包级或者全局变量。

Go语言有两种变量声明形式。一种称为标准形式，另一种称为短声明形式。 短声明形式只能用来声明局部变量。

#### 标准变量声明形式

标准变量声明形式语句起始于一个`var`关键字。 每个`var`关键字跟随着一个变量名。 每个变量名必须为一个[标识符](#标识符)。

下面是几条完整形式的标准变量声明语句。 这些声明确地指定了被声明的变量的类型和初始值。

```go
var lang, website string = "Go", "https://golang.org"
var compiled, dynamic bool = true, false
var announceYear int = 2009
```

可以看到，和常量声明一样，多个同类型的变量可以在一条语句中被声明。

完整形式的标准变量声明使用起来有些罗嗦，因此很少在日常Go编程中使用。 在日常Go编程中，另外两种变种形式用得更广泛一些。 一种变种形式省略了变量类型（但仍指定了变量的初始值），这时编译器将根据初始值的字面量形式来推断出变量的类型。 另一种变种形式省略了初始值（但仍指定了变量类型），这时编译器将使用变量类型的零值做为变量的初始值。

下面是一些第一种变种形式的用例。在这些用例中，如果一个初始值是一个类型确定值，则对应声明的变量的类型将被推断为此初始值的类型； 如果一个初始值是一个类型不确定值，则对应声明的变量的类型将被推断为此初始值的默认类型。 注意**在这种变种中，同时声明的多个变量的类型可以不一样。**

```go
// 变量lang和dynamic的类型将被推断为内置类型string和bool。
var lang, dynamic = "Go", false

// 变量compiled和announceYear的类型将被推断
// 为内置类型bool和int。
var compiled, announceYear = true, 2009

// 变量website的类型将被推断为内置类型string。
var website = "https://golang.org"
```

上例中的类型推断可以被视为**隐式类型转换**。

下例展示了几个省略了初始值的标准变量声明。每个声明的变量的初始值为它们各自的类型的零值。

```go
var lang, website string      // 两者都被初始化为空字符串。
var interpreted, dynamic bool // 两者都被初始化为false。
var n int                     // 被初始化为0。
```

和常量声明一样，多个变量可以用一对小括号组团在一起被声明。

```go
var (
	lang, bornYear, compiled     = "Go", 2007, true
	announceAt, releaseAt    int = 2009, 2012
	createdBy, website       string
)
```

这个变量声明语句包含三个变量描述（variable specification）。

#### 纯赋值语句

等号`=`表示赋值。 一旦一个变量被声明之后，它的值可以被通过纯赋值语句来修改。 多个变量可以同时在一条赋值语句中被修改

一个赋值语句等号左边的表达式必须是一个可寻址的值、一个映射元素或者一个空标识符

**常量是不可改变的**（不可寻址的），所以常量不能做为目标值出现在纯赋值语句的左边，而只能出现在右边用做源值。 变量既可以出现在纯赋值语句的左边用做目标值，也可以出现在右边用做源值

**空标识符**也可以出现在纯赋值语句的左边，**表示不关心对应的目标值**。 空标识符不可被用做源值

纯赋值语句的例子：

```go
const N = 123
var x int
var y, z float32

N = 789 // error: N是一个不可变量
y = N   // ok: N被隐式转换为类型float32
x = y   // error: 类型不匹配
x = N   // ok: N被隐式转换为类型int
y = x   // error: 类型不匹配
z = y   // ok
_ = y   // ok

z, y = y, z               // ok
_, y = y, z               // ok
z, _ = y, z               // ok
_, _ = y, z               // ok
x, y = 69, 1.23           // ok
x, y = y, x               // error: 类型不匹配
x, y = int(y), float32(x) // ok
```

上例中的最后一行使用了显式类型转换，否则此赋值（见倒数第二行）将不合法

Go不支持某些其它语言中的连等语法

```go
var a, b int
a = b = 123 // 语法错误
```

#### 短变量声明形式

用短变量声明形式来声明一些局部变量。如下例：

```go
package main

func main() {
	// 变量lang和year都为新声明的变量。
	lang, year := "Go language", 2007

	// 这里，只有变量createdBy是新声明的变量。
	// 变量year已经在上面声明过了，所以这里仅仅
	// 改变了它的值，或者说它被重新声明了。
	year, createdBy := 2009, "Google Research"

	// 这是一个纯赋值语句。
	lang, year = "Go", 2012

	print(lang, "由", createdBy, "发明")
	print("并发布于", year, "年。")
	println()
}
```

**每个短声明语句中必须至少有一个新声明的变量**。

从上面的例子中，我们可以看到短变量声明形式和标准变量声明形式有几个显著的区别：

1. 短声明形式不包含`var`关键字，并且不能指定变量的类型。
2. 短变量声明中的赋值符号必须为`:=`。
3. 在一个短声明语句的左侧，已经声明过的变量和新声明的变量可以共存。 但在一个标准声明语句中，所有出现在左侧的变量必须都为新声明的变量。

注意，相对于纯赋值语句，目前短声明语句有一个限制：出现在一个短声明左侧的项必须都为纯标识符。 在纯赋值语句的左边可以出现结构体值的字段，指针的解引用和容器类型值的元素索引项等。 但是这些项不能出现在一个变量短声明语句的左边

#### 关于“赋值”这个术语

当“赋值”这个术语被提到的时候，它可以指一个纯赋值、一个短变量声明或者一个初始值未省略的标准变量声明

当`y = x`是一条合法的赋值语句时，我们可以说`x`可以被赋给`y`。 假设`y`的类型为`Ty`，有时为了叙述方便，我们也可以说`x`可以被赋给类型`Ty`

一般来说，如果`x`可以被赋给`y`，则`y`应该是可修改的，并且`x`和`y`的类型相同或者`x`可以被隐式转换到`y`的类型。 当然，`y`也可以是空标识符`_`

#### 每个局部声明的变量至少要被有效使用一次

注意，当使用目前的主流Go编译器编译Go代码时，**一个局部变量被声明之后至少要被有效使用一次，否则编译器将报错**。 <u>包级变量无此限制</u>。 如果一个变量总是被当作赋值语句中的目标值，那么我们认为这个变量没有被有效使用过

比如，下面这个例子编译不通过：

```go
package main

var x, y, z = 123, true, "foo" // 包级变量

func main() {
	var q, r = 789, false
	r, s := true, "bar"
	r = y // r没有被有效使用。
	x = q // q被有效使用了。
}
```

当编译上面这个程序的时候，编译器将报错（假设这个程序代码存在一个名为`example-unused.go`的文件中）：

```bash
./example-unused.go:6:6: r declared and not used
./example-unused.go:7:16: s declared and not used
```

避免编译器报错的方法很简单，**要么删除相关的变量声明**，要么像下面这样，将未曾有效使用过的变量（这里是`r`和`s`）**赋给空标识符**

```go
package main

var x, y, z = 123, true, "foo"

func main() {
	var q, r = 789, false
	r, s := true, "bar"
	r = y
	x = q

	_, _ = r, s // 将r和s做为源值使用一次。
}
```

#### 若干包级变量在声明时刻的依赖关系将影响它们的初始化顺序

下面这个例子中的声明的变量的初始化顺序为`y = 5`、`c = y`、`b = c+1`、`a = b+1`、`x = a+1`

```go
var x, y = a+1, 5         // 8 5
var a, b, c = b+1, c+1, y // 7 6 5
```

包级变量在初始化的时候不能相互依赖。比如，下面这个变量声明语句编译不通过：

```go
var x, y = y, x
```

### 值的可寻址性

在Go中，有些值是可以被寻址的。上面已经提到所有变量都是可以寻址的，所有常量都是不可被寻址

### 非常量数字值相关的显式类型转换规则

在Go中，两个类型不一样的[基本类型](#基本内置类型)值是不能相互赋值的。 我们必须使用显式类型转换将一个值转换为另一个值的类型之后才能进行赋值

已经提到了<u>整数（不论常量还是非常量）都可以被显式转换为字符串类型</u>

再介绍两个不同类型数字值之间的转换规则：

- <u>一个非常量浮点数和整数可以显式转换到其它任何一个浮点数和整数类型</u>。
- <u>一个非常量复数可以显式转换到其它任何一个复数类型</u>。

上面已经提到，**常量数字值的类型转换不能溢出**。**此规则不适用于非常量数字值的类型转换**。 <u>非常量数字值的类型转换中，溢出是允许的</u>。 另外当将一个浮点数非常量值（比如一个变量）转换为一个整数类型的时候，舍入（或者精度丢失）也是允许的。 具体规则如下：

- 当从一个比特位数多的整数类型的非常量整数值向一个比特位数少的整数类型转换的时候，高位的比特将被舍弃，低位的比特将被保留。我们称这种处理方式为**截断（truncated）**。
- 当从一个非常量的浮点数向一个整数类型转换的时候，浮点数的小数部分将被舍弃（向零靠拢）。
- 当从一个非常量整数或者浮点数向一个浮点数类型转换的时候，精度丢失是可以发生的。
- 当从一个非常量复数向另一个复数类型转换的时候，精度丢失也是可以发生的。
- 当一个显式转换涉及到非常量浮点数或者复数数字值时，如果源值溢出了目标类型的表示范围，则转换结果取决于具体编译器实现（即行为未定义）。

下面的例子：

```go
const a = -1.23
// 变量b的类型被推断为内置类型float64。
var b = a
// error: 常量1.23不能被截断舍入到一个整数。
var x = int32(a)
// error: float64类型值不能被隐式转换到int32。
var y int32 = b
// ok: z == -1，变量z的类型被推断为int32。
//     z的小数部分将被舍弃。
var z = int32(b)

const k int16 = 255
var n = k            // 变量n的类型将被推断为int16。
var f = uint8(k + 1) // error: 常量256溢出了uint8。
var g uint8 = n + 1  // error: int16值不能隐式转换为uint8。
var h = uint8(n + 1) // ok: h == 0，变量h的类型为uint8。
                     // (n+1)溢出uint8，所以只有低8位
                     // bits（都为0）被保留。
```

第*7*行和第*15*行的隐式转换是不允许的，第*5*行和第*14*行的显式转换也是不允许的。

第*3*行的隐式转换中，`a`被转换为它的默认类型（`float64`）；因此`b`的类型被推断为`float64`

### 变量和常量的作用域

在Go中，我们可以使用一对大括号来显式形成一个（局部）代码块。一个代码块可以内嵌另一个代码块。 最外层的代码块称为包级代码块。 一个声明在一个内层代码块中的常量或者变量将遮挡另一个外层代码块中声明的同名变量或者常量。 

比如，下面的代码中声明了3个名为`x`的变量。 内层的`x`将遮挡外层的`x`， 从而外层的`x`在内层的`x`声明之后在内层中将不可见

```go
package main

const y = 70
var x int = 123 // 包级变量

func main() {
	// 此x变量遮挡了包级变量x。
	var x = true

	// 一个内嵌代码块。
	{
		x, y := x, y-10 // 这里，左边的x和y均为新声明
		                // 的变量。右边的x为外层声明的
		                // bool变量。右边的y为包级变量。

		// 在此内层代码块中，从此开始，
		// 刚声明的x和y将遮挡外层声明x和y。

		x, z := !x, y/10 // z是一个新声明的变量。
		                 // x和y是上一句中声明的变量。
		println(x, y, z) // false 60 6
	}
	println(x) // true
	println(y) // 70 （包级变量y从未修改）
	/*
	println(z) // error: z未定义。
	           // z的作用域仅限于上面的最内层代码块。
	*/
}
```

作用域是指一个标识符的可见范围。 一个包级变量或者常量的作用域为其所处于的整个代码包。 一个局部变量或者常量的作用域开始于此变量或者常量的声明的下一行，结束于最内层包含此变量或者常量的声明语句的代码块的结尾

### 更多关于常量声明

#### 一个类型不确定常量所表示的值可以溢出其默认类型

比如，下例中的三个类型不确定常量均溢出了它们各自的默认类型，但是此程序编译和运行都没问题

```go
package main

// 三个类型不确定常量。
const n = 1 << 64          // 默认类型为int
const r = 'a' + 0x7FFFFFFF // 默认类型为rune
const x = 2e+308           // 默认类型为float64

func main() {
	_ = n >> 2
	_ = r - 0x7FFFFFFF
	_ = x / 2
}
```

但是下面这个程序编译不通过，因为三个声明的常量为类型确定常量。

```go
package main

// 三个类型确定常量。
const n int = 1 << 64           // error: 溢出int
const r rune = 'a' + 0x7FFFFFFF // error: 溢出rune
const x float64 = 2e+308        // error: 溢出float64

func main() {}
```

#### 每个常量标识符将在编译的时候被其绑定的字面量所替代

常量声明可以看作是增强型的C语言中的`#define`宏。 在编译阶段，所有的标识符将被它们各自绑定的字面量所替代

如果一个运算中的所有运算数都为常量，则此运算的结果也为常量。或者说，此运算将在编译阶段就被估值

一个例子：

```go
package main

const X = 3
const Y = X + X
var a = X

func main() {
	b := Y
	println(a, b, X, Y)
}
```

上面这段程序代码将在编译阶段被重写为下面这样：

```go
package main

var a = 3

func main() {
	b := 6
	println(a, b, 3, 6)
}
```

------



## 运算操作符

将介绍适用于基本类型值的各种运算操作符

同时只介绍算术运算符、位运算符、比较运算符、布尔运算符和字符串衔接运算符。 这些运算符要么是二元的（需要两个操作数），要么是一元的（需要一个操作数）。 所有这些运算符运算都只返回一个结果。操作数常常也称为操作值。

此处的介绍不追求描述的完全准确性。 比如，当我们说一个二元运算符运算需要其涉及的两个操作数类型必须一样的时，这指：

- 如果这两个操作数都是类型确定值，则它们的类型必须相同，或者其中一个操作数可以被隐式转换到另一个操作数的类型。
- 如果其中只有一个操作数是类型确定的，则要么另外一个类型不确定操作数可以表示为此类型确定操作数的类型的值，要么此类型不确定操作数的默认类型的任何值可以被隐式转换到此类型确定操作数的类型。
- 如果这两个操作数都是类型不确定的，则它们必须同时都为两个布尔值，同时都为两个字符串值，或者同时都为两个基本数字值。

类似的，当我们说一个运算符（一元或者二元）运算要求其涉及的某个操作数的类型必须为某个特定类型时，这指：

- 如果这个操作数是类型确定的，则它的类型必须为所要求的特定类型，或者此操作数可以被隐式转换为所要求的特定类型。
- 如果一个操作数是类型不确定的，则要么此操作数可以表示为所要求的特定类型值，要么此操作数的默认类型的任何值可以被隐式转换为所要求的特定类型。

### 常量表达式

在介绍之前，我们需要知道什么叫常量表达式和关于常量表达式估值的一个常识

表达式的概念将在[表达式和语句](#)一文中得到解释。 目前我们只需知道本文中所提及的大多数运算都属于表达式。 **当一个表达式中涉及到的所有操作数都是常量时，此表达式称为一个常量表达式**。 一个常量表达式的估值是在编译阶段进行的。一个常量表达式的估值结果依然是一个常量。 **如果一个表达式中涉及到的操作数中至少有一个不为常量，则此表达式称为非常量表达式**。

### 算术运算符

Go支持五个基本二元算术运算符：

| 字面形式 | 名称 | 对两个运算数的要求                               |
| -------- | ---- | ------------------------------------------------ |
| +        | 加法 | 两个运算数的类型必须相同并且为基本数值类型。     |
| -        | 减法 | 两个运算数的类型必须相同并且为基本数值类型。     |
| *        | 乘法 | 两个运算数的类型必须相同并且为基本数值类型。     |
| /        | 除法 | 两个运算数的类型必须相同并且为基本数值类型。     |
| %        | 余数 | 两个运算数的类型必须相同并且为基本整数数值类型。 |

Go支持六种位运算符（也属于算术运算）：

| 字面形式 | 名称       | 对两个操作数的要求以及机制解释                               |
| -------- | ---------- | ------------------------------------------------------------ |
| &        | 位与       | 两个操作数的类型必须相同并且为基本整数数值类型。机制解释（以下字面量均为二进制）：`1100 & 1010` 得到 `1000` |
| \|       | 位或       | 两个操作数的类型必须相同并且为基本整数数值类型。机制解释：`1100 |1010` 得到 `1110` |
| ^        | （位）异或 | 两个操作数的类型必须相同并且为基本整数数值类型。机制解释：`1100 ^ 1010  ` 得到 `0110` |
| &^       | 清位       | 两个操作数的类型必须相同并且为基本整数数值类型。机制解释：`1100 &^ 1010` 得到 `0100` |
| <<       | 左移位     | 左操作数必须为一个整数，右操作数也必须为一个整数（如果它是一个常数，则它必须非负），但它们的类型可以不同。 （注意：在Go 1.13之前，右操作数必须为一个无符号整数类型的类型确定值或者一个可以表示成`uint`值的[类型不确定](#类型不确定值（untyped value）和类型确定值（typed value）)常数值。）一个负右操作数（非常数）将在运行时刻造成一个恐慌。机制解释：`1100 << 3` 得到 `1100000`（低位补零） |
| >>       | 右移位     | 左操作数必须为一个整数，右操作数也必须为一个整数（如果它是一个常数，则它必须非负），但它们的类型可以不同。 （注意：在Go 1.13之前，右操作数必须为一个无符号整数类型的类型确定值或者一个可以表示成`uint`值的[类型不确定](#类型不确定值（untyped value）和类型确定值（typed value）)常数值。）一个负右操作数（非常数）将在运行时刻造成一个恐慌。机制解释：`1100 >> 3` 得到 `1`（低位被舍弃）注意，在右移运算中，左边空出来的位（即高位）全部用左操作数的最高位（即正负号位）填充。 比如如果左操作数`-128`的类型为`int8`（二进制补码表示为`100000002`）， 则`100000002 >> 2`的二进制补码结果为`111000002`（即`-32`）。 |

Go也支持三个一元算术运算符：

| 字面形式 | 名称           | 解释                                                         |
| -------- | -------------- | ------------------------------------------------------------ |
| +        | 取正数         | `+n`等价于`0 + n`.                                           |
| -        | 取负数         | `-n`等价于`0 - n`.                                           |
| ^        | 位反（或位补） | `^n`等价于`m ^ n`，^为异或运算，每个比特位相同为0，不同为1。其中`m`和`n`同类型并且它的二进制表示中所有比特位均为1。 比如如果`n`的类型为`int8`，则`m`的值为`-1`；如果`n`的类型为`uint8`，则`m`的值为`255`。 |

注意：

- 在很多其它流行语言中，位反运算符是用`~`表示的。
- 和一些其它流行语言一样，加号运算符`+`也可用做字符串衔接运算符。
- 和C及C++语言一样，`*`除了可以当作乘号运算符，它也可以用做指针解引用运算符； `&`除了可以当作位与运算符，它也可以用做取地址运算符。 后面将详解内存地址和指针类型。
- 和Java不一样，Go支持无符号数，所以Go不需要无符号右移运算符`>>>`。
- Go不支持幂运算符， 我们必须使用`math`标准库包中的`Pow`函数来进行幂运算。
- 清位运算符`&^`是Go中特有的一个运算符。 `m &^ n`等价于`m & (^n)`。

一些运算符的使用示例：

```go
func main() {
	var (
		a, b float32 = 12.0, 3.14
		c, d int16   = 15, -6
		e	uint8   = 7
	)

	// 这些行编译没问题。
	_ = 12 + 'A' // 两个类型不确定操作数（都为数值类型）
	_ = 12 - a   // 12将被当做a的类型（float32）使用。
	_ = a * b    // 两个同类型的类型确定操作数。
	_ = c % d
	_, _ = c + int16(e), uint8(c) + e
	_, _, _, _ = a / b, c / d, -100 / -9, 1.23 / 1.2
	_, _, _, _ = c | d, c & d, c ^ d, c &^ d
	_, _, _, _ = d << e, 123 >> e, e >> 3, 0xF << 0
	_, _, _, _ = -b, +c, ^e, ^-1

	// 这些行编译将失败。
	_ = a % b   // error: a和b都不是整数
	_ = a | b   // error: a和b都不是整数
	_ = c + e   // error: c和e的类型不匹配
	_ = b >> 5  // error: b不是一个整数
	_ = c >> -5 // error: -5不是一个无符号整数

	_ = e << uint(c) // 编译没问题
	_ = e << c       // 从Go 1.13开始，此行才能编译过
	_ = e << -c      // 从Go 1.13开始，此行才能编译过。
	                 // 将在运行时刻造成恐慌。
	_ = e << -1      // error: 右操作数不能为负（常数）
}
```

#### 关于溢出

之前提到了

- 一个类型确定数字型常量所表示的值是不能溢出它的类型的表示范围的。
- 一个类型不确定数字型常量所表示的值是可以溢出它的默认类型的表示范围的。 当一个类型不确定数字常量值溢出它的默认类型的表示范围时，此数值不会被截断（亦即回绕）。
- 将一个非常量数字值转换为其它数字类型时，此非常量数字值可以溢出转化结果的类型。 在此转换中，当溢出发生时，转化结果为此非常量数字值的截断（亦即回绕）表示。

对于一个算数运算的结果，上述规则同样适用。

示例：

```go
// 结果为非常量
var a, b uint8 = 255, 1
var c = a + b  // c==0。a+b是一个非常量表达式，
               // 结果中溢出的高位比特将被截断舍弃。
var d = a << b // d == 254。同样，结果中溢出的
               // 高位比特将被截断舍弃。

// 结果为类型不确定常量，允许溢出其默认类型。
const X = 0x1FFFFFFFF * 0x1FFFFFFFF // 没问题，尽管X溢出
const R = 'a' + 0x7FFFFFFF          // 没问题，尽管R溢出

// 运算结果或者转换结果为类型确定常量
var e = X                // error: X溢出int。
var h = R                // error: R溢出rune。
const Y = 128 - int8(1)  // error: 128溢出int8。
const Z = uint8(255) + 1 // error: 256溢出uint8。
```

#### 关于算术运算的结果

除了移位运算，对于一个二元算术运算，

- 如果它的两个操作数都为类型确定值，则此运算的结果也是一个和这两个操作数类型相同的类型确定值。
- 如果只有一个操作数是类型确定的，则此运算的结果也是一个和此类型确定操作数类型相同的类型确定值。 另一个类型不确定操作数的类型将被推断为（或隐式转换为）此类型确定操作数的类型。
- 如果它的两个操作数均为类型不确定值，则此运算的结果也是一个类型不确定值。 在运算中，两个操作数的类型将被设想为它们的默认类型中一个（按照此优先级来选择：`complex128`高于`float64`高于`rune`高于`int`）。 结果的默认类型同样为此设想类型。 比如，如果一个类型不确定操作数的默认类型为`int`，另一个类型不确定操作数的默认类型为`rune`， 则前者的类型在运算中也被视为`rune`，运算结果为一个默认类型为`rune`的类型不确定值。

对于移位运算，结果规则有点小复杂。首先移位运算的结果肯定都是整数。

- 如果左操作数是一个类型确定值（则它的类型必定为整数），则此移位运算的结果也是一个和左操作数类型相同的类型确定值。
- 如果左操作数是一个类型不确定值**并且右操作数是一个常量**，则左操作数将总是被视为一个整数。 如果它的默认类型不是一个整数（`rune`或`int`），则它的默认类型将被视为`int`。 此移位运算的结果也是一个类型不确定值并且它的默认类型和左操作数的默认类型一致。
- 如果左操作数是一个类型不确定值**并且右操作数是一个非常量**，则左操作数将被首先转化为运算结果的期待设想类型。 如果期待设想类型并没有被指定，则左操作数的默认类型将被视为它的期待设想类型。 如果此期待设想类型不是一个内置整数类型，则编译报错。 当然最终运算结果是一个类型为此期待设想类型的类型确定值。

一些非移位算术运算的例子：

```go
func main() {
	// 三个类型不确定常量。它们的默认类型
	// 分别为：int、rune和complex64.
	const X, Y, Z = 2, 'A', 3i


	var a, b int = X, Y // 两个类型确定值

	// 变量d的类型被推断为Y的默认类型：rune（亦即int32）。
	d := X + Y
	// 变量e的类型被推断为a的类型：int。
	e := Y - a
	// 变量f的类型和a及b的类型一样：int。
	f := a * b
	// 变量g的类型被推断为Z的默认类型：complex64。
	g := Z * Y

	// 2 65 (+0.000000e+000+3.000000e+000i)
	println(X, Y, Z)
	// 67 63 130 (+0.000000e+000+1.950000e+002i)
	println(d, e, f, g)
}
```

一个移位算术运算的例子：

```go
const N = 2
// A == 12，它是一个默认类型为int的类型不确定值。
const A = 3.0 << N
// B == 12，它是一个类型为int8的类型确定值。
const B = int8(3.0) << N

var m = uint(32)
// 下面的三行是相互等价的。
var x int64 = 1 << m  // 1的类型将被设想为int64，而非int
var y = int64(1 << m) // 同上
var z = int64(1) << m // 同上

// 下面这行编译不通过。
/*
var _ = 1.23 << m // error: 浮点数不能被移位
*/
```

上面提到的移位运算结果的最后一点类型推断规则有点反常。 这条规则的主要目的是为了防止一些移位运算在32位架构和64位架构的机器上的运算结果出现不一致但不一致却没有被及时发现的情况。 比如如果上面一段代码中第*10*行（或第*9*行）的`1`的类型被推断为它的默认类型`int`， 则在32位架构的机器上，`x`的取值在运行时刻将被截断为*0*，而在64位架构的机器上，`x`的取值在运行时刻将为*232*。 因为`m`是一个变量，在32位架构的机器上，第*9*行和第*10*行并不会在编译时刻报错。 这将导致Go程序员在不经意间写出没有料到的和难以觉察的bug。 因此，第*9*行和第*10*行中的`1`的类型被推断为`int64`（最终的设想结果类型），而不是它们的默认类型`int`。

下面这段代码展示了对于左操作数为类型不确定值的移位运算，编译结果因右操作数是否为常量而带来的不同结果：

```go
const n = uint(2)
var m = uint(2)

// 这两行编译没问题。
var _ float64 = 1 << n
var _ = float64(1 << n)

// 这两行编译失败。
var _ float64 = 1 << m  // error
var _ = float64(1 << m) // error
```

上面这段代码最后两行编译失败是因为它们都等价于下面这两行：

```go
var _ = float64(1) << m
var _ = 1.0 << m // error: shift of type float64
```

另一个例子：

```go
package main

const n = uint(8)
var m = uint(8)

func main() {
	println(a, b) // 2 0
}

var a byte = 1 << n / 128
var b byte = 1 << m / 128
```

上面这个程序打印出`2 0`，因为最后两行等价于：

```go
var a = byte(int(1) << n / 128)
var b = byte(1) << m / 128
```

#### 关于除法和余数运算

假设两个操作数`x`和`y`的类型为同一个整数类型， 则它们通过除法和余数运算得到的商`q`（`= x / y`）和余数`r`（`= x % y`）满足`x == q*y + r`（`|r| < |y|`）。如果余数`r`不为零，则它的符号和被除数`x`相同。商`q`的结果为`x / y`向零靠拢截断。

如果除数`y`是一个常量，则它必须不为0，否则编译不通过。 如果它是一个整数型非常量，则在运行时刻将抛出一个恐慌（panic）。 恐慌类似于某些其它语言中的异常（exception）。  如果除数`y`非整数型的非常量，则运算结果为一个无穷大（Inf，当被除数不为0时）或者NaN（not a number，当被除数为0时）。

示例：

```go
println( 5/3,   5%3)  // 1 2
println( 5/-3,  5%-3) // -1 2
println(-5/3,  -5%3)  // -1 -2
println(-5/-3, -5%-3) // 1 -2

println(5.0 / 3.0)     // 1.666667
println((1-1i)/(1+1i)) // -1i

var a, b = 1.0, 0.0
println(a/b, b/b) // +Inf NaN

_ = int(a)/int(b) // 编译没问题，但在运行时刻将造成恐慌。

// 这两行编译不通过。
println(1.0/0.0) // error: 除数为0
println(0.0/0.0) // error: 除数为0
```

#### `op=`运算符

对于一个二元算数运算符`op`，语句`x = x op y`可以被简写为`x op= y`。 在这个简写的语句中，`x`只会被估值一次。

示例：

```go
var a, b int8 = 3, 5
a += b
println(a) // 8
a *= a
println(a) // 64
a /= b
println(a) // 12
a %= b
println(a) // 2
b <<= uint(a)
println(b) // 20
```

#### 自增和自减操作符

和很多其它流行语言一样，Go也支持自增（`++`）和自减（`--`）操作符。 不过和其它语言不一样的是，自增（`aNumber++`）和自减（`aNumber--`）操作没有返回值， 所以它们不能当做表达式来使用。 另一个显著区别是，在Go中，自增（`++`）和自减（`--`）操作符只能后置，不能前置。

一个例子：

```go
package main

func main() {
	a, b, c := 12, 1.2, 1+2i
	a++ // ok. <=> a += 1 <=> a = a + 1
	b-- // ok. <=> b -= 1 <=> b = b - 1
	c++ // ok.

	// 下面这些行编译不通过。
	/*
	_ = a++
	_ = b--
	_ = c++
	++a
	--b
	++c
	*/
}
```

### 字符串衔接运算符

加法运算符可用做字符串衔接运算符。

| 字面形式 | 名称       | 对两个操作数的要求                   |
| -------- | ---------- | ------------------------------------ |
| +        | 字符串衔接 | 两个操作数必须为同一类型的字符串值。 |

`+=`运算符也适用于字符串衔接。

示例：

```go
println("Go" + "lang") // Golang
var a = "Go"
a += "lang"
println(a) // Golang
```

如果一个字符串衔接运算中的一个操作值为类型确定的，则结果字符串是一个类型和此操作数类型相同的类型确定值。 否则，结果字符串是一个类型不确定值（肯定是一个常量）。

### 布尔（又称逻辑）运算符

Go支持两种布尔二元运算符和一种布尔一元运算符。

| 字面形式 | 名称           | 对操作值的要求                             |
| -------- | -------------- | ------------------------------------------ |
| &&       | 布尔与（二元） | 两个操作值的类型必须为同一布尔类型。       |
| \|\|     | 布尔或（二元） |                                            |
| !        | 布尔否（一元） | 唯一的一个操作值的类型必须为一个布尔类型。 |

我们可以用即将介绍的不等于操作符`!=`来做为布尔异或操作符。

机理解释：

```go
// x    y       x && y   x || y   !x      !y
true    true    true     true     false   false
true    false   false    true     false   true
false   true    false    true     true    false
false   false   false    false    true    true
```

如果一个布尔运算中的一个操作值为类型确定的，则结果为一个和此操作值类型相同的类型确定值。 否则，结果为一个类型不确定布尔值。

### 比较运算符

Go支持6种比较运算符：

| 字面形式 | 名称       | 对两个操作值的要求                                           |
| -------- | ---------- | ------------------------------------------------------------ |
| ==       | 等于       | 如果两个操作数都为类型确定的，则它们的类型必须一样，或者其中一个操作数可以隐式转换为另一个操作数的类型。 两者的类型必须都为可比较类型（将在以后的文章中介绍）。如果只有一个操作数是类型确定的，则另一个类型不确定操作数必须可以隐式转换到类型确定操作数的类型。如果两个操作数都是类型不确定的，则它们必须同时为两个类型不确定布尔值、两个类型不确定字符串值或者两个类型不确定数字值。 |
| !=       | 不等于     | 同 ==                                                        |
| <        | 小于       | 两个操作值的类型必须相同并且它们的类型必须为整数类型、浮点数类型或者字符串类型。 |
| <=       | 小于或等于 | 同 <                                                         |
| >        | 大于       | 同 <                                                         |
| >=       | 大于或等于 | 同 <                                                         |

比较运算的结果总是一个类型不确定布尔值。 如果一个比较运算中的两个操作数都为常量，则结果布尔值也为一个常量。

如果我们说两个值可以比较，我们的意思是说这两个值可以用`==`或者`!=`运算符来比较。我们将了解到某些类型的值是不能比较的。

注意，并非所有的实数在内存中都可以被精确地表示，所以比较两个浮点数或者复数的结果并不是很可靠。 在编程中，我们常常比较两个浮点数的差值是否小于一个阙值来检查两个浮点数是否相等。

### 操作符运算的优先级

Go中的操作符运算的优先级和其它流行语言有一些差别。 下面列出了本文介绍的操作符的优先级。 同一行中的操作符的优先级是一样的。优先级逐行递减。

```go
*   /   %   <<  >>  &   &^
+   -   |   ^
==  !=  <   <=  >   >=
&&
||
```

一个和其它流行语言明显的差别是，移位运算`<<`和`>>`的优先级比加减法`+`和`-`的优先级要高。

一个表达式（做为一个子表达式）可以出现在另一个表达式中。 这个子表达式的估值结果将成为另一个表达式的一个操作数。 在这样的复杂表达式中，对于相同优先级的运算，它们将从左到右进行估值。 和很多其它语言一样，我们也可用一对小括号`()`来提升一个子运算的优先级。

### 更多关于常量表达式

常量子表达式的顺序有可能影响到最终的估值结果。

下面这个声明的变量将被初始化为`2.2`，而不是`2.7`。 优先级更高的子表达式`3/2`是一个常量表达式，所以它将在编译阶段被估值。 根据上面介绍的规则，在运算中，`3`和`2`都被视为`int`，所以`3/2`的估值结果为`1`。 在常量表达式`1.2 + 1`的运算中，两个操作数的类型被视为`float64`，所以最终的估值结果为`2.2`。

```go
var x = 1.2 + 3/2
```

再比如下例，在一个常量声明中，`3/2`先被估值，其结果为`1`，所以最终的估值结果为`0.1`。 在第二个常量声明中，`0.1*3`先被估值，其结果为`0.3`，所以最终的估值结果为`0.15`。

```go
package main

const x = 3/2*0.1
const y = 0.1*3/2

func main() {
	println(x) // +1.000000e-001
	println(y) // +1.500000e-001
}
```

### 更多其它操作符

Go中还有一些其它操作符。它们将在后续介绍。

------



## 函数声明和调用
